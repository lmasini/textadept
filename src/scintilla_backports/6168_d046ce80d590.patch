# HG changeset patch
# User Neil <nyamatongwe@gmail.com>
# Date 1491476677 -36000
# Node ID d046ce80d590607515c1ab59513101818e3da415
# Parent  797ed6c538fdb3de395888cf46e847a617c48f60
Added const where possible.

diff -r 797ed6c538fd -r d046ce80d590 include/Platform.h
--- a/include/Platform.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/include/Platform.h	Thu Apr 06 21:04:37 2017 +1000
@@ -136,7 +136,7 @@
 
 	// Other automatically defined methods (assignment, copy constructor, destructor) are fine
 
-	bool operator==(PRectangle &rc) const {
+	bool operator==(const PRectangle &rc) const {
 		return (rc.left == left) && (rc.right == right) &&
 			(rc.top == top) && (rc.bottom == bottom);
 	}
diff -r 797ed6c538fd -r d046ce80d590 lexlib/Accessor.cxx
--- a/lexlib/Accessor.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/Accessor.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -29,7 +29,7 @@
 }
 
 int Accessor::IndentAmount(Sci_Position line, int *flags, PFNIsCommentLeader pfnIsCommentLeader) {
-	Sci_Position end = Length();
+	const Sci_Position end = Length();
 	int spaceFlags = 0;
 
 	// Determines the indentation level of the current line and also checks for consistent
@@ -44,7 +44,7 @@
 	Sci_Position posPrev = inPrevPrefix ? LineStart(line-1) : 0;
 	while ((ch == ' ' || ch == '\t') && (pos < end)) {
 		if (inPrevPrefix) {
-			char chPrev = (*this)[posPrev++];
+			const char chPrev = (*this)[posPrev++];
 			if (chPrev == ' ' || chPrev == '\t') {
 				if (chPrev != ch)
 					spaceFlags |= wsInconsistent;
diff -r 797ed6c538fd -r d046ce80d590 lexlib/CharacterCategory.cxx
--- a/lexlib/CharacterCategory.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/CharacterCategory.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -3808,11 +3808,11 @@
 	if (IsIdPattern(character)) {
 		return false;
 	}
-	OtherID oid = OtherIDOfCharacter(character);
+	const OtherID oid = OtherIDOfCharacter(character);
 	if (oid == OtherID::oidStart) {
 		return true;
 	}
-	CharacterCategory c = CategoriseCharacter(character);
+	const CharacterCategory c = CategoriseCharacter(character);
 	return (c == ccLl || c == ccLu || c == ccLt || c == ccLm || c == ccLo
 		|| c == ccNl);
 }
@@ -3823,11 +3823,11 @@
 	if (IsIdPattern(character)) {
 		return false;
 	}
-	OtherID oid = OtherIDOfCharacter(character);
+	const OtherID oid = OtherIDOfCharacter(character);
 	if (oid != OtherID::oidNone) {
 		return true;
 	}
-	CharacterCategory c = CategoriseCharacter(character);
+	const CharacterCategory c = CategoriseCharacter(character);
 	return (c == ccLl || c == ccLu || c == ccLt || c == ccLm || c == ccLo
 		|| c == ccNl || c == ccMn || c == ccMc || c == ccNd || c == ccPc);
 }
diff -r 797ed6c538fd -r d046ce80d590 lexlib/CharacterSet.cxx
--- a/lexlib/CharacterSet.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/CharacterSet.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -22,8 +22,8 @@
 int CompareCaseInsensitive(const char *a, const char *b) {
 	while (*a && *b) {
 		if (*a != *b) {
-			char upperA = static_cast<char>(MakeUpperCase(*a));
-			char upperB = static_cast<char>(MakeUpperCase(*b));
+			const char upperA = static_cast<char>(MakeUpperCase(*a));
+			const char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
@@ -37,8 +37,8 @@
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len) {
 	while (*a && *b && len) {
 		if (*a != *b) {
-			char upperA = static_cast<char>(MakeUpperCase(*a));
-			char upperB = static_cast<char>(MakeUpperCase(*b));
+			const char upperA = static_cast<char>(MakeUpperCase(*a));
+			const char upperB = static_cast<char>(MakeUpperCase(*b));
 			if (upperA != upperB)
 				return upperA - upperB;
 		}
diff -r 797ed6c538fd -r d046ce80d590 lexlib/LexAccessor.h
--- a/lexlib/LexAccessor.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/LexAccessor.h	Thu Apr 06 21:04:37 2017 +1000
@@ -125,7 +125,7 @@
 		} else {
 			// Old interface means only '\r', '\n' and '\r\n' line ends.
 			Sci_Position startNext = pAccess->LineStart(line+1);
-			char chLineEnd = SafeGetCharAt(startNext-1);
+			const char chLineEnd = SafeGetCharAt(startNext-1);
 			if (chLineEnd == '\n' && (SafeGetCharAt(startNext-2)  == '\r'))
 				return startNext - 2;
 			else
diff -r 797ed6c538fd -r d046ce80d590 lexlib/StyleContext.h
--- a/lexlib/StyleContext.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/StyleContext.h	Thu Apr 06 21:04:37 2017 +1000
@@ -130,7 +130,7 @@
 		}
 	}
 	void ForwardBytes(Sci_Position nb) {
-		Sci_PositionU forwardPos = currentPos + nb;
+		const Sci_PositionU forwardPos = currentPos + nb;
 		while (forwardPos > currentPos) {
 			Forward();
 		}
@@ -165,7 +165,7 @@
 			}
 			Sci_Position diffRelative = n - offsetRelative;
 			Sci_Position posNew = multiByteAccess->GetRelativePosition(posRelative, diffRelative);
-			int chReturn = multiByteAccess->GetCharacterAndWidth(posNew, 0);
+			const int chReturn = multiByteAccess->GetCharacterAndWidth(posNew, 0);
 			posRelative = posNew;
 			currentPosLastRelative = currentPos;
 			offsetRelative = n;
diff -r 797ed6c538fd -r d046ce80d590 lexlib/WordList.cxx
--- a/lexlib/WordList.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/lexlib/WordList.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -34,7 +34,7 @@
 		wordSeparator[static_cast<unsigned int>('\t')] = true;
 	}
 	for (int j = 0; wordlist[j]; j++) {
-		int curr = static_cast<unsigned char>(wordlist[j]);
+		const int curr = static_cast<unsigned char>(wordlist[j]);
 		if (!wordSeparator[curr] && wordSeparator[prev])
 			words++;
 		prev = curr;
@@ -143,7 +143,7 @@
 bool WordList::InList(const char *s) const {
 	if (0 == words)
 		return false;
-	unsigned char firstChar = s[0];
+	const unsigned char firstChar = s[0];
 	int j = starts[firstChar];
 	if (j >= 0) {
 		while (static_cast<unsigned char>(words[j][0]) == firstChar) {
@@ -185,7 +185,7 @@
 bool WordList::InListAbbreviated(const char *s, const char marker) const {
 	if (0 == words)
 		return false;
-	unsigned char firstChar = s[0];
+	const unsigned char firstChar = s[0];
 	int j = starts[firstChar];
 	if (j >= 0) {
 		while (static_cast<unsigned char>(words[j][0]) == firstChar) {
@@ -239,7 +239,7 @@
 bool WordList::InListAbridged(const char *s, const char marker) const {
 	if (0 == words)
 		return false;
-	unsigned char firstChar = s[0];
+	const unsigned char firstChar = s[0];
 	int j = starts[firstChar];
 	if (j >= 0) {
 		while (static_cast<unsigned char>(words[j][0]) == firstChar) {
diff -r 797ed6c538fd -r d046ce80d590 src/AutoComplete.cxx
--- a/src/AutoComplete.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/AutoComplete.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -131,9 +131,9 @@
 	}
 
 	bool operator()(int a, int b) {
-		int lenA = indices[a * 2 + 1] - indices[a * 2];
-		int lenB = indices[b * 2 + 1] - indices[b * 2];
-		int len  = std::min(lenA, lenB);
+		const int lenA = indices[a * 2 + 1] - indices[a * 2];
+		const int lenB = indices[b * 2 + 1] - indices[b * 2];
+		const int len  = std::min(lenA, lenB);
 		int cmp;
 		if (ac->ignoreCase)
 			cmp = CompareNCaseInsensitive(list + indices[a * 2], list + indices[b * 2], len);
@@ -217,7 +217,7 @@
 
 
 void AutoComplete::Move(int delta) {
-	int count = lb->Length();
+	const int count = lb->Length();
 	int current = lb->GetSelection();
 	current += delta;
 	if (current >= count)
diff -r 797ed6c538fd -r d046ce80d590 src/CallTip.cxx
--- a/src/CallTip.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/CallTip.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -90,7 +90,7 @@
 	int posStart, int posEnd, int ytext, PRectangle rcClient,
 	bool highlight, bool draw) {
 	s += posStart;
-	int len = posEnd - posStart;
+	const int len = posEnd - posStart;
 
 	// Divide the text into sections that are all text, or that are
 	// single arrows or single tab characters (if tabSize > 0).
@@ -113,7 +113,7 @@
 		if (endSeg > startSeg) {
 			if (IsArrowCharacter(s[startSeg])) {
 				xEnd = x + widthArrow;
-				bool upArrow = s[startSeg] == '\001';
+				const bool upArrow = s[startSeg] == '\001';
 				rcClient.left = static_cast<XYPOSITION>(x);
 				rcClient.right = static_cast<XYPOSITION>(xEnd);
 				if (draw) {
@@ -189,9 +189,9 @@
 			chunkEnd = chunkVal + strlen(chunkVal);
 			moreChunks = false;
 		}
-		int chunkOffset = static_cast<int>(chunkVal - val.c_str());
-		int chunkLength = static_cast<int>(chunkEnd - chunkVal);
-		int chunkEndOffset = chunkOffset + chunkLength;
+		const int chunkOffset = static_cast<int>(chunkVal - val.c_str());
+		const int chunkLength = static_cast<int>(chunkEnd - chunkVal);
+		const int chunkEndOffset = chunkOffset + chunkLength;
 		int thisStartHighlight = std::max(startHighlight, chunkOffset);
 		thisStartHighlight = std::min(thisStartHighlight, chunkEndOffset);
 		thisStartHighlight -= chunkOffset;
diff -r 797ed6c538fd -r d046ce80d590 src/CaseConvert.cxx
--- a/src/CaseConvert.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/CaseConvert.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -708,18 +708,18 @@
 void SetupConversions(enum CaseConversion conversion) {
 	// First initialize for the symmetric ranges
 	for (size_t i=0; i<ELEMENTS(symmetricCaseConversionRanges);) {
-		int lower = symmetricCaseConversionRanges[i++];
-		int upper = symmetricCaseConversionRanges[i++];
-		int length = symmetricCaseConversionRanges[i++];
-		int pitch = symmetricCaseConversionRanges[i++];
+		const int lower = symmetricCaseConversionRanges[i++];
+		const int upper = symmetricCaseConversionRanges[i++];
+		const int length = symmetricCaseConversionRanges[i++];
+		const int pitch = symmetricCaseConversionRanges[i++];
 		for (int j=0; j<length*pitch; j+=pitch) {
 			AddSymmetric(conversion, lower+j, upper+j);
 		}
 	}
 	// Add the symmetric singletons
 	for (size_t i=0; i<ELEMENTS(symmetricCaseConversions);) {
-		int lower = symmetricCaseConversions[i++];
-		int upper = symmetricCaseConversions[i++];
+		const int lower = symmetricCaseConversions[i++];
+		const int upper = symmetricCaseConversions[i++];
 		AddSymmetric(conversion, lower, upper);
 	}
 	// Add the complex cases
diff -r 797ed6c538fd -r d046ce80d590 src/CellBuffer.cxx
--- a/src/CellBuffer.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/CellBuffer.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -162,7 +162,7 @@
 	// as two actions may be created by the calling function
 	if (currentAction >= (lenActions - 2)) {
 		// Run out of undo nodes so extend the array
-		int lenActionsNew = lenActions * 2;
+		const int lenActionsNew = lenActions * 2;
 		Action *actionsNew = new Action[lenActionsNew];
 		for (int act = 0; act <= currentAction; act++)
 			actionsNew[act].Grab(&actions[act]);
@@ -240,7 +240,7 @@
 		currentAction++;
 	}
 	startSequence = oldCurrentAction != currentAction;
-	int actionWithData = currentAction;
+	const int actionWithData = currentAction;
 	actions[currentAction].Create(at, position, data, lengthData, mayCoalesce);
 	currentAction++;
 	actions[currentAction].Create(startAction);
@@ -439,7 +439,7 @@
 }
 
 bool CellBuffer::SetStyleAt(Sci::Position position, char styleValue) {
-	char curVal = style.ValueAt(position);
+	const char curVal = style.ValueAt(position);
 	if (curVal != styleValue) {
 		style.SetValueAt(position, styleValue);
 		return true;
@@ -453,7 +453,7 @@
 	PLATFORM_ASSERT(lengthStyle == 0 ||
 		(lengthStyle > 0 && lengthStyle + position <= style.Length()));
 	while (lengthStyle--) {
-		char curVal = style.ValueAt(position);
+		const char curVal = style.ValueAt(position);
 		if (curVal != styleValue) {
 			style.SetValueAt(position, styleValue);
 			changed = true;
@@ -505,7 +505,7 @@
 		if ((ch == '\r') || (ch == '\n')) {
 			return true;
 		} else if (utf8LineEnds) {
-			unsigned char back3[3] = { chBeforePrev, chPrev, ch };
+			const unsigned char back3[3] = { chBeforePrev, chPrev, ch };
 			if (UTF8IsSeparator(back3) || UTF8IsNEL(back3 + 1)) {
 				return true;
 			}
@@ -576,7 +576,7 @@
 }
 
 bool CellBuffer::UTF8LineEndOverlaps(Sci::Position position) const {
-	unsigned char bytes[] = {
+	const unsigned char bytes[] = {
 		static_cast<unsigned char>(substance.ValueAt(position-2)),
 		static_cast<unsigned char>(substance.ValueAt(position-1)),
 		static_cast<unsigned char>(substance.ValueAt(position)),
@@ -597,7 +597,7 @@
 	unsigned char chBeforePrev = 0;
 	unsigned char chPrev = 0;
 	for (Sci::Position i = 0; i < length; i++) {
-		unsigned char ch = substance.ValueAt(position + i);
+		const unsigned char ch = substance.ValueAt(position + i);
 		if (ch == '\r') {
 			InsertLine(lineInsert, (position + i) + 1, atLineStart);
 			lineInsert++;
@@ -610,7 +610,7 @@
 				lineInsert++;
 			}
 		} else if (utf8LineEnds) {
-			unsigned char back3[3] = {chBeforePrev, chPrev, ch};
+			const unsigned char back3[3] = {chBeforePrev, chPrev, ch};
 			if (UTF8IsSeparator(back3) || UTF8IsNEL(back3+1)) {
 				InsertLine(lineInsert, (position + i) + 1, atLineStart);
 				lineInsert++;
@@ -626,7 +626,7 @@
 		return;
 	PLATFORM_ASSERT(insertLength > 0);
 
-	unsigned char chAfter = substance.ValueAt(position);
+	const unsigned char chAfter = substance.ValueAt(position);
 	bool breakingUTF8LineEnd = false;
 	if (utf8LineEnds && UTF8IsTrailByte(chAfter)) {
 		breakingUTF8LineEnd = UTF8LineEndOverlaps(position);
@@ -664,7 +664,7 @@
 				lineInsert++;
 			}
 		} else if (utf8LineEnds) {
-			unsigned char back3[3] = {chBeforePrev, chPrev, ch};
+			const unsigned char back3[3] = {chBeforePrev, chPrev, ch};
 			if (UTF8IsSeparator(back3) || UTF8IsNEL(back3+1)) {
 				InsertLine(lineInsert, (position + i) + 1, atLineStart);
 				lineInsert++;
@@ -682,8 +682,8 @@
 	} else if (utf8LineEnds && !UTF8IsAscii(chAfter)) {
 		// May have end of UTF-8 line end in buffer and start in insertion
 		for (int j = 0; j < UTF8SeparatorLength-1; j++) {
-			unsigned char chAt = substance.ValueAt(position + insertLength + j);
-			unsigned char back3[3] = {chBeforePrev, chPrev, chAt};
+			const unsigned char chAt = substance.ValueAt(position + insertLength + j);
+			const unsigned char back3[3] = {chBeforePrev, chPrev, chAt};
 			if (UTF8IsSeparator(back3)) {
 				InsertLine(lineInsert, (position + insertLength + j) + 1, atLineStart);
 				lineInsert++;
@@ -712,8 +712,8 @@
 
 		Sci::Line lineRemove = lv.LineFromPosition(position) + 1;
 		lv.InsertText(lineRemove-1, - (deleteLength));
-		unsigned char chPrev = substance.ValueAt(position - 1);
-		unsigned char chBefore = chPrev;
+		const unsigned char chPrev = substance.ValueAt(position - 1);
+		const unsigned char chBefore = chPrev;
 		unsigned char chNext = substance.ValueAt(position);
 		bool ignoreNL = false;
 		if (chPrev == '\r' && chNext == '\n') {
@@ -743,7 +743,7 @@
 				}
 			} else if (utf8LineEnds) {
 				if (!UTF8IsAscii(ch)) {
-					unsigned char next3[3] = {ch, chNext,
+					const unsigned char next3[3] = {ch, chNext,
 						static_cast<unsigned char>(substance.ValueAt(position + i + 2))};
 					if (UTF8IsSeparator(next3) || UTF8IsNEL(next3)) {
 						RemoveLine(lineRemove);
@@ -755,7 +755,7 @@
 		}
 		// May have to fix up end if last deletion causes cr to be next to lf
 		// or removes one of a crlf pair
-		char chAfter = substance.ValueAt(position + deleteLength);
+		const char chAfter = substance.ValueAt(position + deleteLength);
 		if (chBefore == '\r' && chAfter == '\n') {
 			// Using lineRemove-1 as cr ended line before start of deletion
 			RemoveLine(lineRemove - 1);
diff -r 797ed6c538fd -r d046ce80d590 src/Decoration.cxx
--- a/src/Decoration.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Decoration.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -125,7 +125,7 @@
 			current = Create(currentIndicator, lengthDocument);
 		}
 	}
-	bool changed = current->rs.FillRange(position, value, fillLength);
+	const bool changed = current->rs.FillRange(position, value, fillLength);
 	if (current->Empty()) {
 		Delete(currentIndicator);
 	}
@@ -177,7 +177,7 @@
 }
 
 int DecorationList::ValueAt(int indicator, int position) {
-	Decoration *deco = DecorationFromIndicator(indicator);
+	const Decoration *deco = DecorationFromIndicator(indicator);
 	if (deco) {
 		return deco->rs.ValueAt(position);
 	}
@@ -185,7 +185,7 @@
 }
 
 int DecorationList::Start(int indicator, int position) {
-	Decoration *deco = DecorationFromIndicator(indicator);
+	const Decoration *deco = DecorationFromIndicator(indicator);
 	if (deco) {
 		return deco->rs.StartRun(position);
 	}
@@ -193,7 +193,7 @@
 }
 
 int DecorationList::End(int indicator, int position) {
-	Decoration *deco = DecorationFromIndicator(indicator);
+	const Decoration *deco = DecorationFromIndicator(indicator);
 	if (deco) {
 		return deco->rs.EndRun(position);
 	}
diff -r 797ed6c538fd -r d046ce80d590 src/Document.cxx
--- a/src/Document.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Document.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -84,7 +84,7 @@
 
 int LexInterface::LineEndTypesSupported() {
 	if (instance) {
-		int interfaceVersion = instance->Version();
+		const int interfaceVersion = instance->Version();
 		if (interfaceVersion >= lvSubStyles) {
 			ILexerWithSubStyles *ssinstance = static_cast<ILexerWithSubStyles *>(instance);
 			return ssinstance->LineEndTypesSupported();
@@ -211,7 +211,7 @@
 // Decrease reference count and return its previous value.
 // Delete the document if reference count reaches zero.
 int SCI_METHOD Document::Release() {
-	int curRefCount = --refCount;
+	const int curRefCount = --refCount;
 	if (curRefCount == 0)
 		delete this;
 	return curRefCount;
@@ -229,9 +229,9 @@
 	if (enteredModification == 0) {
 		enteredModification++;
 		if (!cb.IsReadOnly()) {
-			bool startSavePoint = cb.IsSavePoint();
+			const bool startSavePoint = cb.IsSavePoint();
 			bool multiLine = false;
-			int steps = cb.TentativeSteps();
+			const int steps = cb.TentativeSteps();
 			//Platform::DebugPrintf("Steps=%d\n", steps);
 			for (int step = 0; step < steps; step++) {
 				const Sci::Line prevLinesTotal = LinesTotal();
@@ -293,7 +293,7 @@
 
 int Document::AddMark(Sci::Line line, int markerNum) {
 	if (line >= 0 && line <= LinesTotal()) {
-		int prev = static_cast<LineMarkers *>(perLineData[ldMarkers])->
+		const int prev = static_cast<LineMarkers *>(perLineData[ldMarkers])->
 			AddMark(line, markerNum, LinesTotal());
 		DocModification mh(SC_MOD_CHANGEMARKER, LineStart(line), 0, 0, 0, line);
 		NotifyModified(mh);
@@ -360,7 +360,7 @@
 	} else {
 		Sci::Position position = LineStart(line + 1);
 		if (SC_CP_UTF8 == dbcsCodePage) {
-			unsigned char bytes[] = {
+			const unsigned char bytes[] = {
 				static_cast<unsigned char>(cb.CharAt(position-3)),
 				static_cast<unsigned char>(cb.CharAt(position-2)),
 				static_cast<unsigned char>(cb.CharAt(position-1)),
@@ -407,7 +407,7 @@
 Sci::Position Document::VCHomePosition(Sci::Position position) const {
 	Sci::Line line = LineFromPosition(position);
 	Sci::Position startPosition = LineStart(line);
-	Sci::Position endLine = LineEnd(line);
+	const Sci::Position endLine = LineEnd(line);
 	Sci::Position startText = startPosition;
 	while (startText < endLine && (cb.CharAt(startText) == ' ' || cb.CharAt(startText) == '\t'))
 		startText++;
@@ -418,7 +418,7 @@
 }
 
 int SCI_METHOD Document::SetLevel(Sci_Position line, int level) {
-	int prev = static_cast<LineLevels *>(perLineData[ldLevels])->SetLevel(line, level, LinesTotal());
+	const int prev = static_cast<LineLevels *>(perLineData[ldLevels])->SetLevel(line, level, LinesTotal());
 	if (prev != level) {
 		DocModification mh(SC_MOD_CHANGEFOLD | SC_MOD_CHANGEMARKER,
 		                   LineStart(line), 0, 0, 0, line);
@@ -447,8 +447,8 @@
 Sci::Line Document::GetLastChild(Sci::Line lineParent, int level, Sci::Line lastLine) {
 	if (level == -1)
 		level = LevelNumber(GetLevel(lineParent));
-	Sci::Line maxLine = LinesTotal();
-	Sci::Line lookLastLine = (lastLine != -1) ? std::min(LinesTotal() - 1, lastLine) : -1;
+	const Sci::Line maxLine = LinesTotal();
+	const Sci::Line lookLastLine = (lastLine != -1) ? std::min(LinesTotal() - 1, lastLine) : -1;
 	Sci::Line lineMaxSubord = lineParent;
 	while (lineMaxSubord < maxLine - 1) {
 		EnsureStyledTo(LineStart(lineMaxSubord + 2));
@@ -470,7 +470,7 @@
 }
 
 Sci::Line Document::GetFoldParent(Sci::Line line) const {
-	int level = LevelNumber(GetLevel(line));
+	const int level = LevelNumber(GetLevel(line));
 	Sci::Line lineLook = line - 1;
 	while ((lineLook > 0) && (
 	            (!(GetLevel(lineLook) & SC_FOLDLEVELHEADERFLAG)) ||
@@ -487,7 +487,7 @@
 }
 
 void Document::GetHighlightDelimiters(HighlightDelimiter &highlightDelimiter, Sci::Line line, Sci::Line lastLine) {
-	int level = GetLevel(line);
+	const int level = GetLevel(line);
 	Sci::Line lookLastLine = std::max(line, lastLine) + 1;
 
 	Sci::Line lookLine = line;
@@ -599,15 +599,15 @@
 	if (widthCharBytes == 1) {
 		return false;
 	} else {
-		int trailBytes = widthCharBytes - 1;
-		Sci::Position len = pos - start;
+		const int trailBytes = widthCharBytes - 1;
+		const Sci::Position len = pos - start;
 		if (len > trailBytes)
 			// pos too far from lead
 			return false;
 		char charBytes[UTF8MaxBytes] = {static_cast<char>(leadByte),0,0,0};
 		for (int b=1; b<widthCharBytes && ((start+b) < Length()); b++)
 			charBytes[b] = cb.CharAt(static_cast<Sci::Position>(start+b));
-		int utf8status = UTF8Classify(reinterpret_cast<const unsigned char *>(charBytes), widthCharBytes);
+		const int utf8status = UTF8Classify(reinterpret_cast<const unsigned char *>(charBytes), widthCharBytes);
 		if (utf8status & UTF8MaskInvalid)
 			return false;
 		end = start + widthCharBytes;
@@ -638,7 +638,7 @@
 
 	if (dbcsCodePage) {
 		if (SC_CP_UTF8 == dbcsCodePage) {
-			unsigned char ch = static_cast<unsigned char>(cb.CharAt(pos));
+			const unsigned char ch = static_cast<unsigned char>(cb.CharAt(pos));
 			// If ch is not a trail byte then pos is valid intercharacter position
 			if (UTF8IsTrailByte(ch)) {
 				Sci::Position startUTF = pos;
@@ -655,7 +655,7 @@
 		} else {
 			// Anchor DBCS calculations at start of line because start of line can
 			// not be a DBCS trail byte.
-			Sci::Position posStartLine = LineStart(LineFromPosition(pos));
+			const Sci::Position posStartLine = LineStart(LineFromPosition(pos));
 			if (pos == posStartLine)
 				return pos;
 
@@ -717,7 +717,7 @@
 			} else {
 				// Examine byte before position
 				pos--;
-				unsigned char ch = static_cast<unsigned char>(cb.CharAt(pos));
+				const unsigned char ch = static_cast<unsigned char>(cb.CharAt(pos));
 				// If ch is not a trail byte then pos is valid intercharacter position
 				if (UTF8IsTrailByte(ch)) {
 					// If ch is a trail byte in a valid UTF-8 character then return start of character
@@ -738,7 +738,7 @@
 			} else {
 				// Anchor DBCS calculations at start of line because start of line can
 				// not be a DBCS trail byte.
-				Sci::Position posStartLine = LineStart(LineFromPosition(pos));
+				const Sci::Position posStartLine = LineStart(LineFromPosition(pos));
 				// See http://msdn.microsoft.com/en-us/library/cc194792%28v=MSDN.10%29.aspx
 				// http://msdn.microsoft.com/en-us/library/cc194790.aspx
 				if ((pos - 1) <= posStartLine) {
@@ -902,7 +902,7 @@
 				unsigned char charBytes[UTF8MaxBytes] = {leadByte,0,0,0};
 				for (int b=1; b<widthCharBytes; b++)
 					charBytes[b] = static_cast<unsigned char>(cb.CharAt(position+b));
-				int utf8status = UTF8Classify(charBytes, widthCharBytes);
+				const int utf8status = UTF8Classify(charBytes, widthCharBytes);
 				if (utf8status & UTF8MaskInvalid) {
 					// Report as singleton surrogate values which are invalid Unicode
 					character =  0xDC80 + leadByte;
@@ -934,7 +934,7 @@
 
 bool SCI_METHOD Document::IsDBCSLeadByte(char ch) const {
 	// Byte ranges found in Wikipedia articles with relevant search strings in each case
-	unsigned char uch = static_cast<unsigned char>(ch);
+	const unsigned char uch = static_cast<unsigned char>(ch);
 	switch (dbcsCodePage) {
 		case 932:
 			// Shift_jis
@@ -982,7 +982,7 @@
 	int lastPunctuationBreak = -1;
 	int lastEncodingAllowedBreak = 0;
 	for (int j=0; j < lengthSegment;) {
-		unsigned char ch = static_cast<unsigned char>(text[j]);
+		const unsigned char ch = static_cast<unsigned char>(text[j]);
 		if (j > 0) {
 			if (IsSpaceOrTab(text[j - 1]) && !IsSpaceOrTab(text[j])) {
 				lastSpaceBreak = j;
@@ -1150,9 +1150,9 @@
 	if ((enteredModification == 0) && (cb.IsCollectingUndo())) {
 		enteredModification++;
 		if (!cb.IsReadOnly()) {
-			bool startSavePoint = cb.IsSavePoint();
+			const bool startSavePoint = cb.IsSavePoint();
 			bool multiLine = false;
-			int steps = cb.StartUndo();
+			const int steps = cb.StartUndo();
 			//Platform::DebugPrintf("Steps=%d\n", steps);
 			Sci::Position coalescedRemovePos = -1;
 			Sci::Position coalescedRemoveLen = 0;
@@ -1235,9 +1235,9 @@
 	if ((enteredModification == 0) && (cb.IsCollectingUndo())) {
 		enteredModification++;
 		if (!cb.IsReadOnly()) {
-			bool startSavePoint = cb.IsSavePoint();
+			const bool startSavePoint = cb.IsSavePoint();
 			bool multiLine = false;
-			int steps = cb.StartRedo();
+			const int steps = cb.StartRedo();
 			for (int step = 0; step < steps; step++) {
 				const Sci::Line prevLinesTotal = LinesTotal();
 				const Action &action = cb.GetRedoStep();
@@ -1328,10 +1328,10 @@
 int SCI_METHOD Document::GetLineIndentation(Sci_Position line) {
 	int indent = 0;
 	if ((line >= 0) && (line < LinesTotal())) {
-		Sci::Position lineStart = LineStart(line);
-		Sci::Position length = Length();
+		const Sci::Position lineStart = LineStart(line);
+		const Sci::Position length = Length();
 		for (Sci::Position i = lineStart; i < length; i++) {
-			char ch = cb.CharAt(i);
+			const char ch = cb.CharAt(i);
 			if (ch == ' ')
 				indent++;
 			else if (ch == '\t')
@@ -1344,7 +1344,7 @@
 }
 
 Sci::Position Document::SetLineIndentation(Sci::Line line, Sci::Position indent) {
-	int indentOfLine = GetLineIndentation(line);
+	const int indentOfLine = GetLineIndentation(line);
 	if (indent < 0)
 		indent = 0;
 	if (indent != indentOfLine) {
@@ -1364,7 +1364,7 @@
 	if (line < 0)
 		return 0;
 	Sci::Position pos = LineStart(line);
-	Sci::Position length = Length();
+	const Sci::Position length = Length();
 	while ((pos < length) && IsSpaceOrTab(cb.CharAt(pos))) {
 		pos++;
 	}
@@ -1376,7 +1376,7 @@
 	Sci::Line line = LineFromPosition(pos);
 	if ((line >= 0) && (line < LinesTotal())) {
 		for (Sci::Position i = LineStart(line); i < pos;) {
-			char ch = cb.CharAt(i);
+			const char ch = cb.CharAt(i);
 			if (ch == '\t') {
 				column = NextTab(column, tabInChars);
 				i++;
@@ -1427,7 +1427,7 @@
 	if ((line >= 0) && (line < LinesTotal())) {
 		Sci::Position columnCurrent = 0;
 		while ((columnCurrent < column) && (position < Length())) {
-			char ch = cb.CharAt(position);
+			const char ch = cb.CharAt(position);
 			if (ch == '\t') {
 				columnCurrent = NextTab(columnCurrent, tabInChars);
 				if (columnCurrent > column)
@@ -1524,7 +1524,7 @@
 
 bool Document::IsWhiteLine(Sci::Line line) const {
 	Sci::Position currentChar = LineStart(line);
-	Sci::Position endLine = LineEnd(line);
+	const Sci::Position endLine = LineEnd(line);
 	while (currentChar < endLine) {
 		if (cb.CharAt(currentChar) != ' ' && cb.CharAt(currentChar) != '\t') {
 			return false;
@@ -1718,7 +1718,7 @@
 	if (delta < 0) {
 		if (pos > 0) {
 			CharacterExtracted ce = CharacterBefore(pos);
-			CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			const CharClassify::cc ccStart = WordCharacterClass(ce.character);
 			if (ccStart != CharClassify::ccSpace) {
 				while (pos > 0) {
 					ce = CharacterBefore(pos);
@@ -1743,7 +1743,7 @@
 		}
 		if (pos < Length()) {
 			CharacterExtracted ce = CharacterAfter(pos);
-			CharClassify::cc ccStart = WordCharacterClass(ce.character);
+			const CharClassify::cc ccStart = WordCharacterClass(ce.character);
 			while (pos < Length()) {
 				ce = CharacterAfter(pos);
 				if (WordCharacterClass(ce.character) != ccStart)
@@ -2125,7 +2125,7 @@
 }
 
 int SCI_METHOD Document::SetLineState(Sci_Position line, int state) {
-	int statePrevious = static_cast<LineState *>(perLineData[ldState])->SetLineState(line, state);
+	const int statePrevious = static_cast<LineState *>(perLineData[ldState])->SetLineState(line, state);
 	if (state != statePrevious) {
 		DocModification mh(SC_MOD_CHANGELINESTATE, LineStart(line), 0, 0, 0, line);
 		NotifyModified(mh);
@@ -2147,7 +2147,7 @@
 }
 
 StyledText Document::MarginStyledText(Sci::Line line) const {
-	LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldMargin]);
+	const LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldMargin]);
 	return StyledText(pla->Length(line), pla->Text(line),
 		pla->MultipleStyles(line), pla->Style(line), pla->Styles(line));
 }
@@ -2169,7 +2169,7 @@
 }
 
 void Document::MarginClearAll() {
-	Sci::Line maxEditorLine = LinesTotal();
+	const Sci::Line maxEditorLine = LinesTotal();
 	for (Sci::Line l=0; l<maxEditorLine; l++)
 		MarginSetText(l, 0);
 	// Free remaining data
@@ -2177,7 +2177,7 @@
 }
 
 StyledText Document::AnnotationStyledText(Sci::Line line) const {
-	LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldAnnotation]);
+	const LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldAnnotation]);
 	return StyledText(pla->Length(line), pla->Text(line),
 		pla->MultipleStyles(line), pla->Style(line), pla->Styles(line));
 }
@@ -2210,7 +2210,7 @@
 }
 
 void Document::AnnotationClearAll() {
-	Sci::Line maxEditorLine = LinesTotal();
+	const Sci::Line maxEditorLine = LinesTotal();
 	for (Sci::Line l=0; l<maxEditorLine; l++)
 		AnnotationSetText(l, 0);
 	// Free remaining data
@@ -2416,7 +2416,7 @@
 }
 
 Sci::Position Document::ExtendStyleRange(Sci::Position pos, int delta, bool singleLine) {
-	int sStart = cb.StyleAt(pos);
+	const int sStart = cb.StyleAt(pos);
 	if (delta < 0) {
 		while (pos > 0 && (cb.StyleAt(pos) == sStart) && (!singleLine || !IsLineEndChar(cb.CharAt(pos))))
 			pos--;
@@ -2453,8 +2453,8 @@
 
 // TODO: should be able to extend styled region to find matching brace
 Sci::Position Document::BraceMatch(Sci::Position position, Sci::Position /*maxReStyle*/) {
-	char chBrace = CharAt(position);
-	char chSeek = BraceOpposite(chBrace);
+	const char chBrace = CharAt(position);
+	const char chSeek = BraceOpposite(chBrace);
 	if (chSeek == '\0')
 		return - 1;
 	const int styBrace = StyleIndexAt(position);
@@ -2464,7 +2464,7 @@
 	int depth = 1;
 	position = NextPosition(position, direction);
 	while ((position >= 0) && (position < Length())) {
-		char chAtPos = CharAt(position);
+		const char chAtPos = CharAt(position);
 		const int styAtPos = StyleIndexAt(position);
 		if ((position > GetEndStyled()) || (styAtPos == styBrace)) {
 			if (chAtPos == chBrace)
@@ -2474,7 +2474,7 @@
 			if (depth == 0)
 				return position;
 		}
-		Sci::Position positionBeforeMove = position;
+		const Sci::Position positionBeforeMove = position;
 		position = NextPosition(position, direction);
 		if (position == positionBeforeMove)
 			break;
@@ -2740,7 +2740,7 @@
 	}
 private:
 	void ReadCharacter() {
-		Document::CharacterExtracted charExtracted = doc->ExtractCharacter(position);
+		const Document::CharacterExtracted charExtracted = doc->ExtractCharacter(position);
 		lenBytes = charExtracted.widthBytes;
 		if (charExtracted.character == unicodeReplacementChar) {
 			lenCharacters = 1;
diff -r 797ed6c538fd -r d046ce80d590 src/EditView.cxx
--- a/src/EditView.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/EditView.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -244,7 +244,7 @@
 }
 
 int EditView::GetNextTabstop(Sci::Line line, int x) const {
-	LineTabstops *lt = static_cast<LineTabstops *>(ldTabstops);
+	const LineTabstops *lt = static_cast<LineTabstops *>(ldTabstops);
 	if (lt) {
 		return lt->GetNextTabstop(line, x);
 	} else {
@@ -386,7 +386,7 @@
 			int numCharsInLine = 0;
 			while (numCharsInLine < lineLength) {
 				Sci::Position charInDoc = numCharsInLine + posLineStart;
-				char chDoc = model.pdoc->CharAt(charInDoc);
+				const char chDoc = model.pdoc->CharAt(charInDoc);
 				styleByte = model.pdoc->StyleIndexAt(charInDoc);
 				allSame = allSame &&
 					(ll->styles[numCharsInLine] == styleByte);
@@ -435,7 +435,7 @@
 		const int lineLength = posLineEnd - posLineStart;
 		model.pdoc->GetCharRange(ll->chars, posLineStart, lineLength);
 		model.pdoc->GetStyleRange(ll->styles, posLineStart, lineLength);
-		int numCharsBeforeEOL = model.pdoc->LineEnd(line) - posLineStart;
+		const int numCharsBeforeEOL = model.pdoc->LineEnd(line) - posLineStart;
 		const int numCharsInLine = (vstyle.viewEOL) ? lineLength : numCharsBeforeEOL;
 		for (Sci::Position styleInLine = 0; styleInLine < numCharsInLine; styleInLine++) {
 			const unsigned char styleByte = ll->styles[styleInLine];
@@ -444,7 +444,7 @@
 		const unsigned char styleByteLast = (lineLength > 0) ? ll->styles[lineLength - 1] : 0;
 		if (vstyle.someStylesForceCase) {
 			for (int charInLine = 0; charInLine<lineLength; charInLine++) {
-				char chDoc = ll->chars[charInLine];
+				const char chDoc = ll->chars[charInLine];
 				if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseUpper)
 					ll->chars[charInLine] = static_cast<char>(MakeUpperCase(chDoc));
 				else if (vstyle.styles[ll->styles[charInLine]].caseForce == Style::caseLower)
@@ -721,13 +721,13 @@
 }
 
 Sci::Line EditView::DisplayFromPosition(Surface *surface, const EditModel &model, Sci::Position pos, const ViewStyle &vs) {
-	Sci::Line lineDoc = model.pdoc->LineFromPosition(pos);
+	const Sci::Line lineDoc = model.pdoc->LineFromPosition(pos);
 	Sci::Line lineDisplay = model.cs.DisplayFromDoc(lineDoc);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
-		Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
-		Sci::Position posInLine = pos - posLineStart;
+		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
+		const Sci::Position posInLine = pos - posLineStart;
 		lineDisplay--; // To make up for first increment ahead.
 		for (int subLine = 0; subLine < ll->lines; subLine++) {
 			if (posInLine >= ll->LineStart(subLine)) {
@@ -739,13 +739,13 @@
 }
 
 Sci::Position EditView::StartEndDisplayLine(Surface *surface, const EditModel &model, Sci::Position pos, bool start, const ViewStyle &vs) {
-	Sci::Line line = model.pdoc->LineFromPosition(pos);
+	const Sci::Line line = model.pdoc->LineFromPosition(pos);
 	AutoLineLayout ll(llc, RetrieveLineLayout(line, model));
 	Sci::Position posRet = INVALID_POSITION;
 	if (surface && ll) {
-		Sci::Position posLineStart = model.pdoc->LineStart(line);
+		const Sci::Position posLineStart = model.pdoc->LineStart(line);
 		LayoutLine(model, line, surface, vs, ll, model.wrapWidth);
-		Sci::Position posInLine = pos - posLineStart;
+		const Sci::Position posInLine = pos - posLineStart;
 		if (posInLine <= ll->maxLineLength) {
 			for (int subLine = 0; subLine < ll->lines; subLine++) {
 				if ((posInLine >= ll->LineStart(subLine)) &&
@@ -880,7 +880,7 @@
 		const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
 		virtualSpace = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line)) * spaceWidth;
 	}
-	XYPOSITION xEol = static_cast<XYPOSITION>(ll->positions[lineEnd] - subLineStart);
+	const XYPOSITION xEol = static_cast<XYPOSITION>(ll->positions[lineEnd] - subLineStart);
 
 	// Fill the virtual space and show selections within it
 	if (virtualSpace > 0.0f) {
@@ -890,9 +890,9 @@
 		if (!hideSelection && ((vsDraw.selAlpha == SC_ALPHA_NOALPHA) || (vsDraw.selAdditionalAlpha == SC_ALPHA_NOALPHA))) {
 			SelectionSegment virtualSpaceRange(SelectionPosition(model.pdoc->LineEnd(line)), SelectionPosition(model.pdoc->LineEnd(line), model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line))));
 			for (size_t r = 0; r<model.sel.Count(); r++) {
-				int alpha = (r == model.sel.Main()) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
+				const int alpha = (r == model.sel.Main()) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 				if (alpha == SC_ALPHA_NOALPHA) {
-					SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
+					const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
 					if (!portion.Empty()) {
 						const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
 						rcSegment.left = xStart + ll->positions[portion.start.Position() - posLineStart] -
@@ -925,7 +925,7 @@
 			blobsWidth += rcSegment.Width();
 			char hexits[4];
 			const char *ctrlChar;
-			unsigned char chEOL = ll->chars[eolPos];
+			const unsigned char chEOL = ll->chars[eolPos];
 			int styleMain = ll->styles[eolPos];
 			ColourDesired textBack = TextBackground(model, vsDraw, ll, background, eolInSelection, false, styleMain, eolPos);
 			if (UTF8IsAscii(chEOL)) {
@@ -986,7 +986,7 @@
 		rcSegment.left = rcLine.left;
 	rcSegment.right = rcLine.right;
 
-	bool fillRemainder = !lastSubLine || model.foldDisplayTextStyle == SC_FOLDDISPLAYTEXT_HIDDEN || !model.cs.GetFoldDisplayTextShown(line);
+	const bool fillRemainder = !lastSubLine || model.foldDisplayTextStyle == SC_FOLDDISPLAYTEXT_HIDDEN || !model.cs.GetFoldDisplayTextShown(line);
 	if (fillRemainder) {
 		// Fill the remainder of the line
 		FillLineRemainder(surface, model, vsDraw, ll, line, rcSegment, subLine);
@@ -1064,7 +1064,7 @@
 				const bool hover = vsDraw.indicators[deco->Indicator()].IsDynamic() &&
 					rangeRun.ContainsCharacter(hoverIndicatorPos);
 				const int value = deco->rs.ValueAt(startPos);
-				Indicator::DrawState drawState = hover ? Indicator::drawHover : Indicator::drawNormal;
+				const Indicator::DrawState drawState = hover ? Indicator::drawHover : Indicator::drawNormal;
 				const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
 				DrawIndicator(deco->Indicator(), startPos - posLineStart, endPos - posLineStart,
 					surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, drawState, value);
@@ -1079,7 +1079,7 @@
 	// Use indicators to highlight matching braces
 	if ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == STYLE_BRACELIGHT)) ||
 		(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == STYLE_BRACEBAD))) {
-		int braceIndicator = (model.bracesMatchStyle == STYLE_BRACELIGHT) ? vsDraw.braceHighlightIndicator : vsDraw.braceBadLightIndicator;
+		const int braceIndicator = (model.bracesMatchStyle == STYLE_BRACELIGHT) ? vsDraw.braceHighlightIndicator : vsDraw.braceBadLightIndicator;
 		if (under == vsDraw.indicators[braceIndicator].under) {
 			Range rangeLine(posLineStart + lineStart, posLineEnd);
 			if (rangeLine.ContainsCharacter(model.braces[0])) {
@@ -1128,13 +1128,13 @@
 	rcSegment.left = xStart + static_cast<XYPOSITION>(ll->positions[ll->numCharsInLine] - subLineStart) + virtualSpace + vsDraw.aveCharWidth;
 	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthFoldDisplayText);
 
-	ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
+	const ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
 	FontAlias textFont = vsDraw.styles[STYLE_FOLDDISPLAYTEXT].font;
 	ColourDesired textFore = vsDraw.styles[STYLE_FOLDDISPLAYTEXT].fore;
 	if (eolInSelection && (vsDraw.selColours.fore.isSet)) {
 		textFore = (eolInSelection == 1) ? vsDraw.selColours.fore : vsDraw.selAdditionalForeground;
 	}
-	ColourDesired textBack = TextBackground(model, vsDraw, ll, background, eolInSelection,
+	const ColourDesired textBack = TextBackground(model, vsDraw, ll, background, eolInSelection,
 											false, STYLE_FOLDDISPLAYTEXT, -1);
 
 	if (model.trackLineWidth) {
@@ -1198,9 +1198,9 @@
 
 void EditView::DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
 	Sci::Line line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
-	int indent = static_cast<int>(model.pdoc->GetLineIndentation(line) * vsDraw.spaceWidth);
+	const int indent = static_cast<int>(model.pdoc->GetLineIndentation(line) * vsDraw.spaceWidth);
 	PRectangle rcSegment = rcLine;
-	int annotationLine = subLine - ll->lines;
+	const int annotationLine = subLine - ll->lines;
 	const StyledText stAnnotation = model.pdoc->AnnotationStyledText(line);
 	if (stAnnotation.text && ValidStyledText(vsDraw, vsDraw.annotationStyleOffset, stAnnotation)) {
 		if (phase & drawBack) {
@@ -1322,7 +1322,7 @@
 void EditView::DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
 	Sci::Line lineDoc, int xStart, PRectangle rcLine, int subLine) const {
 	// When drag is active it is the only caret drawn
-	bool drawDrag = model.posDrag.IsValid();
+	const bool drawDrag = model.posDrag.IsValid();
 	if (hideSelection && !drawDrag)
 		return;
 	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
@@ -1342,12 +1342,12 @@
 		if (ll->InLine(offset, subLine) && offset <= ll->numCharsBeforeEOL) {
 			XYPOSITION xposCaret = ll->positions[offset] + virtualOffset - ll->positions[ll->LineStart(subLine)];
 			if (ll->wrapIndent != 0) {
-				Sci::Position lineStart = ll->LineStart(subLine);
+				const Sci::Position lineStart = ll->LineStart(subLine);
 				if (lineStart != 0)	// Wrapped
 					xposCaret += ll->wrapIndent;
 			}
-			bool caretBlinkState = (model.caret.active && model.caret.on) || (!additionalCaretsBlink && !mainCaret);
-			bool caretVisibleState = additionalCaretsVisible || mainCaret;
+			const bool caretBlinkState = (model.caret.active && model.caret.on) || (!additionalCaretsBlink && !mainCaret);
+			const bool caretVisibleState = additionalCaretsVisible || mainCaret;
 			if ((xposCaret >= 0) && (vsDraw.caretWidth > 0) && (vsDraw.caretStyle != CARETSTYLE_INVISIBLE) &&
 				((model.posDrag.IsValid()) || (caretBlinkState && caretVisibleState))) {
 				bool caretAtEOF = false;
@@ -1566,13 +1566,13 @@
 		if (subLine == (ll->lines - 1)) {
 			virtualSpaces = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line));
 		}
-		SelectionPosition posStart(posLineStart + lineRange.start);
-		SelectionPosition posEnd(posLineStart + lineRange.end, virtualSpaces);
-		SelectionSegment virtualSpaceRange(posStart, posEnd);
+		const SelectionPosition posStart(posLineStart + lineRange.start);
+		const SelectionPosition posEnd(posLineStart + lineRange.end, virtualSpaces);
+		const SelectionSegment virtualSpaceRange(posStart, posEnd);
 		for (size_t r = 0; r < model.sel.Count(); r++) {
-			int alpha = (r == model.sel.Main()) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
+			const int alpha = (r == model.sel.Main()) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 			if (alpha != SC_ALPHA_NOALPHA) {
-				SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
+				const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
 				if (!portion.Empty()) {
 					const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
 					PRectangle rcSegment = rcLine;
@@ -1838,7 +1838,7 @@
 			xStartText = 100000;	// Don't limit to visible indentation on empty line
 			// This line is empty, so use indentation of last line with text
 			int indentLastWithText = model.pdoc->GetLineIndentation(lineLastWithText);
-			int isFoldHeader = model.pdoc->GetLevel(lineLastWithText) & SC_FOLDLEVELHEADERFLAG;
+			const int isFoldHeader = model.pdoc->GetLevel(lineLastWithText) & SC_FOLDLEVELHEADERFLAG;
 			if (isFoldHeader) {
 				// Level is one more level than parent
 				indentLastWithText += model.pdoc->IndentSize();
@@ -1950,7 +1950,7 @@
 }
 
 static void DrawFoldLines(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, Sci::Line line, PRectangle rcLine) {
-	bool expanded = model.cs.GetExpanded(line);
+	const bool expanded = model.cs.GetExpanded(line);
 	const int level = model.pdoc->GetLevel(line);
 	const int levelNext = model.pdoc->GetLevel(line + 1);
 	if ((level & SC_FOLDLEVELHEADERFLAG) &&
@@ -2163,7 +2163,7 @@
 			alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 		}
 
-		ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
+		const ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
 
 		if (eolInSelection && vsDraw.selEOLFilled && vsDraw.selColours.back.isSet && (line < model.pdoc->LinesTotal() - 1) && (alpha == SC_ALPHA_NOALPHA)) {
 			surface->FillRectangle(rcArea, SelectionBackground(vsDraw, eolInSelection == 1, model.primarySelection));
@@ -2188,8 +2188,8 @@
 	unsigned int r = orig.GetRed();
 	unsigned int g = orig.GetGreen();
 	unsigned int b = orig.GetBlue();
-	unsigned int l = (r + g + b) / 3; 	// There is a better calculation for this that matches human eye
-	unsigned int il = 0xff - l;
+	const unsigned int l = (r + g + b) / 3; 	// There is a better calculation for this that matches human eye
+	const unsigned int il = 0xff - l;
 	if (l == 0)
 		return ColourDesired(0xff, 0xff, 0xff);
 	r = r * il / l;
@@ -2320,7 +2320,7 @@
 		// to start printing from to ensure a particular position is on the first
 		// line of the page.
 		if (visibleLine == 0) {
-			Sci::Position startWithinLine = nPrintPos - model.pdoc->LineStart(lineDoc);
+			const Sci::Position startWithinLine = nPrintPos - model.pdoc->LineStart(lineDoc);
 			for (int iwl = 0; iwl < ll.lines - 1; iwl++) {
 				if (ll.LineStart(iwl) <= startWithinLine && ll.LineStart(iwl + 1) >= startWithinLine) {
 					visibleLine = -iwl;
diff -r 797ed6c538fd -r d046ce80d590 src/Editor.cxx
--- a/src/Editor.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Editor.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -287,7 +287,7 @@
 PointDocument Editor::DocumentPointFromView(Point ptView) const {
 	PointDocument ptDocument(ptView);
 	if (wMargin.GetID()) {
-		Point ptOrigin = GetVisibleOriginInMain();
+		const Point ptOrigin = GetVisibleOriginInMain();
 		ptDocument.x += ptOrigin.x;
 		ptDocument.y += ptOrigin.y;
 	} else {
@@ -321,8 +321,8 @@
 }
 
 Sci::Line Editor::LinesOnScreen() const {
-	PRectangle rcClient = GetClientRectangle();
-	int htClient = static_cast<int>(rcClient.bottom - rcClient.top);
+	const PRectangle rcClient = GetClientRectangle();
+	const int htClient = static_cast<int>(rcClient.bottom - rcClient.top);
 	//Platform::DebugPrintf("lines on screen = %d\n", htClient / lineHeight + 1);
 	return htClient / vs.lineHeight;
 }
@@ -565,14 +565,14 @@
 
 void Editor::SetRectangularRange() {
 	if (sel.IsRectangular()) {
-		int xAnchor = XFromPosition(sel.Rectangular().anchor);
+		const int xAnchor = XFromPosition(sel.Rectangular().anchor);
 		int xCaret = XFromPosition(sel.Rectangular().caret);
 		if (sel.selType == Selection::selThin) {
 			xCaret = xAnchor;
 		}
-		Sci::Line lineAnchorRect = pdoc->LineFromPosition(sel.Rectangular().anchor.Position());
-		Sci::Line lineCaret = pdoc->LineFromPosition(sel.Rectangular().caret.Position());
-		int increment = (lineCaret > lineAnchorRect) ? 1 : -1;
+		const Sci::Line lineAnchorRect = pdoc->LineFromPosition(sel.Rectangular().anchor.Position());
+		const Sci::Line lineCaret = pdoc->LineFromPosition(sel.Rectangular().caret.Position());
+		const int increment = (lineCaret > lineAnchorRect) ? 1 : -1;
 		for (Sci::Line line=lineAnchorRect; line != lineCaret+increment; line += increment) {
 			SelectionRange range(SPositionFromLineX(line, xCaret), SPositionFromLineX(line, xAnchor));
 			if ((virtualSpaceOptions & SCVS_RECTANGULARSELECTION) == 0)
@@ -913,12 +913,12 @@
 }
 
 void Editor::ScrollTo(Sci::Line line, bool moveThumb) {
-	Sci::Line topLineNew = Platform::Clamp(line, 0, MaxScrollPos());
+	const Sci::Line topLineNew = Platform::Clamp(line, 0, MaxScrollPos());
 	if (topLineNew != topLine) {
 		// Try to optimise small scrolls
 #ifndef UNDER_CE
-		Sci::Line linesToMove = topLine - topLineNew;
-		bool performBlit = (abs(linesToMove) <= 10) && (paintState == notPainting);
+		const Sci::Line linesToMove = topLine - topLineNew;
+		const bool performBlit = (abs(linesToMove) <= 10) && (paintState == notPainting);
 		willRedrawAll = !performBlit;
 #endif
 		SetTopLine(topLineNew);
@@ -960,9 +960,9 @@
 }
 
 void Editor::VerticalCentreCaret() {
-	Sci::Line lineDoc = pdoc->LineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
-	Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
-	Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
+	const Sci::Line lineDoc = pdoc->LineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
+	const Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
+	const Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
 	if (topLine != newTop) {
 		SetTopLine(newTop > 0 ? newTop : 0);
 		RedrawRect(GetClientRectangle());
@@ -979,15 +979,15 @@
 
 	// if selection doesn't start at the beginning of the line, set the new start
 	Sci::Position selectionStart = SelectionStart().Position();
-	Sci::Line startLine = pdoc->LineFromPosition(selectionStart);
-	Sci::Position beginningOfStartLine = pdoc->LineStart(startLine);
+	const Sci::Line startLine = pdoc->LineFromPosition(selectionStart);
+	const Sci::Position beginningOfStartLine = pdoc->LineStart(startLine);
 	selectionStart = beginningOfStartLine;
 
 	// if selection doesn't end at the beginning of a line greater than that of the start,
 	// then set it at the beginning of the next one
 	Sci::Position selectionEnd = SelectionEnd().Position();
-	Sci::Line endLine = pdoc->LineFromPosition(selectionEnd);
-	Sci::Position beginningOfEndLine = pdoc->LineStart(endLine);
+	const Sci::Line endLine = pdoc->LineFromPosition(selectionEnd);
+	const Sci::Position beginningOfEndLine = pdoc->LineStart(endLine);
 	bool appendEol = false;
 	if (selectionEnd > beginningOfEndLine
 		|| selectionStart == selectionEnd) {
@@ -1114,7 +1114,7 @@
 */
 
 Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange &range, const XYScrollOptions options) {
-	PRectangle rcClient = GetTextRectangle();
+	const PRectangle rcClient = GetTextRectangle();
 	Point pt = LocationFromPosition(range.caret);
 	Point ptAnchor = LocationFromPosition(range.anchor);
 	const Point ptOrigin = GetVisibleOriginInMain();
@@ -1334,14 +1334,14 @@
 		if (!(range.caret == range.anchor)) {
 			if (ptAnchor.x < pt.x) {
 				// Shift to left to show anchor or as much of range as possible
-				int maxOffset = static_cast<int>(ptAnchor.x + xOffset - rcClient.left) - 1;
-				int minOffset = static_cast<int>(pt.x + xOffset - rcClient.right) + 1;
+				const int maxOffset = static_cast<int>(ptAnchor.x + xOffset - rcClient.left) - 1;
+				const int minOffset = static_cast<int>(pt.x + xOffset - rcClient.right) + 1;
 				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
 				newXY.xOffset = std::max(newXY.xOffset, minOffset);
 			} else {
 				// Shift to right to show anchor or as much of range as possible
-				int minOffset = static_cast<Sci::Position>(ptAnchor.x + xOffset - rcClient.right) + 1;
-				int maxOffset = static_cast<Sci::Position>(pt.x + xOffset - rcClient.left) - 1;
+				const int minOffset = static_cast<Sci::Position>(ptAnchor.x + xOffset - rcClient.right) + 1;
+				const int maxOffset = static_cast<Sci::Position>(pt.x + xOffset - rcClient.left) - 1;
 				newXY.xOffset = std::max(newXY.xOffset, minOffset);
 				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
 			}
@@ -1364,7 +1364,7 @@
 			xOffset = newXY.xOffset;
 			ContainerNeedsUpdate(SC_UPDATE_H_SCROLL);
 			if (newXY.xOffset > 0) {
-				PRectangle rcText = GetTextRectangle();
+				const PRectangle rcText = GetTextRectangle();
 				if (horizontalScrollBarVisible &&
 					rcText.Width() + xOffset > scrollWidth) {
 					scrollWidth = xOffset + static_cast<Sci::Position>(rcText.Width());
@@ -1599,7 +1599,7 @@
 void Editor::LinesSplit(int pixelWidth) {
 	if (!RangeContainsProtected(targetStart, targetEnd)) {
 		if (pixelWidth == 0) {
-			PRectangle rcText = GetTextRectangle();
+			const PRectangle rcText = GetTextRectangle();
 			pixelWidth = static_cast<int>(rcText.Width());
 		}
 		Sci::Line lineStart = pdoc->LineFromPosition(targetStart);
@@ -1675,7 +1675,7 @@
 	view.RefreshPixMaps(surfaceWindow, wMain.GetID(), vs);
 	marginView.RefreshPixMaps(surfaceWindow, wMain.GetID(), vs);
 	if (view.bufferedDraw) {
-		PRectangle rcClient = GetClientRectangle();
+		const PRectangle rcClient = GetClientRectangle();
 		if (!view.pixmapLine->Initialised()) {
 
 			view.pixmapLine->InitPixMap(static_cast<int>(rcClient.Width()), vs.lineHeight,
@@ -1804,9 +1804,9 @@
 void Editor::SetScrollBars() {
 	RefreshStyleData();
 
-	Sci::Line nMax = MaxScrollPos();
-	Sci::Line nPage = LinesOnScreen();
-	bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
+	const Sci::Line nMax = MaxScrollPos();
+	const Sci::Line nPage = LinesOnScreen();
+	const bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
 	if (modified) {
 		DwellEnd(true);
 	}
@@ -2251,8 +2251,8 @@
 						if (pdoc->GetColumn(sel.Range(r).caret.Position()) <= pdoc->GetLineIndentation(lineCurrentPos) &&
 								pdoc->GetColumn(sel.Range(r).caret.Position()) > 0 && pdoc->backspaceUnindents) {
 							UndoGroup ugInner(pdoc, !ug.Needed());
-							int indentation = pdoc->GetLineIndentation(lineCurrentPos);
-							int indentationStep = pdoc->IndentSize();
+							const int indentation = pdoc->GetLineIndentation(lineCurrentPos);
+							const int indentationStep = pdoc->IndentSize();
 							int indentationChange = indentation % indentationStep;
 							if (indentationChange == 0)
 								indentationChange = indentationStep;
@@ -2406,7 +2406,7 @@
 }
 
 void Editor::NotifyIndicatorClick(bool click, Sci::Position position, int modifiers) {
-	int mask = pdoc->decorations.AllOnFor(position);
+	const int mask = pdoc->decorations.AllOnFor(position);
 	if ((click && mask) || pdoc->decorations.ClickNotified()) {
 		SCNotification scn = {};
 		pdoc->decorations.SetClickNotified(click);
@@ -2539,7 +2539,7 @@
 // character is still present else after the previous surviving character.
 static inline Sci::Position MovePositionForDeletion(Sci::Position position, Sci::Position startDeletion, Sci::Position length) {
 	if (position > startDeletion) {
-		Sci::Position endDeletion = startDeletion + length;
+		const Sci::Position endDeletion = startDeletion + length;
 		if (position > endDeletion) {
 			return position - length;
 		} else {
@@ -2862,9 +2862,9 @@
 	Sci::Line topLineNew;
 	SelectionPosition newPos;
 
-	Sci::Line currentLine = pdoc->LineFromPosition(sel.MainCaret());
-	Sci::Line topStutterLine = topLine + caretYSlop;
-	Sci::Line bottomStutterLine =
+	const Sci::Line currentLine = pdoc->LineFromPosition(sel.MainCaret());
+	const Sci::Line topStutterLine = topLine + caretYSlop;
+	const Sci::Line bottomStutterLine =
 	    pdoc->LineFromPosition(PositionFromLocation(
 	                Point::FromInts(lastXChosen - xOffset, direction * vs.lineHeight * LinesToScroll())))
 	    - caretYSlop - 1;
@@ -3810,26 +3810,26 @@
 		return DelWordOrLine(iMessage);
 
 	case SCI_LINECOPY: {
-			Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
-			Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
+			const Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
+			const Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
 			CopyRangeToClipboard(pdoc->LineStart(lineStart),
 			        pdoc->LineStart(lineEnd + 1));
 		}
 		break;
 	case SCI_LINECUT: {
-			Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
-			Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
-			Sci::Position start = pdoc->LineStart(lineStart);
-			Sci::Position end = pdoc->LineStart(lineEnd + 1);
+			const Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
+			const Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
+			const Sci::Position start = pdoc->LineStart(lineStart);
+			const Sci::Position end = pdoc->LineStart(lineEnd + 1);
 			SetSelection(start, end);
 			Cut();
 			SetLastXChosen();
 		}
 		break;
 	case SCI_LINEDELETE: {
-			Sci::Line line = pdoc->LineFromPosition(sel.MainCaret());
-			Sci::Position start = pdoc->LineStart(line);
-			Sci::Position end = pdoc->LineStart(line + 1);
+			const Sci::Line line = pdoc->LineFromPosition(sel.MainCaret());
+			const Sci::Position start = pdoc->LineStart(line);
+			const Sci::Position end = pdoc->LineStart(line + 1);
 			pdoc->DeleteChars(start, end - start);
 		}
 		break;
@@ -3918,8 +3918,8 @@
 			} else {
 				if (pdoc->GetColumn(caretPosition) <= pdoc->GetLineIndentation(lineCurrentPos) &&
 						pdoc->tabIndents) {
-					int indentation = pdoc->GetLineIndentation(lineCurrentPos);
-					int indentationStep = pdoc->IndentSize();
+					const int indentation = pdoc->GetLineIndentation(lineCurrentPos);
+					const int indentationStep = pdoc->IndentSize();
 					const Sci::Position posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationStep);
 					sel.Range(r) = SelectionRange(posSelect);
 				} else {
@@ -3934,10 +3934,10 @@
 				}
 			}
 		} else {	// Multiline
-			Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() - pdoc->LineStart(lineOfAnchor);
-			Sci::Position currentPosPosOnLine = caretPosition - pdoc->LineStart(lineCurrentPos);
+			const Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() - pdoc->LineStart(lineOfAnchor);
+			const Sci::Position currentPosPosOnLine = caretPosition - pdoc->LineStart(lineCurrentPos);
 			// Multiple lines selected so indent / dedent
-			Sci::Line lineTopSel = std::min(lineOfAnchor, lineCurrentPos);
+			const Sci::Line lineTopSel = std::min(lineOfAnchor, lineCurrentPos);
 			Sci::Line lineBottomSel = std::max(lineOfAnchor, lineCurrentPos);
 			if (pdoc->LineStart(lineBottomSel) == sel.Range(r).anchor.Position() || pdoc->LineStart(lineBottomSel) == caretPosition)
 				lineBottomSel--;  	// If not selecting any characters on a line, do not indent
@@ -4148,7 +4148,7 @@
 		if (sel.selType == Selection::selRectangle)
 			std::sort(rangesInOrder.begin(), rangesInOrder.end());
 		for (size_t r=0; r<rangesInOrder.size(); r++) {
-			SelectionRange current = rangesInOrder[r];
+			const SelectionRange current = rangesInOrder[r];
 			text.append(RangeText(current.Start().Position(), current.End().Position()));
 			if (sel.selType == Selection::selRectangle) {
 				if (pdoc->eolMode != SC_EOL_LF)
@@ -4207,9 +4207,9 @@
 }
 
 bool Editor::DragThreshold(Point ptStart, Point ptNow) {
-	int xMove = static_cast<int>(ptStart.x - ptNow.x);
-	int yMove = static_cast<int>(ptStart.y - ptNow.y);
-	int distanceSquared = xMove * xMove + yMove * yMove;
+	const int xMove = static_cast<int>(ptStart.x - ptNow.x);
+	const int yMove = static_cast<int>(ptStart.y - ptNow.y);
+	const int distanceSquared = xMove * xMove + yMove * yMove;
 	return distanceSquared > 16;
 }
 
@@ -4224,9 +4224,9 @@
 	if (inDragDrop == ddDragging)
 		dropWentOutside = false;
 
-	bool positionWasInSelection = PositionInSelection(position.Position());
-
-	bool positionOnEdgeOfSelection =
+	const bool positionWasInSelection = PositionInSelection(position.Position());
+
+	const bool positionOnEdgeOfSelection =
 	    (position == SelectionStart()) || (position == SelectionEnd());
 
 	if ((inDragDrop != ddDragging) || !(positionWasInSelection) ||
@@ -4298,10 +4298,10 @@
 }
 
 bool Editor::PointInSelection(Point pt) {
-	SelectionPosition pos = SPositionFromLocation(pt, false, true);
-	Point ptPos = LocationFromPosition(pos);
+	const SelectionPosition pos = SPositionFromLocation(pt, false, true);
+	const Point ptPos = LocationFromPosition(pos);
 	for (size_t r=0; r<sel.Count(); r++) {
-		SelectionRange range = sel.Range(r);
+		const SelectionRange range = sel.Range(r);
 		if (range.Contains(pos)) {
 			bool hit = true;
 			if (pos == range.Start()) {
@@ -4456,7 +4456,7 @@
 
 	NotifyIndicatorClick(true, newPos.Position(), modifiers);
 
-	bool inSelMargin = PointInSelMargin(pt);
+	const bool inSelMargin = PointInSelMargin(pt);
 	// In margin ctrl+(double)click should always select everything
 	if (ctrl && inSelMargin) {
 		SelectAll();
@@ -4647,7 +4647,7 @@
 }
 
 void Editor::SetHoverIndicatorPosition(Sci::Position position) {
-	Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
+	const Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
 	hoverIndicatorPos = INVALID_POSITION;
 	if (vs.indicatorsDynamic == 0)
 		return;
@@ -5276,7 +5276,7 @@
 
 void Editor::SetAnnotationVisible(int visible) {
 	if (vs.annotationVisible != visible) {
-		bool changedFromOrToHidden = ((vs.annotationVisible != 0) != (visible != 0));
+		const bool changedFromOrToHidden = ((vs.annotationVisible != 0) != (visible != 0));
 		vs.annotationVisible = visible;
 		if (changedFromOrToHidden) {
 			int dir = vs.annotationVisible ? 1 : -1;
@@ -5299,7 +5299,7 @@
 	line++;
 	while (line <= lineMaxSubord) {
 		cs.SetVisible(line, line, true);
-		int level = pdoc->GetLevel(line);
+		const int level = pdoc->GetLevel(line);
 		if (level & SC_FOLDLEVELHEADERFLAG) {
 			if (cs.GetExpanded(line)) {
 				line = ExpandLine(line);
@@ -5330,12 +5330,12 @@
 		}
 
 		if (action == SC_FOLDACTION_CONTRACT) {
-			Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
+			const Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
 			if (lineMaxSubord > line) {
 				cs.SetExpanded(line, 0);
 				cs.SetVisible(line + 1, lineMaxSubord, false);
 
-				Sci::Line lineCurrent = pdoc->LineFromPosition(sel.MainCaret());
+				const Sci::Line lineCurrent = pdoc->LineFromPosition(sel.MainCaret());
 				if (lineCurrent > line && lineCurrent <= lineMaxSubord) {
 					// This does not re-expand the fold
 					EnsureCaretVisible();
@@ -5372,7 +5372,7 @@
 	line++;
 	cs.SetVisible(line, lineMaxSubord, expanding);
 	while (line <= lineMaxSubord) {
-		int levelLine = pdoc->GetLevel(line);
+		const int levelLine = pdoc->GetLevel(line);
 		if (levelLine & SC_FOLDLEVELHEADERFLAG) {
 			SetFoldExpanded(line, expanding);
 		}
@@ -5428,7 +5428,7 @@
 		Redraw();
 	}
 	if (enforcePolicy) {
-		Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
+		const Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
 		if (visiblePolicy & VISIBLE_SLOP) {
 			if ((topLine > lineDisplay) || ((visiblePolicy & VISIBLE_STRICT) && (topLine + visibleSlop > lineDisplay))) {
 				SetTopLine(Platform::Clamp(lineDisplay - visibleSlop, 0, MaxScrollPos()));
@@ -5466,14 +5466,14 @@
 	if (expanding) {
 		cs.SetVisible(0, maxLine-1, true);
 		for (int line = 0; line < maxLine; line++) {
-			int levelLine = pdoc->GetLevel(line);
+			const int levelLine = pdoc->GetLevel(line);
 			if (levelLine & SC_FOLDLEVELHEADERFLAG) {
 				SetFoldExpanded(line, true);
 			}
 		}
 	} else {
 		for (int line = 0; line < maxLine; line++) {
-			int level = pdoc->GetLevel(line);
+			const int level = pdoc->GetLevel(line);
 			if ((level & SC_FOLDLEVELHEADERFLAG) &&
 					(SC_FOLDLEVELBASE == LevelNumber(level))) {
 				SetFoldExpanded(line, false);
@@ -5540,8 +5540,8 @@
 
 void Editor::NeedShown(Sci::Position pos, Sci::Position len) {
 	if (foldAutomatic & SC_AUTOMATICFOLD_SHOW) {
-		Sci::Line lineStart = pdoc->LineFromPosition(pos);
-		Sci::Line lineEnd = pdoc->LineFromPosition(pos+len);
+		const Sci::Line lineStart = pdoc->LineFromPosition(pos);
+		const Sci::Line lineEnd = pdoc->LineFromPosition(pos+len);
 		for (Sci::Line line = lineStart; line <= lineEnd; line++) {
 			EnsureLineVisible(line, false);
 		}
@@ -7693,7 +7693,7 @@
 			SelectionSegment segmentLine(SelectionPosition(pdoc->LineStart(static_cast<int>(wParam))),
 				SelectionPosition(pdoc->LineEnd(static_cast<int>(wParam))));
 			for (size_t r=0; r<sel.Count(); r++) {
-				SelectionSegment portion = sel.Range(r).Intersect(segmentLine);
+				const SelectionSegment portion = sel.Range(r).Intersect(segmentLine);
 				if (portion.start.IsValid()) {
 					return (iMessage == SCI_GETLINESELSTARTPOSITION) ? portion.start.Position() : portion.end.Position();
 				}
diff -r 797ed6c538fd -r d046ce80d590 src/ExternalLexer.cxx
--- a/src/ExternalLexer.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/ExternalLexer.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -65,7 +65,7 @@
 			GetLexerNameFn GetLexerName = (GetLexerNameFn)(sptr_t)lib->FindFunction("GetLexerName");
 			GetLexerFactoryFunction fnFactory = (GetLexerFactoryFunction)(sptr_t)lib->FindFunction("GetLexerFactory");
 
-			int nl = GetLexerCount();
+			const int nl = GetLexerCount();
 
 			for (int i = 0; i < nl; i++) {
 				// Assign a buffer for the lexer name.
diff -r 797ed6c538fd -r d046ce80d590 src/Indicator.cxx
--- a/src/Indicator.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Indicator.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -36,7 +36,7 @@
 	int ymid = static_cast<int>(rc.bottom + rc.top) / 2;
 	if (sacDraw.style == INDIC_SQUIGGLE) {
 		int x = int(rc.left+0.5);
-		int xLast = int(rc.right+0.5);
+		const int xLast = int(rc.right+0.5);
 		int y = 0;
 		surface->MoveTo(x, static_cast<int>(rc.top) + y);
 		while (x < xLast) {
diff -r 797ed6c538fd -r d046ce80d590 src/LineMarker.cxx
--- a/src/LineMarker.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/LineMarker.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -122,11 +122,11 @@
 	int minDim = Platform::Minimum(static_cast<int>(rc.Width()), static_cast<int>(rc.Height()));
 	minDim--;	// Ensure does not go beyond edge
 	int centreX = static_cast<int>(floor((rc.right + rc.left) / 2.0));
-	int centreY = static_cast<int>(floor((rc.bottom + rc.top) / 2.0));
-	int dimOn2 = minDim / 2;
-	int dimOn4 = minDim / 4;
+	const int centreY = static_cast<int>(floor((rc.bottom + rc.top) / 2.0));
+	const int dimOn2 = minDim / 2;
+	const int dimOn4 = minDim / 4;
 	int blobSize = dimOn2-1;
-	int armSize = dimOn2-2;
+	const int armSize = dimOn2-2;
 	if (marginStyle == SC_MARGIN_NUMBER || marginStyle == SC_MARGIN_TEXT || marginStyle == SC_MARGIN_RTEXT) {
 		// On textual margins move marker to the left to try to avoid overlapping the text
 		centreX = static_cast<int>(rc.left) + dimOn2 + 1;
@@ -384,7 +384,7 @@
 		rcLeft.right = rcLeft.left + 4;
 		surface->FillRectangle(rcLeft, back);
 	} else if (markType == SC_MARK_BOOKMARK) {
-		int halfHeight = minDim / 3;
+		const int halfHeight = minDim / 3;
 		Point pts[] = {
 			Point::FromInts(static_cast<int>(rc.left), centreY-halfHeight),
 			Point::FromInts(static_cast<int>(rc.right) - 3, centreY - halfHeight),
diff -r 797ed6c538fd -r d046ce80d590 src/MarginView.cxx
--- a/src/MarginView.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/MarginView.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -64,10 +64,10 @@
 	enum { xa = 1 }; // gap before start
 	int w = static_cast<int>(rcPlace.right - rcPlace.left) - xa - 1;
 
-	bool xStraight = isEndMarker;  // x-mirrored symbol for start marker
+	const bool xStraight = isEndMarker;  // x-mirrored symbol for start marker
 
-	int x0 = static_cast<int>(xStraight ? rcPlace.left : rcPlace.right - 1);
-	int y0 = static_cast<int>(rcPlace.top);
+	const int x0 = static_cast<int>(xStraight ? rcPlace.left : rcPlace.right - 1);
+	const int y0 = static_cast<int>(rcPlace.top);
 
 	int dy = static_cast<int>(rcPlace.bottom - rcPlace.top) / 5;
 	int y = static_cast<int>(rcPlace.bottom - rcPlace.top) / 2 + dy;
@@ -205,7 +205,7 @@
 					// Required because of special way brush is created for selection margin
 					// Ensure patterns line up when scrolling with separate margin view
 					// by choosing correctly aligned variant.
-					bool invertPhase = static_cast<int>(ptOrigin.y) & 1;
+					const bool invertPhase = static_cast<int>(ptOrigin.y) & 1;
 					surface->FillRectangle(rcSelMargin,
 						invertPhase ? *pixmapSelPattern : *pixmapSelPatternOffset1);
 				} else {
@@ -238,7 +238,7 @@
 			// be displayed until the last of a sequence of whitespace.
 			bool needWhiteClosure = false;
 			if (vs.ms[margin].mask & SC_MASK_FOLDERS) {
-				int level = model.pdoc->GetLevel(model.cs.DocFromDisplay(visibleLine));
+				const int level = model.pdoc->GetLevel(model.cs.DocFromDisplay(visibleLine));
 				if (level & SC_FOLDLEVELWHITEFLAG) {
 					Sci::Line lineBack = model.cs.DocFromDisplay(visibleLine);
 					int levelPrev = level;
@@ -380,7 +380,7 @@
 							sprintf(number, "%d", lineDoc + 1);
 						if (model.foldFlags & (SC_FOLDFLAG_LEVELNUMBERS | SC_FOLDFLAG_LINESTATE)) {
 							if (model.foldFlags & SC_FOLDFLAG_LEVELNUMBERS) {
-								int lev = model.pdoc->GetLevel(lineDoc);
+								const int lev = model.pdoc->GetLevel(lineDoc);
 								sprintf(number, "%c%c %03X %03X",
 									(lev & SC_FOLDLEVELHEADERFLAG) ? 'H' : '_',
 									(lev & SC_FOLDLEVELWHITEFLAG) ? 'W' : '_',
@@ -388,7 +388,7 @@
 									lev >> 16
 									);
 							} else {
-								int state = model.pdoc->GetLineState(lineDoc);
+								const int state = model.pdoc->GetLineState(lineDoc);
 								sprintf(number, "%0X", state);
 							}
 						}
diff -r 797ed6c538fd -r d046ce80d590 src/Partitioning.h
--- a/src/Partitioning.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Partitioning.h	Thu Apr 06 21:04:37 2017 +1000
@@ -27,9 +27,9 @@
 	void RangeAddDelta(int start, int end, int delta) {
 		// end is 1 past end, so end-start is number of elements to change
 		int i = 0;
-		int rangeLength = end - start;
+		const int rangeLength = end - start;
 		int range1Length = rangeLength;
-		int part1Left = part1Length - start;
+		const int part1Left = part1Length - start;
 		if (range1Length > part1Left)
 			range1Length = part1Left;
 		while (i < range1Length) {
@@ -170,7 +170,7 @@
 		int lower = 0;
 		int upper = body->Length()-1;
 		do {
-			int middle = (upper + lower + 1) / 2; 	// Round high
+			const int middle = (upper + lower + 1) / 2; 	// Round high
 			int posMiddle = body->ValueAt(middle);
 			if (middle > stepPartition)
 				posMiddle += stepLength;
diff -r 797ed6c538fd -r d046ce80d590 src/PerLine.cxx
--- a/src/PerLine.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/PerLine.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -181,9 +181,9 @@
 Sci::Line LineMarkers::MarkerNext(Sci::Line lineStart, int mask) const {
 	if (lineStart < 0)
 		lineStart = 0;
-	Sci::Line length = markers.Length();
+	const Sci::Line length = markers.Length();
 	for (Sci::Line iLine = lineStart; iLine < length; iLine++) {
-		MarkerHandleSet *onLine = markers[iLine];
+		const MarkerHandleSet *onLine = markers[iLine];
 		if (onLine && ((onLine->MarkValue() & mask) != 0))
 		//if ((pdoc->GetMark(iLine) & lParam) != 0)
 			return iLine;
@@ -318,7 +318,7 @@
 
 int LineState::SetLineState(Sci::Line line, int state) {
 	lineStates.EnsureLength(line + 1);
-	int stateOld = lineStates[line];
+	const int stateOld = lineStates[line];
 	lineStates[line] = state;
 	return stateOld;
 }
@@ -410,7 +410,7 @@
 }
 
 static char *AllocateAnnotation(int length, int style) {
-	size_t len = sizeof(AnnotationHeader) + length + ((style == IndividualStyles) ? length : 0);
+	const size_t len = sizeof(AnnotationHeader) + length + ((style == IndividualStyles) ? length : 0);
 	char *ret = new char[len]();
 	return ret;
 }
@@ -418,7 +418,7 @@
 void LineAnnotation::SetText(Sci::Line line, const char *text) {
 	if (text && (line >= 0)) {
 		annotations.EnsureLength(line+1);
-		int style = Style(line);
+		const int style = Style(line);
 		if (annotations[line]) {
 			delete []annotations[line];
 		}
diff -r 797ed6c538fd -r d046ce80d590 src/PositionCache.cxx
--- a/src/PositionCache.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/PositionCache.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -189,7 +189,7 @@
 int LineLayout::FindBefore(XYPOSITION x, int lower, int upper) const {
 	do {
 		int middle = (upper + lower + 1) / 2; 	// Round high
-		XYPOSITION posMiddle = positions[middle];
+		const XYPOSITION posMiddle = positions[middle];
 		if (x < posMiddle) {
 			upper = middle - 1;
 		} else {
@@ -469,11 +469,11 @@
 	}
 
 	if (breakForSelection) {
-		SelectionPosition posStart(posLineStart);
-		SelectionPosition posEnd(posLineStart + lineRange.end);
-		SelectionSegment segmentLine(posStart, posEnd);
+		const SelectionPosition posStart(posLineStart);
+		const SelectionPosition posEnd(posLineStart + lineRange.end);
+		const SelectionSegment segmentLine(posStart, posEnd);
 		for (size_t r=0; r<psel->Count(); r++) {
-			SelectionSegment portion = psel->Range(r).Intersect(segmentLine);
+			const SelectionSegment portion = psel->Range(r).Intersect(segmentLine);
 			if (!(portion.start == portion.end)) {
 				if (portion.start.IsValid())
 					Insert(portion.start.Position() - posLineStart);
@@ -653,7 +653,7 @@
 }
 
 void PositionCache::MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
-	const char *s, unsigned int len, XYPOSITION *positions, Document *pdoc) {
+	const char *s, unsigned int len, XYPOSITION *positions, const Document *pdoc) {
 
 	allClear = false;
 	size_t probe = pces.size();	// Out of bounds
diff -r 797ed6c538fd -r d046ce80d590 src/PositionCache.h
--- a/src/PositionCache.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/PositionCache.h	Thu Apr 06 21:04:37 2017 +1000
@@ -214,7 +214,7 @@
 	void SetSize(size_t size_);
 	size_t GetSize() const { return pces.size(); }
 	void MeasureWidths(Surface *surface, const ViewStyle &vstyle, unsigned int styleNumber,
-		const char *s, unsigned int len, XYPOSITION *positions, Document *pdoc);
+		const char *s, unsigned int len, XYPOSITION *positions, const Document *pdoc);
 };
 
 inline bool IsSpaceOrTab(int ch) {
diff -r 797ed6c538fd -r d046ce80d590 src/RESearch.cxx
--- a/src/RESearch.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/RESearch.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -358,7 +358,7 @@
 	incr = 0;	// Most of the time, will skip the char "naturally".
 	int c;
 	int result = -1;
-	unsigned char bsc = *pattern;
+	const unsigned char bsc = *pattern;
 	if (!bsc) {
 		// Avoid overrun
 		result = '\\';	// \ at end of pattern, take it literally
@@ -376,9 +376,9 @@
 		result = escapeValue(bsc);
 		break;
 	case 'x': {
-			unsigned char hd1 = *(pattern + 1);
-			unsigned char hd2 = *(pattern + 2);
-			int hexValue = GetHexaChar(hd1, hd2);
+			const unsigned char hd1 = *(pattern + 1);
+			const unsigned char hd2 = *(pattern + 2);
+			const int hexValue = GetHexaChar(hd1, hd2);
 			if (hexValue >= 0) {
 				result = hexValue;
 				incr = 2;	// Must skip the digits
diff -r 797ed6c538fd -r d046ce80d590 src/RunStyles.cxx
--- a/src/RunStyles.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/RunStyles.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -38,7 +38,7 @@
 // If there is no run boundary at position, insert one continuing style.
 int RunStyles::SplitRun(int position) {
 	int run = RunFromPosition(position);
-	int posRun = starts->PositionFromPartition(run);
+	const int posRun = starts->PositionFromPartition(run);
 	if (posRun < position) {
 		int runStyle = ValueAt(position);
 		run++;
@@ -91,12 +91,12 @@
 }
 
 int RunStyles::FindNextChange(int position, int end) const {
-	int run = starts->PartitionFromPosition(position);
+	const int run = starts->PartitionFromPosition(position);
 	if (run < starts->Partitions()) {
-		int runChange = starts->PositionFromPartition(run);
+		const int runChange = starts->PositionFromPartition(run);
 		if (runChange > position)
 			return runChange;
-		int nextChange = starts->PositionFromPartition(run + 1);
+		const int nextChange = starts->PositionFromPartition(run + 1);
 		if (nextChange > position) {
 			return nextChange;
 		} else if (position < end) {
@@ -273,7 +273,7 @@
 	}
 	int start=0;
 	while (start < Length()) {
-		int end = EndRun(start);
+		const int end = EndRun(start);
 		if (start >= end) {
 			throw std::runtime_error("RunStyles: Partition is 0 length.");
 		}
diff -r 797ed6c538fd -r d046ce80d590 src/ScintillaBase.cxx
--- a/src/ScintillaBase.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/ScintillaBase.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -79,7 +79,7 @@
 }
 
 void ScintillaBase::AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS) {
-	bool isFillUp = ac.Active() && ac.IsFillUpChar(*s);
+	const bool isFillUp = ac.Active() && ac.IsFillUpChar(*s);
 	if (!isFillUp) {
 		Editor::AddCharUTF(s, len, treatAsDBCS);
 	}
@@ -365,7 +365,7 @@
 }
 
 void ScintillaBase::AutoCompleteCompleted(char ch, unsigned int completionMethod) {
-	int item = ac.GetSelection();
+	const int item = ac.GetSelection();
 	if (item == -1) {
 		AutoCompleteCancel();
 		return;
@@ -415,7 +415,7 @@
 
 int ScintillaBase::AutoCompleteGetCurrentText(char *buffer) const {
 	if (ac.Active()) {
-		int item = ac.GetSelection();
+		const int item = ac.GetSelection();
 		if (item != -1) {
 			const std::string selected = ac.GetValue(item);
 			if (buffer != NULL)
@@ -453,7 +453,7 @@
 		wMain);
 	// If the call-tip window would be out of the client
 	// space
-	PRectangle rcClient = GetClientRectangle();
+	const PRectangle rcClient = GetClientRectangle();
 	int offset = vs.lineHeight + static_cast<int>(rc.Height());
 	// adjust so it displays above the text.
 	if (rc.bottom > rcClient.bottom && rc.Height() < rcClient.Height()) {
@@ -485,7 +485,7 @@
 
 void ScintillaBase::ContextMenu(Point pt) {
 	if (displayPopupMenu) {
-		bool writable = !WndProc(SCI_GETREADONLY, 0, 0);
+		const bool writable = !WndProc(SCI_GETREADONLY, 0, 0);
 		popup.CreatePopUp();
 		AddToPopUp("Undo", idcmdUndo, writable && pdoc->CanUndo());
 		AddToPopUp("Redo", idcmdRedo, writable && pdoc->CanRedo());
diff -r 797ed6c538fd -r d046ce80d590 src/Selection.cxx
--- a/src/Selection.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/Selection.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -36,7 +36,7 @@
 			virtualSpace = 0;
 		}
 		if (position > startChange) {
-			Sci::Position endDeletion = startChange + length;
+			const Sci::Position endDeletion = startChange + length;
 			if (position > endDeletion) {
 				position -= length;
 			} else {
@@ -131,8 +131,8 @@
 }
 
 bool SelectionRange::Trim(SelectionRange range) {
-	SelectionPosition startRange = range.Start();
-	SelectionPosition endRange = range.End();
+	const SelectionPosition startRange = range.Start();
+	const SelectionPosition endRange = range.End();
 	SelectionPosition start = Start();
 	SelectionPosition end = End();
 	PLATFORM_ASSERT(start <= end);
diff -r 797ed6c538fd -r d046ce80d590 src/SplitVector.h
--- a/src/SplitVector.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/SplitVector.h	Thu Apr 06 21:04:37 2017 +1000
@@ -251,7 +251,7 @@
 		// Split into up to 2 ranges, before and after the split then use memcpy on each.
 		int range1Length = 0;
 		if (position < part1Length) {
-			int part1AfterPosition = part1Length - position;
+			const int part1AfterPosition = part1Length - position;
 			range1Length = retrieveLength;
 			if (range1Length > part1AfterPosition)
 				range1Length = part1AfterPosition;
diff -r 797ed6c538fd -r d046ce80d590 src/UniConversion.cxx
--- a/src/UniConversion.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/UniConversion.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -23,7 +23,7 @@
 unsigned int UTF8Length(const wchar_t *uptr, unsigned int tlen) {
 	unsigned int len = 0;
 	for (unsigned int i = 0; i < tlen && uptr[i];) {
-		unsigned int uch = uptr[i];
+		const unsigned int uch = uptr[i];
 		if (uch < 0x80) {
 			len++;
 		} else if (uch < 0x800) {
@@ -43,7 +43,7 @@
 void UTF8FromUTF16(const wchar_t *uptr, unsigned int tlen, char *putf, unsigned int len) {
 	unsigned int k = 0;
 	for (unsigned int i = 0; i < tlen && uptr[i];) {
-		unsigned int uch = uptr[i];
+		const unsigned int uch = uptr[i];
 		if (uch < 0x80) {
 			putf[k++] = static_cast<char>(uch);
 		} else if (uch < 0x800) {
@@ -53,7 +53,7 @@
 			(uch <= SURROGATE_TRAIL_LAST)) {
 			// Half a surrogate pair
 			i++;
-			unsigned int xch = 0x10000 + ((uch & 0x3ff) << 10) + (uptr[i] & 0x3ff);
+			const unsigned int xch = 0x10000 + ((uch & 0x3ff) << 10) + (uptr[i] & 0x3ff);
 			putf[k++] = static_cast<char>(0xF0 | (xch >> 18));
 			putf[k++] = static_cast<char>(0x80 | ((xch >> 12) & 0x3f));
 			putf[k++] = static_cast<char>(0x80 | ((xch >> 6) & 0x3f));
@@ -85,7 +85,7 @@
 	size_t ulen = 0;
 	size_t charLen;
 	for (size_t i = 0; i<len;) {
-		unsigned char ch = static_cast<unsigned char>(s[i]);
+		const unsigned char ch = static_cast<unsigned char>(s[i]);
 		if (ch < 0x80) {
 			charLen = 1;
 		} else if (ch < 0x80 + 0x40 + 0x20) {
@@ -301,7 +301,7 @@
 }
 
 int UTF8DrawBytes(const unsigned char *us, int len) {
-	int utf8StatusNext = UTF8Classify(us, len);
+	const int utf8StatusNext = UTF8Classify(us, len);
 	return (utf8StatusNext & UTF8MaskInvalid) ? 1 : (utf8StatusNext & UTF8MaskWidth);
 }
 
diff -r 797ed6c538fd -r d046ce80d590 src/ViewStyle.cxx
--- a/src/ViewStyle.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/ViewStyle.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -565,31 +565,31 @@
 		wrapStateWanted = eWrapNone;
 		break;
 	}
-	bool changed = wrapState != wrapStateWanted;
+	const bool changed = wrapState != wrapStateWanted;
 	wrapState = wrapStateWanted;
 	return changed;
 }
 
 bool ViewStyle::SetWrapVisualFlags(int wrapVisualFlags_) {
-	bool changed = wrapVisualFlags != wrapVisualFlags_;
+	const bool changed = wrapVisualFlags != wrapVisualFlags_;
 	wrapVisualFlags = wrapVisualFlags_;
 	return changed;
 }
 
 bool ViewStyle::SetWrapVisualFlagsLocation(int wrapVisualFlagsLocation_) {
-	bool changed = wrapVisualFlagsLocation != wrapVisualFlagsLocation_;
+	const bool changed = wrapVisualFlagsLocation != wrapVisualFlagsLocation_;
 	wrapVisualFlagsLocation = wrapVisualFlagsLocation_;
 	return changed;
 }
 
 bool ViewStyle::SetWrapVisualStartIndent(int wrapVisualStartIndent_) {
-	bool changed = wrapVisualStartIndent != wrapVisualStartIndent_;
+	const bool changed = wrapVisualStartIndent != wrapVisualStartIndent_;
 	wrapVisualStartIndent = wrapVisualStartIndent_;
 	return changed;
 }
 
 bool ViewStyle::SetWrapIndentMode(int wrapIndentMode_) {
-	bool changed = wrapIndentMode != wrapIndentMode_;
+	const bool changed = wrapIndentMode != wrapIndentMode_;
 	wrapIndentMode = wrapIndentMode_;
 	return changed;
 }
diff -r 797ed6c538fd -r d046ce80d590 src/XPM.cxx
--- a/src/XPM.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/XPM.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -117,24 +117,24 @@
 
 	for (int y=0; y<height; y++) {
 		const char *lform = linesForm[y+nColours+1];
-		size_t len = MeasureLength(lform);
+		const size_t len = MeasureLength(lform);
 		for (size_t x = 0; x<len; x++)
 			pixels[y * width + x] = static_cast<unsigned char>(lform[x]);
 	}
 }
 
-void XPM::Draw(Surface *surface, PRectangle &rc) {
+void XPM::Draw(Surface *surface, const PRectangle &rc) {
 	if (pixels.empty()) {
 		return;
 	}
 	// Centre the pixmap
-	int startY = static_cast<int>(rc.top + (rc.Height() - height) / 2);
-	int startX = static_cast<int>(rc.left + (rc.Width() - width) / 2);
+	const int startY = static_cast<int>(rc.top + (rc.Height() - height) / 2);
+	const int startX = static_cast<int>(rc.left + (rc.Width() - width) / 2);
 	for (int y=0; y<height; y++) {
 		int prevCode = 0;
 		int xStartRun = 0;
 		for (int x=0; x<width; x++) {
-			int code = pixels[y * width + x];
+			const int code = pixels[y * width + x];
 			if (code != prevCode) {
 				FillRun(surface, prevCode, startX + xStartRun, startY + y, startX + x);
 				xStartRun = x;
diff -r 797ed6c538fd -r d046ce80d590 src/XPM.h
--- a/src/XPM.h	Thu Apr 06 20:19:23 2017 +1000
+++ b/src/XPM.h	Thu Apr 06 21:04:37 2017 +1000
@@ -31,7 +31,7 @@
 	void Init(const char *textForm);
 	void Init(const char *const *linesForm);
 	/// Decompose image into runs and use FillRectangle for each run
-	void Draw(Surface *surface, PRectangle &rc);
+	void Draw(Surface *surface, const PRectangle &rc);
 	int GetHeight() const { return height; }
 	int GetWidth() const { return width; }
 	void PixelAt(int x, int y, ColourDesired &colour, bool &transparent) const;
diff -r 797ed6c538fd -r d046ce80d590 win32/HanjaDic.cxx
--- a/win32/HanjaDic.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/win32/HanjaDic.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -112,7 +112,7 @@
 			if (dict.IsHanja(static_cast<int>(inout[i]))) { // Pass hanja only!
 				conv[0] = inout[i];
 				BSTR bstrHanja = SysAllocString(conv);
-				HRESULT hr = dict.HJinterface->HanjaToHangul(bstrHanja, &bstrHangul);
+				const HRESULT hr = dict.HJinterface->HanjaToHangul(bstrHanja, &bstrHangul);
 				if (SUCCEEDED(hr)) {
 					inout[i] = static_cast<wchar_t>(bstrHangul[0]);
 					changed += 1;
diff -r 797ed6c538fd -r d046ce80d590 win32/PlatWin.cxx
--- a/win32/PlatWin.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/win32/PlatWin.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -129,7 +129,7 @@
 		}
 
 		if (pIDWriteFactory) {
-			HRESULT hr = pIDWriteFactory->CreateRenderingParams(&defaultRenderingParams);
+			const HRESULT hr = pIDWriteFactory->CreateRenderingParams(&defaultRenderingParams);
 			if (SUCCEEDED(hr)) {
 				unsigned int clearTypeContrast;
 				if (::SystemParametersInfo(SPI_GETFONTSMOOTHINGCONTRAST, 0, &clearTypeContrast, 0)) {
@@ -212,7 +212,7 @@
 			return 0;
 		}
 	} else {
-		HRESULT hr = pTextFormat->GetFontFamilyName(lf.lfFaceName, LF_FACESIZE);
+		const HRESULT hr = pTextFormat->GetFontFamilyName(lf.lfFaceName, LF_FACESIZE);
 		if (!SUCCEEDED(hr)) {
 			return 0;
 		}
@@ -393,7 +393,7 @@
 FontID FontCached::FindOrCreate(const FontParameters &fp) {
 	FontID ret = 0;
 	::EnterCriticalSection(&crPlatformLock);
-	int hashFind = HashFont(fp);
+	const int hashFind = HashFont(fp);
 	for (FontCached *cur=first; cur; cur=cur->next) {
 		if ((cur->hash == hashFind) &&
 			cur->SameAs(fp)) {
@@ -843,7 +843,7 @@
 			for (int y=height-1; y>=0; y--) {
 				for (int x=0; x<width; x++) {
 					unsigned char *pixel = image + (y*width+x) * 4;
-					unsigned char alpha = pixelsImage[3];
+					const unsigned char alpha = pixelsImage[3];
 					// Input is RGBA, output is BGRA with premultiplied alpha
 					pixel[2] = static_cast<unsigned char>((*pixelsImage++) * alpha / 255);
 					pixel[1] = static_cast<unsigned char>((*pixelsImage++) * alpha / 255);
@@ -952,7 +952,7 @@
 		}
 		// Map the widths given for UTF-16 characters back onto the UTF-8 input string
 		for (int ui = 0; ui < fit; ui++) {
-			unsigned int lenChar = UTF8BytesOfLead[static_cast<unsigned char>(s[i])];
+			const unsigned int lenChar = UTF8BytesOfLead[static_cast<unsigned char>(s[i])];
 			if (lenChar == 4) {	// Non-BMP
 				ui++;
 			}
@@ -1211,7 +1211,7 @@
 	desiredFormat = psurfOther->pRenderTarget->GetPixelFormat();
 #endif
 	desiredFormat.alphaMode = D2D1_ALPHA_MODE_IGNORE;
-	HRESULT hr = psurfOther->pRenderTarget->CreateCompatibleRenderTarget(
+	const HRESULT hr = psurfOther->pRenderTarget->CreateCompatibleRenderTarget(
 		&desiredSize, NULL, &desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE, &pCompatibleRenderTarget);
 	if (SUCCEEDED(hr)) {
 		pRenderTarget = pCompatibleRenderTarget;
@@ -1236,7 +1236,7 @@
 		if (pBrush) {
 			pBrush->SetColor(col);
 		} else {
-			HRESULT hr = pRenderTarget->CreateSolidColorBrush(col, &pBrush);
+			const HRESULT hr = pRenderTarget->CreateSolidColorBrush(col, &pBrush);
 			if (!SUCCEEDED(hr) && pBrush) {
 				pBrush->Release();
 				pBrush = 0;
@@ -1297,18 +1297,18 @@
 
 void SurfaceD2D::LineTo(int x_, int y_) {
 	if (pRenderTarget) {
-		int xDiff = x_ - x;
-		int xDelta = Delta(xDiff);
-		int yDiff = y_ - y;
-		int yDelta = Delta(yDiff);
+		const int xDiff = x_ - x;
+		const int xDelta = Delta(xDiff);
+		const int yDiff = y_ - y;
+		const int yDelta = Delta(yDiff);
 		if ((xDiff == 0) || (yDiff == 0)) {
 			// Horizontal or vertical lines can be more precisely drawn as a filled rectangle
-			int xEnd = x_ - xDelta;
-			int left = Platform::Minimum(x, xEnd);
-			int width = abs(x - xEnd) + 1;
-			int yEnd = y_ - yDelta;
-			int top = Platform::Minimum(y, yEnd);
-			int height = abs(y - yEnd) + 1;
+			const int xEnd = x_ - xDelta;
+			const int left = Platform::Minimum(x, xEnd);
+			const int width = abs(x - xEnd) + 1;
+			const int yEnd = y_ - yDelta;
+			const int top = Platform::Minimum(y, yEnd);
+			const int height = abs(y - yEnd) + 1;
 			D2D1_RECT_F rectangle1 = D2D1::RectF(static_cast<float>(left), static_cast<float>(top),
 				static_cast<float>(left+width), static_cast<float>(top+height));
 			pRenderTarget->FillRectangle(&rectangle1, pBrush);
@@ -1455,7 +1455,7 @@
 		for (int yPixel=0; yPixel<height; yPixel++) {
 			for (int xPixel = 0; xPixel<width; xPixel++) {
 				unsigned char *pixel = &image[0] + (yPixel*width + xPixel) * 4;
-				unsigned char alpha = pixelsImage[3];
+				const unsigned char alpha = pixelsImage[3];
 				// Input is RGBA, output is BGRA with premultiplied alpha
 				pixel[2] = (*pixelsImage++) * alpha / 255;
 				pixel[1] = (*pixelsImage++) * alpha / 255;
@@ -1468,7 +1468,7 @@
 		D2D1_SIZE_U size = D2D1::SizeU(width, height);
 		D2D1_BITMAP_PROPERTIES props = {{DXGI_FORMAT_B8G8R8A8_UNORM,
 		    D2D1_ALPHA_MODE_PREMULTIPLIED}, 72.0, 72.0};
-		HRESULT hr = pRenderTarget->CreateBitmap(size, &image[0],
+		const HRESULT hr = pRenderTarget->CreateBitmap(size, &image[0],
                   width * 4, &props, &bitmap);
 		if (SUCCEEDED(hr)) {
 			D2D1_RECT_F rcDestination = {rc.left, rc.top, rc.right, rc.bottom};
@@ -1525,7 +1525,7 @@
 
 		// Explicitly creating a text layout appears a little faster
 		IDWriteTextLayout *pTextLayout;
-		HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat,
+		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat,
 				rc.Width(), rc.Height(), &pTextLayout);
 		if (SUCCEEDED(hr)) {
 			D2D1_POINT_2F origin = {rc.left, ybase-yAscent};
@@ -1578,7 +1578,7 @@
 	if (pIDWriteFactory && pTextFormat) {
 		// Create a layout
 		IDWriteTextLayout *pTextLayout = 0;
-		HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 1000.0, 1000.0, &pTextLayout);
+		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 1000.0, 1000.0, &pTextLayout);
 		if (SUCCEEDED(hr)) {
 			DWRITE_TEXT_METRICS textMetrics;
 			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
@@ -1602,7 +1602,7 @@
 		SetFont(font_);
 		// Create a layout
 		IDWriteTextLayout *pTextLayout = 0;
-		HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 10000.0, 1000.0, &pTextLayout);
+		const HRESULT hr = pIDWriteFactory->CreateTextLayout(tbuf.buffer, tbuf.tlen, pTextFormat, 10000.0, 1000.0, &pTextLayout);
 		if (!SUCCEEDED(hr))
 			return;
 		if (!SUCCEEDED(pTextLayout->GetClusterMetrics(clusterMetrics, clusters, &count)))
@@ -1625,7 +1625,7 @@
 		const unsigned char *us = reinterpret_cast<const unsigned char *>(s);
 		int i=0;
 		while (ui<fit) {
-			unsigned char uch = us[i];
+			const unsigned char uch = us[i];
 			unsigned int lenChar = 1;
 			if (uch >= (0x80 + 0x40 + 0x20 + 0x10)) {
 				lenChar = 4;
@@ -1683,7 +1683,7 @@
 		// Create a layout
 		IDWriteTextLayout *pTextLayout = 0;
 		const WCHAR wch = ch;
-		HRESULT hr = pIDWriteFactory->CreateTextLayout(&wch, 1, pTextFormat, 1000.0, 1000.0, &pTextLayout);
+		const HRESULT hr = pIDWriteFactory->CreateTextLayout(&wch, 1, pTextFormat, 1000.0, 1000.0, &pTextLayout);
 		if (SUCCEEDED(hr)) {
 			DWRITE_TEXT_METRICS textMetrics;
 			if (SUCCEEDED(pTextLayout->GetMetrics(&textMetrics)))
@@ -1726,7 +1726,7 @@
 		IDWriteTextLayout *pTextLayout = 0;
 		const WCHAR wszAllAlpha[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 		const size_t lenAllAlpha = wcslen(wszAllAlpha);
-		HRESULT hr = pIDWriteFactory->CreateTextLayout(wszAllAlpha, static_cast<UINT32>(lenAllAlpha),
+		const HRESULT hr = pIDWriteFactory->CreateTextLayout(wszAllAlpha, static_cast<UINT32>(lenAllAlpha),
 			pTextFormat, 1000.0, 1000.0, &pTextLayout);
 		if (SUCCEEDED(hr)) {
 			DWRITE_TEXT_METRICS textMetrics;
@@ -1812,7 +1812,7 @@
 }
 
 void Window::SetPositionRelative(PRectangle rc, Window w) {
-	LONG style = ::GetWindowLong(static_cast<HWND>(wid), GWL_STYLE);
+	const LONG style = ::GetWindowLong(static_cast<HWND>(wid), GWL_STYLE);
 	if (style & WS_POPUP) {
 		POINT ptOther = {0, 0};
 		::ClientToScreen(static_cast<HWND>(w.GetID()), &ptOther);
@@ -2194,7 +2194,7 @@
 	SelectFont(hdc, oldFont);
 	::ReleaseDC(lb, hdc);
 
-	int widthDesired = Platform::Maximum(textSize.cx, (len + 1) * tm.tmAveCharWidth);
+	const int widthDesired = Platform::Maximum(textSize.cx, (len + 1) * tm.tmAveCharWidth);
 	if (width < widthDesired)
 		width = widthDesired;
 
@@ -2253,7 +2253,7 @@
 }
 
 void ListBoxX::GetValue(int n, char *value, int len) {
-	ListItemData item = lti.Get(n);
+	const ListItemData item = lti.Get(n);
 	strncpy(value, item.text, len);
 	value[len-1] = '\0';
 }
@@ -2289,7 +2289,7 @@
 			::SetTextColor(pDrawItem->hDC, ::GetSysColor(COLOR_WINDOWTEXT));
 		}
 
-		ListItemData item = lti.Get(pDrawItem->itemID);
+		const ListItemData item = lti.Get(pDrawItem->itemID);
 		int pixId = item.pixId;
 		const char *text = item.text;
 		int len = static_cast<int>(strlen(text));
@@ -2305,13 +2305,13 @@
 		}
 
 		// Draw the image, if any
-		RGBAImage *pimage = images.Get(pixId);
+		const RGBAImage *pimage = images.Get(pixId);
 		if (pimage) {
 			Surface *surfaceItem = Surface::Allocate(technology);
 			if (surfaceItem) {
 				if (technology == SCWIN_TECH_GDI) {
 					surfaceItem->Init(pDrawItem->hDC, pDrawItem->hwndItem);
-					long left = pDrawItem->rcItem.left + static_cast<int>(ItemInset.x + ImageInset.x);
+					const long left = pDrawItem->rcItem.left + static_cast<int>(ItemInset.x + ImageInset.x);
 					PRectangle rcImage = PRectangle::FromInts(left, pDrawItem->rcItem.top,
 						left + images.GetWidth(), pDrawItem->rcItem.bottom);
 					surfaceItem->DrawRGBAImage(rcImage,
@@ -2339,7 +2339,7 @@
 						if (SUCCEEDED(hr)) {
 							surfaceItem->Init(pDCRT, pDrawItem->hwndItem);
 							pDCRT->BeginDraw();
-							long left = pDrawItem->rcItem.left + static_cast<long>(ItemInset.x + ImageInset.x);
+							const long left = pDrawItem->rcItem.left + static_cast<long>(ItemInset.x + ImageInset.x);
 							PRectangle rcImage = PRectangle::FromInts(left, pDrawItem->rcItem.top,
 								left + images.GetWidth(), pDrawItem->rcItem.bottom);
 							surfaceItem->DrawRGBAImage(rcImage,
@@ -2371,7 +2371,7 @@
 	}
 
 	lti.AllocItem(text, pixId);
-	unsigned int len = static_cast<unsigned int>(strlen(text));
+	const unsigned int len = static_cast<unsigned int>(strlen(text));
 	if (maxItemCharacters < len) {
 		maxItemCharacters = len;
 		widestItem = text;
@@ -2383,7 +2383,7 @@
 	// the listbox is not visible.
 	SetRedraw(false);
 	Clear();
-	size_t size = strlen(list);
+	const size_t size = strlen(list);
 	char *words = lti.SetWords(list);
 	char *startword = words;
 	char *numword = NULL;
@@ -2422,7 +2422,7 @@
 
 int ListBoxX::ItemHeight() const {
 	int itemHeight = lineHeight + (static_cast<int>(TextInset.y) * 2);
-	int pixHeight = images.GetHeight() + (static_cast<int>(ImageInset.y) * 2);
+	const int pixHeight = images.GetHeight() + (static_cast<int>(ImageInset.y) * 2);
 	if (itemHeight < pixHeight) {
 		itemHeight = pixHeight;
 	}
@@ -2570,8 +2570,8 @@
 	// window caption height + frame, even if one is hovering over the bottom edge of
 	// the frame, so workaround that here
 	if (hit >= HTTOP && hit <= HTTOPRIGHT) {
-		int minHeight = GetSystemMetrics(SM_CYMINTRACK);
-		int yPos = GET_Y_LPARAM(lParam);
+		const int minHeight = GetSystemMetrics(SM_CYMINTRACK);
+		const int yPos = GET_Y_LPARAM(lParam);
 		if ((rc.Height() < minHeight) && (yPos > ((rc.top + rc.bottom)/2))) {
 			hit += HTBOTTOM - HTTOP;
 		}
@@ -2625,10 +2625,10 @@
 void ListBoxX::CentreItem(int n) {
 	// If below mid point, scroll up to centre, but with more items below if uneven
 	if (n >= 0) {
-		POINT extent = GetClientExtent();
-		int visible = extent.y/ItemHeight();
+		const POINT extent = GetClientExtent();
+		const int visible = extent.y/ItemHeight();
 		if (visible < Length()) {
-			LRESULT top = ::SendMessage(lb, LB_GETTOPINDEX, 0, 0);
+			const LRESULT top = ::SendMessage(lb, LB_GETTOPINDEX, 0, 0);
 			int half = (visible - 1) / 2;
 			if (n > (top + half))
 				::SendMessage(lb, LB_SETTOPINDEX, n - half , 0);
@@ -2680,7 +2680,7 @@
 		case WM_LBUTTONDOWN: {
 				// We must take control of selection to prevent the ListBox activating
 				// the popup
-				LRESULT lResult = ::SendMessage(hWnd, LB_ITEMFROMPOINT, 0, lParam);
+				const LRESULT lResult = ::SendMessage(hWnd, LB_ITEMFROMPOINT, 0, lParam);
 				int item = LOWORD(lResult);
 				if (HIWORD(lResult) == 0 && item >= 0) {
 					::SendMessage(hWnd, LB_SETCURSEL, item, 0);
@@ -2816,7 +2816,7 @@
 	case WM_MOUSEWHEEL:
 		wheelDelta -= static_cast<short>(HIWORD(wParam));
 		if (abs(wheelDelta) >= WHEEL_DELTA) {
-			int nRows = GetVisibleRows();
+			const int nRows = GetVisibleRows();
 			int linesToScroll = 1;
 			if (nRows > 1) {
 				linesToScroll = nRows - 1;
@@ -2939,12 +2939,12 @@
 		LARGE_INTEGER lBegin;
 		lBegin.HighPart = bigBit;
 		lBegin.LowPart = littleBit;
-		double elapsed = static_cast<double>(lEnd.QuadPart - lBegin.QuadPart);
+		const double elapsed = static_cast<double>(lEnd.QuadPart - lBegin.QuadPart);
 		result = elapsed / static_cast<double>(frequency.QuadPart);
 	} else {
 		endBigBit = clock();
 		endLittleBit = 0;
-		double elapsed = endBigBit - bigBit;
+		const double elapsed = endBigBit - bigBit;
 		result = elapsed / CLOCKS_PER_SEC;
 	}
 	if (reset) {
@@ -3036,7 +3036,7 @@
 
 bool Platform::IsDBCSLeadByte(int codePage, char ch) {
 	// Byte ranges found in Wikipedia articles with relevant search strings in each case
-	unsigned char uch = static_cast<unsigned char>(ch);
+	const unsigned char uch = static_cast<unsigned char>(ch);
 	switch (codePage) {
 	case 932:
 		// Shift_jis
@@ -3109,7 +3109,7 @@
 static bool assertionPopUps = true;
 
 bool Platform::ShowAssertionPopUps(bool assertionPopUps_) {
-	bool ret = assertionPopUps;
+	const bool ret = assertionPopUps;
 	assertionPopUps = assertionPopUps_;
 	return ret;
 }
@@ -3118,7 +3118,7 @@
 	char buffer[2000];
 	sprintf(buffer, "Assertion [%s] failed at %s %d%s", c, file, line, assertionPopUps ? "" : "\r\n");
 	if (assertionPopUps) {
-		int idButton = ::MessageBoxA(0, buffer, "Assertion failure",
+		const int idButton = ::MessageBoxA(0, buffer, "Assertion failure",
 			MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
 		if (idButton == IDRETRY) {
 			::DebugBreak();
diff -r 797ed6c538fd -r d046ce80d590 win32/ScintillaWin.cxx
--- a/win32/ScintillaWin.cxx	Thu Apr 06 20:19:23 2017 +1000
+++ b/win32/ScintillaWin.cxx	Thu Apr 06 21:04:37 2017 +1000
@@ -594,8 +594,8 @@
 }
 
 bool ScintillaWin::DragThreshold(Point ptStart, Point ptNow) {
-	int xMove = static_cast<int>(std::abs(ptStart.x - ptNow.x));
-	int yMove = static_cast<int>(std::abs(ptStart.y - ptNow.y));
+	const int xMove = static_cast<int>(std::abs(ptStart.x - ptNow.x));
+	const int yMove = static_cast<int>(std::abs(ptStart.y - ptNow.y));
 	return (xMove > ::GetSystemMetrics(SM_CXDRAG)) ||
 		(yMove > ::GetSystemMetrics(SM_CYDRAG));
 }
@@ -607,7 +607,7 @@
 	IDataObject *pDataObject = reinterpret_cast<IDataObject *>(&dob);
 	IDropSource *pDropSource = reinterpret_cast<IDropSource *>(&ds);
 	//Platform::DebugPrintf("About to DoDragDrop %x %x\n", pDataObject, pDropSource);
-	HRESULT hr = ::DoDragDrop(
+	const HRESULT hr = ::DoDragDrop(
 	                 pDataObject,
 	                 pDropSource,
 	                 DROPEFFECT_COPY | DROPEFFECT_MOVE, &dwEffect);
@@ -635,7 +635,7 @@
 	HKL inputLocale = ::GetKeyboardLayout(0);
 	LANGID inputLang = LOWORD(inputLocale);
 	char sCodePage[10];
-	int res = ::GetLocaleInfoA(MAKELCID(inputLang, SORT_DEFAULT),
+	const int res = ::GetLocaleInfoA(MAKELCID(inputLang, SORT_DEFAULT),
 	  LOCALE_IDEFAULTANSICODEPAGE, sCodePage, sizeof(sCodePage));
 	if (!res)
 		return 0;
@@ -687,7 +687,7 @@
 			if (hRgnCheck) {
 				HRGN hRgnDifference = ::CreateRectRgn(0, 0, 0, 0);
 				if (hRgnDifference) {
-					int combination = ::CombineRgn(hRgnDifference, hRgnCheck, hRgnBounds, RGN_DIFF);
+					const int combination = ::CombineRgn(hRgnDifference, hRgnCheck, hRgnBounds, RGN_DIFF);
 					if (combination != NULLREGION) {
 						contains = false;
 					}
@@ -788,7 +788,7 @@
 	} else {
 		UINT cpDest = CodePageOfDocument();
 		char inBufferCP[maxLenInputIME * 2];
-		int size = ::WideCharToMultiByte(cpDest,
+		const int size = ::WideCharToMultiByte(cpDest,
 			0, wcs, wclen, inBufferCP, sizeof(inBufferCP) - 1, 0, 0);
 		for (int i=0; i<size; i++) {
 			AddChar(inBufferCP[i]);
@@ -800,12 +800,12 @@
 	//ElapsedTime et;
 
 	// Redirect assertions to debug output and save current state
-	bool assertsPopup = Platform::ShowAssertionPopUps(false);
+	const bool assertsPopup = Platform::ShowAssertionPopUps(false);
 	paintState = painting;
 	PAINTSTRUCT ps;
 	PAINTSTRUCT *pps;
 
-	bool IsOcxCtrl = (wParam != 0); // if wParam != 0, it contains
+	const bool IsOcxCtrl = (wParam != 0); // if wParam != 0, it contains
 								   // a PAINSTRUCT* from the OCX
 	// Removed since this interferes with reporting other assertions as it occurs repeatedly
 	//PLATFORM_ASSERT(hRgnUpdate == NULL);
@@ -818,7 +818,7 @@
 		::BeginPaint(MainHWND(), pps);
 	}
 	rcPaint = PRectangle::FromInts(pps->rcPaint.left, pps->rcPaint.top, pps->rcPaint.right, pps->rcPaint.bottom);
-	PRectangle rcClient = GetClientRectangle();
+	const PRectangle rcClient = GetClientRectangle();
 	paintingAllText = BoundsContains(rcPaint, hRgnUpdate, rcClient);
 	if (technology == SC_TECHNOLOGY_DEFAULT) {
 		AutoSurface surfaceWindow(pps->hdc, this);
@@ -834,7 +834,7 @@
 			pRenderTarget->BeginDraw();
 			Paint(surfaceWindow, rcPaint);
 			surfaceWindow->Release();
-			HRESULT hr = pRenderTarget->EndDraw();
+			const HRESULT hr = pRenderTarget->EndDraw();
 			if (hr == static_cast<HRESULT>(D2DERR_RECREATE_TARGET)) {
 				DropRenderTarget();
 				paintState = paintAbandoned;
@@ -939,7 +939,7 @@
 		pdoc->GetCharRange(&documentStr[0], selStart, documentStrLen);
 
 		std::wstring uniStr = StringDecode(documentStr, CodePageOfDocument());
-		int converted = HanjaDict::GetHangulOfHanja(&uniStr[0]);
+		const int converted = HanjaDict::GetHangulOfHanja(&uniStr[0]);
 		documentStr = StringEncode(uniStr, CodePageOfDocument());
 
 		if (converted > 0) {
@@ -1028,7 +1028,7 @@
 	if (wcs.empty())
 		return;
 
-	int codePage = CodePageOfDocument();
+	const int codePage = CodePageOfDocument();
 	for (size_t i = 0; i < wcs.size(); ) {
 		const size_t ucWidth = UTF16CharLength(wcs[i]);
 		const std::wstring uniChar(wcs, i, ucWidth);
@@ -1075,9 +1075,9 @@
 
 		std::vector<int> imeIndicator = MapImeIndicators(imc.GetImeAttributes());
 
-		bool tmpRecordingMacro = recordingMacro;
+		const bool tmpRecordingMacro = recordingMacro;
 		recordingMacro = false;
-		int codePage = CodePageOfDocument();
+		const int codePage = CodePageOfDocument();
 		for (size_t i = 0; i < wcs.size(); ) {
 			const size_t ucWidth = UTF16CharLength(wcs[i]);
 			const std::wstring uniChar(wcs, i, ucWidth);
@@ -1091,7 +1091,7 @@
 		recordingMacro = tmpRecordingMacro;
 
 		// Move IME caret from current last position to imeCaretPos.
-		int imeEndToImeCaretU16 = imc.GetImeCaretPos() - static_cast<unsigned int>(wcs.size());
+		const int imeEndToImeCaretU16 = imc.GetImeCaretPos() - static_cast<unsigned int>(wcs.size());
 		Sci::Position imeCaretPosDoc = pdoc->GetRelativePositionUTF16(CurrentPosition(), imeEndToImeCaretU16);
 
 		MoveImeCarets(- CurrentPosition() + imeCaretPosDoc);
@@ -1352,8 +1352,8 @@
 #ifdef _MSC_VER
 #pragma warning(suppress: 28159)
 #endif
-						DWORD dwCurrent = GetTickCount();
-						DWORD dwStart = wParam ? static_cast<DWORD>(wParam) : dwCurrent;
+						const DWORD dwCurrent = GetTickCount();
+						const DWORD dwStart = wParam ? static_cast<DWORD>(wParam) : dwCurrent;
 						const DWORD maxWorkTime = 50;
 
 						if (dwCurrent >= dwStart && dwCurrent > maxWorkTime && dwCurrent - maxWorkTime < dwStart)
@@ -1484,7 +1484,7 @@
 		case WM_KEYDOWN: {
 			//Platform::DebugPrintf("S keydown %d %x %x %x %x\n",iMessage, wParam, lParam, ::IsKeyDown(VK_SHIFT), ::IsKeyDown(VK_CONTROL));
 				lastKeyDownConsumed = false;
-				int ret = KeyDown(KeyTranslate(static_cast<int>(wParam)),
+				const int ret = KeyDown(KeyTranslate(static_cast<int>(wParam)),
 					Platform::IsKeyDown(VK_SHIFT),
 					Platform::IsKeyDown(VK_CONTROL),
 					Platform::IsKeyDown(VK_MENU),
@@ -1526,7 +1526,7 @@
 		case WM_KILLFOCUS: {
 				HWND wOther = reinterpret_cast<HWND>(wParam);
 				HWND wThis = MainHWND();
-				HWND wCT = static_cast<HWND>(ct.wCallTip.GetID());
+				const HWND wCT = static_cast<HWND>(ct.wCallTip.GetID());
 				if (!wParam ||
 					!(::IsChild(wThis, wOther) || (wOther == wCT))) {
 					SetFocusState(false);
@@ -1929,7 +1929,7 @@
 		modified = true;
 	}
 
-	PRectangle rcText = GetTextRectangle();
+	const PRectangle rcText = GetTextRectangle();
 	int horizEndPreferred = scrollWidth;
 	if (horizEndPreferred < 0)
 		horizEndPreferred = 0;
@@ -2013,7 +2013,7 @@
 			if (lenMixed > utf16Mixed.size()) {
 				utf16Mixed.resize(lenMixed + 8);
 			}
-			size_t nUtf16Mixed = ::MultiByteToWideChar(cp, 0, mixed,
+			const size_t nUtf16Mixed = ::MultiByteToWideChar(cp, 0, mixed,
 				static_cast<int>(lenMixed),
 				&utf16Mixed[0],
 				static_cast<int>(utf16Mixed.size()));
@@ -2032,7 +2032,7 @@
 				if (foldedUTF8) {
 					// Maximum length of a case conversion is 6 bytes, 3 characters
 					wchar_t wFolded[20];
-					size_t charsConverted = UTF16FromUTF8(foldedUTF8,
+					const size_t charsConverted = UTF16FromUTF8(foldedUTF8,
 							strlen(foldedUTF8),
 							wFolded, ELEMENTS(wFolded));
 					for (size_t j=0; j<charsConverted; j++)
@@ -2072,18 +2072,18 @@
 				char sCharacter[2] = "A";
 				sCharacter[0] = static_cast<char>(i);
 				wchar_t wCharacter[20];
-				unsigned int lengthUTF16 = ::MultiByteToWideChar(cpDoc, 0, sCharacter, 1,
+				const unsigned int lengthUTF16 = ::MultiByteToWideChar(cpDoc, 0, sCharacter, 1,
 					wCharacter, ELEMENTS(wCharacter));
 				if (lengthUTF16 == 1) {
 					const char *caseFolded = CaseConvert(wCharacter[0], CaseConversionFold);
 					if (caseFolded) {
 						wchar_t wLower[20];
-						size_t charsConverted = UTF16FromUTF8(caseFolded,
+						const size_t charsConverted = UTF16FromUTF8(caseFolded,
 							strlen(caseFolded),
 							wLower, ELEMENTS(wLower));
 						if (charsConverted == 1) {
 							char sCharacterLowered[20];
-							unsigned int lengthConverted = ::WideCharToMultiByte(cpDoc, 0,
+							const unsigned int lengthConverted = ::WideCharToMultiByte(cpDoc, 0,
 								wLower, static_cast<int>(charsConverted),
 								sCharacterLowered, ELEMENTS(sCharacterLowered), NULL, 0);
 							if ((lengthConverted == 1) && (sCharacter[0] != sCharacterLowered[0])) {
@@ -2234,7 +2234,7 @@
 			std::vector<char> putf;
 			// Default Scintilla behaviour in Unicode mode
 			if (IsUnicodeMode()) {
-				unsigned int bytes = static_cast<unsigned int>(memUSelection.Size());
+				const unsigned int bytes = static_cast<unsigned int>(memUSelection.Size());
 				len = UTF8Length(uptr, bytes / 2);
 				putf.resize(len + 1);
 				UTF8FromUTF16(uptr, bytes / 2, &putf[0], len);
@@ -2258,7 +2258,7 @@
 		if (memSelection) {
 			char *ptr = static_cast<char *>(memSelection.ptr);
 			if (ptr) {
-				unsigned int bytes = static_cast<unsigned int>(memSelection.Size());
+				const unsigned int bytes = static_cast<unsigned int>(memSelection.Size());
 				unsigned int len = bytes;
 				for (unsigned int i = 0; i < bytes; i++) {
 					if ((len == bytes) && (0 == ptr[i]))
@@ -2269,7 +2269,7 @@
 				if (IsUnicodeMode()) {
 					std::vector<wchar_t> uptr(len+1);
 
-					unsigned int ulen = ::MultiByteToWideChar(CP_ACP, 0,
+					const unsigned int ulen = ::MultiByteToWideChar(CP_ACP, 0,
 					                    ptr, len, &uptr[0], len+1);
 
 					unsigned int mlen = UTF8Length(&uptr[0], ulen);
@@ -2460,7 +2460,7 @@
 		return S_OK;
 	}
 
-	bool formatOK = (pFE->cfFormat == CF_TEXT) ||
+	const bool formatOK = (pFE->cfFormat == CF_TEXT) ||
 		((pFE->cfFormat == CF_UNICODETEXT) && pd->sci->IsUnicodeMode());
 	if (!formatOK ||
 	    pFE->ptd != 0 ||
@@ -2855,8 +2855,8 @@
 
 void ScintillaWin::HorizontalScrollMessage(WPARAM wParam) {
 	int xPos = xOffset;
-	PRectangle rcText = GetTextRectangle();
-	int pageWidth = static_cast<int>(rcText.Width() * 2 / 3);
+	const PRectangle rcText = GetTextRectangle();
+	const int pageWidth = static_cast<int>(rcText.Width() * 2 / 3);
 	switch (LoWord(wParam)) {
 	case SB_LINEUP:
 		xPos -= 20;
@@ -2930,7 +2930,7 @@
 			pRenderTarget->BeginDraw();
 			Paint(surfaceWindow, rcPaint);
 			surfaceWindow->Release();
-			HRESULT hr = pRenderTarget->EndDraw();
+			const HRESULT hr = pRenderTarget->EndDraw();
 			if (hr == static_cast<HRESULT>(D2DERR_RECREATE_TARGET)) {
 				DropRenderTarget();
 			}
@@ -2946,7 +2946,7 @@
 
 bool ScintillaWin::IsCompatibleDC(HDC hOtherDC) {
 	HDC hdc = ::GetDC(MainHWND());
-	bool isCompatible =
+	const bool isCompatible =
 		CompareDevCap(hdc, hOtherDC, TECHNOLOGY) &&
 		CompareDevCap(hdc, hOtherDC, LOGPIXELSY) &&
 		CompareDevCap(hdc, hOtherDC, LOGPIXELSX) &&
@@ -3000,11 +3000,11 @@
 	if (pIDataSource == NULL)
 		return E_POINTER;
 	FORMATETC fmtu = {CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
-	HRESULT hrHasUText = pIDataSource->QueryGetData(&fmtu);
+	const HRESULT hrHasUText = pIDataSource->QueryGetData(&fmtu);
 	hasOKText = (hrHasUText == S_OK);
 	if (!hasOKText) {
 		FORMATETC fmte = {CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
-		HRESULT hrHasText = pIDataSource->QueryGetData(&fmte);
+		const HRESULT hrHasText = pIDataSource->QueryGetData(&fmte);
 		hasOKText = (hrHasText == S_OK);
 	}
 	if (!hasOKText) {
@@ -3068,7 +3068,7 @@
 			wchar_t *udata = static_cast<wchar_t *>(memUDrop.ptr);
 			if (udata) {
 				if (IsUnicodeMode()) {
-					int tlen = static_cast<int>(memUDrop.Size());
+					const int tlen = static_cast<int>(memUDrop.Size());
 					// Convert UTF-16 to UTF-8
 					int dataLen = UTF8Length(udata, tlen/2);
 					data.resize(dataLen+1);
@@ -3129,7 +3129,7 @@
 
 /// Implement important part of IDataObject
 STDMETHODIMP ScintillaWin::GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) {
-	bool formatOK = (pFEIn->cfFormat == CF_TEXT) ||
+	const bool formatOK = (pFEIn->cfFormat == CF_TEXT) ||
 		((pFEIn->cfFormat == CF_UNICODETEXT) && IsUnicodeMode());
 	if (!formatOK ||
 	    pFEIn->ptd != 0 ||
@@ -3421,7 +3421,7 @@
 // Must be called once only.
 int Scintilla_RegisterClasses(void *hInstance) {
 	Platform_Initialise(hInstance);
-	bool result = ScintillaWin::Register(static_cast<HINSTANCE>(hInstance));
+	const bool result = ScintillaWin::Register(static_cast<HINSTANCE>(hInstance));
 #ifdef SCI_LEXER
 	Scintilla_LinkLexers();
 #endif
@@ -3429,7 +3429,7 @@
 }
 
 static int ResourcesRelease(bool fromDllMain) {
-	bool result = ScintillaWin::Unregister();
+	const bool result = ScintillaWin::Unregister();
 	Platform_Finalise(fromDllMain);
 	return result;
 }
