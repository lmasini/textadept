# HG changeset patch
# User Neil <nyamatongwe@gmail.com>
# Date 1490944778 -39600
# Node ID a0f26eaf474d98cb999629f79a3d082c0028925b
# Parent  1788f6795302a077e98c9cea25100068eef8624b
Using Sci::Position and Sci::Line to mark variables that are document positions
and lines.

diff -r 1788f6795302 -r a0f26eaf474d cocoa/ScintillaCocoa.h
--- a/cocoa/ScintillaCocoa.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/cocoa/ScintillaCocoa.h	Fri Mar 31 18:19:38 2017 +1100
@@ -158,10 +158,10 @@
   void SetMouseCapture(bool on) override;
   bool HaveMouseCapture() override;
   void WillDraw(NSRect rect);
-  void ScrollText(int linesToMove) override;
+  void ScrollText(Sci::Line linesToMove) override;
   void SetVerticalScrollPos() override;
   void SetHorizontalScrollPos() override;
-  bool ModifyScrollBars(int nMax, int nPage) override;
+  bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) override;
   bool SetScrollingSize(void);
   void Resize();
   void UpdateForScroll();
@@ -197,7 +197,7 @@
   void ObserverAdd();
   void ObserverRemove();
   void IdleWork() override;
-  void QueueIdleWork(WorkNeeded::workItems items, int upTo) override;
+  void QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo) override;
   int InsertText(NSString* input);
   NSRange PositionsFromCharacters(NSRange rangeCharacters) const;
   NSRange CharactersFromPositions(NSRange rangePositions) const;
diff -r 1788f6795302 -r a0f26eaf474d cocoa/ScintillaCocoa.mm
--- a/cocoa/ScintillaCocoa.mm	Thu Mar 30 09:11:48 2017 +1100
+++ b/cocoa/ScintillaCocoa.mm	Fri Mar 31 18:19:38 2017 +1100
@@ -522,7 +522,7 @@
 
 //--------------------------------------------------------------------------------------------------
 
-void ScintillaCocoa::QueueIdleWork(WorkNeeded::workItems items, int upTo) {
+void ScintillaCocoa::QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo) {
   Editor::QueueIdleWork(items, upTo);
   ObserverAdd();
 }
@@ -1236,7 +1236,7 @@
  */
 NSPoint ScintillaCocoa::GetCaretPosition()
 {
-  const int line = pdoc->LineFromPosition(sel.RangeMain().caret.Position());
+  const Sci::Line line = pdoc->LineFromPosition(sel.RangeMain().caret.Position());
   NSPoint result;
 
   result.y = line;
@@ -1261,9 +1261,9 @@
   }
 
   // TODO: does not work for wrapped lines, fix it.
-  int line = pdoc->LineFromPosition(posDrag.Position());
-  int currentVisibleLine = cs.DisplayFromDoc(line);
-  int lastVisibleLine = Platform::Minimum(topLine + LinesOnScreen(), cs.LinesDisplayed()) - 2;
+  Sci::Line line = pdoc->LineFromPosition(posDrag.Position());
+  Sci::Line currentVisibleLine = cs.DisplayFromDoc(line);
+  Sci::Line lastVisibleLine = Platform::Minimum(topLine + LinesOnScreen(), cs.LinesDisplayed()) - 2;
 
   if (currentVisibleLine <= topLine && topLine > 0)
     ScrollTo(topLine - scrollSpeed);
@@ -1368,10 +1368,10 @@
 
   // calculate the bounds of the selection
   PRectangle client = GetTextRectangle();
-  int selStart = sel.RangeMain().Start().Position();
-  int selEnd = sel.RangeMain().End().Position();
-  int startLine = pdoc->LineFromPosition(selStart);
-  int endLine = pdoc->LineFromPosition(selEnd);
+  Sci::Position selStart = sel.RangeMain().Start().Position();
+  Sci::Position selEnd = sel.RangeMain().End().Position();
+  Sci::Line startLine = pdoc->LineFromPosition(selStart);
+  Sci::Line endLine = pdoc->LineFromPosition(selEnd);
   Point pt;
   long startPos, endPos, ep;
   PRectangle rcSel;
@@ -1561,7 +1561,7 @@
 void ScintillaCocoa::DraggingExited(id <NSDraggingInfo> info)
 {
 #pragma unused(info)
-  SetDragPosition(SelectionPosition(invalidPosition));
+  SetDragPosition(SelectionPosition(Sci::invalidPosition));
   FineTickerCancel(tickPlatform);
   inDragDrop = ddNone;
 }
@@ -1914,7 +1914,7 @@
 /**
  * ScrollText is empty because scrolling is handled by the NSScrollView.
  */
-void ScintillaCocoa::ScrollText(int)
+void ScintillaCocoa::ScrollText(Sci::Line)
 {
 }
 
@@ -1968,7 +1968,7 @@
  * @param nPage Number of lines per scroll page.
  * @return True if there was a change, otherwise false.
  */
-bool ScintillaCocoa::ModifyScrollBars(int nMax, int nPage)
+bool ScintillaCocoa::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
 {
 #pragma unused(nMax, nPage)
   return SetScrollingSize();
diff -r 1788f6795302 -r a0f26eaf474d gtk/ScintillaGTK.cxx
--- a/gtk/ScintillaGTK.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/gtk/ScintillaGTK.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -1029,7 +1029,7 @@
 	return rc;
 }
 
-void ScintillaGTK::ScrollText(int linesToMove) {
+void ScintillaGTK::ScrollText(Sci::Line linesToMove) {
 	int diff = vs.lineHeight * -linesToMove;
 	//Platform::DebugPrintf("ScintillaGTK::ScrollText %d %d %0d,%0d %0d,%0d\n", linesToMove, diff,
 	//	rc.left, rc.top, rc.right, rc.bottom);
@@ -1052,7 +1052,7 @@
 	gtk_adjustment_set_value(GTK_ADJUSTMENT(adjustmenth), xOffset);
 }
 
-bool ScintillaGTK::ModifyScrollBars(int nMax, int nPage) {
+bool ScintillaGTK::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) {
 	bool modified = false;
 	int pageScroll = LinesToScroll();
 
@@ -2763,7 +2763,7 @@
 void ScintillaGTK::DragLeave(GtkWidget *widget, GdkDragContext * /*context*/, guint) {
 	ScintillaGTK *sciThis = FromWidget(widget);
 	try {
-		sciThis->SetDragPosition(SelectionPosition(invalidPosition));
+		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
 		//Platform::DebugPrintf("DragLeave %x\n", sciThis);
 	} catch (...) {
 		sciThis->errorStatus = SC_STATUS_FAILURE;
@@ -2776,7 +2776,7 @@
 		// If drag did not result in drop here or elsewhere
 		if (!sciThis->dragWasDropped)
 			sciThis->SetEmptySelection(sciThis->posDrag);
-		sciThis->SetDragPosition(SelectionPosition(invalidPosition));
+		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
 		//Platform::DebugPrintf("DragEnd %x %d\n", sciThis, sciThis->dragWasDropped);
 		sciThis->inDragDrop = ddNone;
 	} catch (...) {
@@ -2789,7 +2789,7 @@
 	ScintillaGTK *sciThis = FromWidget(widget);
 	try {
 		//Platform::DebugPrintf("Drop %x\n", sciThis);
-		sciThis->SetDragPosition(SelectionPosition(invalidPosition));
+		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
 	} catch (...) {
 		sciThis->errorStatus = SC_STATUS_FAILURE;
 	}
@@ -2801,7 +2801,7 @@
 	ScintillaGTK *sciThis = FromWidget(widget);
 	try {
 		sciThis->ReceivedDrop(selection_data);
-		sciThis->SetDragPosition(SelectionPosition(invalidPosition));
+		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
 	} catch (...) {
 		sciThis->errorStatus = SC_STATUS_FAILURE;
 	}
@@ -2832,7 +2832,7 @@
 			}
 			sciThis->ClearSelection();
 		}
-		sciThis->SetDragPosition(SelectionPosition(invalidPosition));
+		sciThis->SetDragPosition(SelectionPosition(Sci::invalidPosition));
 	} catch (...) {
 		sciThis->errorStatus = SC_STATUS_FAILURE;
 	}
@@ -2870,7 +2870,7 @@
 	styleIdleID = 0;
 }
 
-void ScintillaGTK::QueueIdleWork(WorkNeeded::workItems items, int upTo) {
+void ScintillaGTK::QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo) {
 	Editor::QueueIdleWork(items, upTo);
 	if (!styleIdleID) {
 		// Only allow one style needed to be queued
diff -r 1788f6795302 -r a0f26eaf474d gtk/ScintillaGTK.h
--- a/gtk/ScintillaGTK.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/gtk/ScintillaGTK.h	Fri Mar 31 18:19:38 2017 +1100
@@ -111,10 +111,10 @@
 	virtual bool PaintContains(PRectangle rc);
 	void FullPaint();
 	virtual PRectangle GetClientRectangle() const;
-	virtual void ScrollText(int linesToMove);
+	virtual void ScrollText(Sci::Line linesToMove);
 	virtual void SetVerticalScrollPos();
 	virtual void SetHorizontalScrollPos();
-	virtual bool ModifyScrollBars(int nMax, int nPage);
+	virtual bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage);
 	void ReconfigureScrollBars();
 	virtual void NotifyChange();
 	virtual void NotifyFocus(bool focus);
@@ -231,7 +231,7 @@
 	static gboolean IdleCallback(gpointer pSci);
 	static gboolean StyleIdle(gpointer pSci);
 	virtual void IdleWork();
-	virtual void QueueIdleWork(WorkNeeded::workItems items, int upTo);
+	virtual void QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo);
 	virtual void SetDocPointer(Document *document);
 	static void PopUpCB(GtkMenuItem *menuItem, ScintillaGTK *sciThis);
 
diff -r 1788f6795302 -r a0f26eaf474d gtk/ScintillaGTKAccessible.cxx
--- a/gtk/ScintillaGTKAccessible.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/gtk/ScintillaGTKAccessible.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -168,7 +168,7 @@
 	}
 }
 
-gchar *ScintillaGTKAccessible::GetTextRangeUTF8(Position startByte, Position endByte) {
+gchar *ScintillaGTKAccessible::GetTextRangeUTF8(Sci::Position startByte, Sci::Position endByte) {
 	g_return_val_if_fail(startByte >= 0, NULL);
 	// FIXME: should we swap start/end if necessary?
 	g_return_val_if_fail(endByte >= startByte, NULL);
@@ -196,7 +196,7 @@
 }
 
 gchar *ScintillaGTKAccessible::GetText(int startChar, int endChar) {
-	Position startByte, endByte;
+	Sci::Position startByte, endByte;
 	if (endChar == -1) {
 		startByte = ByteOffsetFromCharacterOffset(startChar);
 		endByte = sci->pdoc->Length();
@@ -210,8 +210,8 @@
 		AtkTextBoundary boundaryType, int *startChar, int *endChar) {
 	g_return_val_if_fail(charOffset >= 0, NULL);
 
-	Position startByte, endByte;
-	Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position startByte, endByte;
+	Sci::Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
 
 	switch (boundaryType) {
 		case ATK_TEXT_BOUNDARY_CHAR:
@@ -261,8 +261,8 @@
 		AtkTextBoundary boundaryType, int *startChar, int *endChar) {
 	g_return_val_if_fail(charOffset >= 0, NULL);
 
-	Position startByte, endByte;
-	Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position startByte, endByte;
+	Sci::Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
 
 	switch (boundaryType) {
 		case ATK_TEXT_BOUNDARY_CHAR:
@@ -323,8 +323,8 @@
 		AtkTextBoundary boundaryType, int *startChar, int *endChar) {
 	g_return_val_if_fail(charOffset >= 0, NULL);
 
-	Position startByte, endByte;
-	Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position startByte, endByte;
+	Sci::Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
 
 	switch (boundaryType) {
 		case ATK_TEXT_BOUNDARY_CHAR:
@@ -386,8 +386,8 @@
 		AtkTextGranularity granularity, int *startChar, int *endChar) {
 	g_return_val_if_fail(charOffset >= 0, NULL);
 
-	Position startByte, endByte;
-	Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position startByte, endByte;
+	Sci::Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
 
 	switch (granularity) {
 		case ATK_TEXT_GRANULARITY_CHAR:
@@ -417,8 +417,8 @@
 gunichar ScintillaGTKAccessible::GetCharacterAtOffset(int charOffset) {
 	g_return_val_if_fail(charOffset >= 0, 0);
 
-	Position startByte = ByteOffsetFromCharacterOffset(charOffset);
-	Position endByte = PositionAfter(startByte);
+	Sci::Position startByte = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position endByte = PositionAfter(startByte);
 	gchar *ch = GetTextRangeUTF8(startByte, endByte);
 	gunichar unichar = g_utf8_get_char_validated(ch, -1);
 	g_free(ch);
@@ -466,7 +466,7 @@
 		gint *x, gint *y, gint *width, gint *height, AtkCoordType coords) {
 	*x = *y = *height = *width = 0;
 
-	Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
+	Sci::Position byteOffset = ByteOffsetFromCharacterOffset(charOffset);
 
 	// FIXME: should we handle scrolling?
 	*x = sci->WndProc(SCI_POINTXFROMPOSITION, 0, byteOffset);
@@ -550,7 +550,7 @@
 AtkAttributeSet *ScintillaGTKAccessible::GetRunAttributes(int charOffset, int *startChar, int *endChar) {
 	g_return_val_if_fail(charOffset >= -1, NULL);
 
-	Position byteOffset;
+	Sci::Position byteOffset;
 	if (charOffset == -1) {
 		byteOffset = sci->WndProc(SCI_GETCURRENTPOS, 0, 0);
 	} else {
@@ -562,11 +562,11 @@
 
 	const char style = StyleAt(byteOffset, true);
 	// compute the range for this style
-	Position startByte = byteOffset;
+	Sci::Position startByte = byteOffset;
 	// when going backwards, we know the style is already computed
 	while (startByte > 0 && sci->pdoc->StyleAt((startByte) - 1) == style)
 		(startByte)--;
-	Position endByte = byteOffset + 1;
+	Sci::Position endByte = byteOffset + 1;
 	while (endByte < length && StyleAt(endByte, true) == style)
 		(endByte)++;
 
@@ -586,8 +586,8 @@
 	if (selection_num < 0 || (unsigned int) selection_num >= sci->sel.Count())
 		return NULL;
 
-	Position startByte = sci->sel.Range(selection_num).Start().Position();
-	Position endByte = sci->sel.Range(selection_num).End().Position();
+	Sci::Position startByte = sci->sel.Range(selection_num).Start().Position();
+	Sci::Position endByte = sci->sel.Range(selection_num).End().Position();
 
 	CharacterRangeFromByteRange(startByte, endByte, startChar, endChar);
 	return GetTextRangeUTF8(startByte, endByte);
@@ -595,7 +595,7 @@
 
 gboolean ScintillaGTKAccessible::AddSelection(int startChar, int endChar) {
 	size_t n_selections = sci->sel.Count();
-	Position startByte, endByte;
+	Sci::Position startByte, endByte;
 	ByteRangeFromCharacterRange(startChar, endChar, startByte, endByte);
 	// use WndProc() to set the selections so it notifies as needed
 	if (n_selections > 1 || ! sci->sel.Empty()) {
@@ -627,7 +627,7 @@
 	if (selection_num < 0 || (unsigned int) selection_num >= sci->sel.Count())
 		return FALSE;
 
-	Position startByte, endByte;
+	Sci::Position startByte, endByte;
 	ByteRangeFromCharacterRange(startChar, endChar, startByte, endByte);
 
 	sci->WndProc(SCI_SETSELECTIONNSTART, selection_num, startByte);
@@ -668,7 +668,7 @@
 	}
 }
 
-bool ScintillaGTKAccessible::InsertStringUTF8(Position bytePos, const gchar *utf8, int lengthBytes) {
+bool ScintillaGTKAccessible::InsertStringUTF8(Sci::Position bytePos, const gchar *utf8, Sci::Position lengthBytes) {
 	if (sci->pdoc->IsReadOnly()) {
 		return false;
 	}
@@ -688,7 +688,7 @@
 }
 
 void ScintillaGTKAccessible::InsertText(const gchar *text, int lengthBytes, int *charPosition) {
-	Position bytePosition = ByteOffsetFromCharacterOffset(*charPosition);
+	Sci::Position bytePosition = ByteOffsetFromCharacterOffset(*charPosition);
 
 	// FIXME: should we update the target?
 	if (InsertStringUTF8(bytePosition, text, lengthBytes)) {
@@ -697,7 +697,7 @@
 }
 
 void ScintillaGTKAccessible::CopyText(int startChar, int endChar) {
-	Position startByte, endByte;
+	Sci::Position startByte, endByte;
 	ByteRangeFromCharacterRange(startChar, endChar, startByte, endByte);
 	sci->CopyRangeToClipboard(startByte, endByte);
 }
@@ -716,7 +716,7 @@
 	g_return_if_fail(endChar >= startChar);
 
 	if (! sci->pdoc->IsReadOnly()) {
-		Position startByte, endByte;
+		Sci::Position startByte, endByte;
 		ByteRangeFromCharacterRange(startChar, endChar, startByte, endByte);
 
 		if (! sci->RangeContainsProtected(startByte, endByte)) {
@@ -735,13 +735,13 @@
 	// has always done that without problems, so let's guess it's a fairly safe bet.
 	struct Helper : GObjectWatcher {
 		ScintillaGTKAccessible *scia;
-		Position bytePosition;
+		Sci::Position bytePosition;
 
 		virtual void Destroyed() {
 			scia = 0;
 		}
 
-		Helper(ScintillaGTKAccessible *scia_, Position bytePos_) :
+		Helper(ScintillaGTKAccessible *scia_, Sci::Position bytePos_) :
 			GObjectWatcher(G_OBJECT(scia_->sci->sci)),
 			scia(scia_),
 			bytePosition(bytePos_) {
@@ -757,7 +757,7 @@
 					len = convertedText.length();
 					text = convertedText.c_str();
 				}
-				scia->InsertStringUTF8(bytePosition, text, static_cast<int>(len));
+				scia->InsertStringUTF8(bytePosition, text, static_cast<Sci::Position>(len));
 			}
 		}
 
@@ -795,7 +795,7 @@
 // Callbacks
 
 void ScintillaGTKAccessible::UpdateCursor() {
-	Position pos = sci->WndProc(SCI_GETCURRENTPOS, 0, 0);
+	Sci::Position pos = sci->WndProc(SCI_GETCURRENTPOS, 0, 0);
 	if (old_pos != pos) {
 		int charPosition = CharacterOffsetFromByteOffset(pos);
 		g_signal_emit_by_name(accessible, "text-caret-moved", charPosition);
@@ -875,7 +875,7 @@
 		case SCN_MODIFIED: {
 			if (nt->modificationType & (SC_MOD_INSERTTEXT | SC_MOD_DELETETEXT)) {
 				// invalidate character offset cache if applicable
-				const Position line = sci->pdoc->LineFromPosition(nt->position);
+				const Sci::Line line = sci->pdoc->LineFromPosition(nt->position);
 				if (character_offsets.size() > static_cast<size_t>(line + 1)) {
 					character_offsets.resize(line + 1);
 				}
diff -r 1788f6795302 -r a0f26eaf474d gtk/ScintillaGTKAccessible.h
--- a/gtk/ScintillaGTKAccessible.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/gtk/ScintillaGTKAccessible.h	Fri Mar 31 18:19:38 2017 +1100
@@ -21,12 +21,12 @@
 	ScintillaGTK *sci;
 
 	// cache holding character offset for each line start, see CharacterOffsetFromByteOffset()
-	std::vector<Position> character_offsets;
+	std::vector<Sci::Position> character_offsets;
 
 	// cached length of the deletion, in characters (see Notify())
 	int deletionLengthChar;
 	// local state for comparing
-	Position old_pos;
+	Sci::Position old_pos;
 	std::vector<SelectionRange> old_sels;
 
 	bool Enabled() const;
@@ -38,8 +38,8 @@
 		} catch (...) {}
 	}
 
-	Position ByteOffsetFromCharacterOffset(Position startByte, int characterOffset) {
-		Position pos = sci->pdoc->GetRelativePosition(startByte, characterOffset);
+	Sci::Position ByteOffsetFromCharacterOffset(Sci::Position startByte, int characterOffset) {
+		Sci::Position pos = sci->pdoc->GetRelativePosition(startByte, characterOffset);
 		if (pos == INVALID_POSITION) {
 			// clamp invalid positions inside the document
 			if (characterOffset > 0) {
@@ -51,51 +51,51 @@
 		return pos;
 	}
 
-	Position ByteOffsetFromCharacterOffset(int characterOffset) {
+	Sci::Position ByteOffsetFromCharacterOffset(Sci::Position characterOffset) {
 		return ByteOffsetFromCharacterOffset(0, characterOffset);
 	}
 
-	int CharacterOffsetFromByteOffset(Position byteOffset) {
-		const Position line = sci->pdoc->LineFromPosition(byteOffset);
+	Sci::Position CharacterOffsetFromByteOffset(Sci::Position byteOffset) {
+		const Sci::Line line = sci->pdoc->LineFromPosition(byteOffset);
 		if (character_offsets.size() <= static_cast<size_t>(line)) {
 			if (character_offsets.empty())
 				character_offsets.push_back(0);
-			for (Position i = character_offsets.size(); i <= line; i++) {
-				const Position start = sci->pdoc->LineStart(i - 1);
-				const Position end = sci->pdoc->LineStart(i);
+			for (Sci::Position i = character_offsets.size(); i <= line; i++) {
+				const Sci::Position start = sci->pdoc->LineStart(i - 1);
+				const Sci::Position end = sci->pdoc->LineStart(i);
 				character_offsets.push_back(character_offsets[i - 1] + sci->pdoc->CountCharacters(start, end));
 			}
 		}
-		const Position lineStart = sci->pdoc->LineStart(line);
+		const Sci::Position lineStart = sci->pdoc->LineStart(line);
 		return character_offsets[line] + sci->pdoc->CountCharacters(lineStart, byteOffset);
 	}
 
-	void CharacterRangeFromByteRange(Position startByte, Position endByte, int *startChar, int *endChar) {
+	void CharacterRangeFromByteRange(Sci::Position startByte, Sci::Position endByte, int *startChar, int *endChar) {
 		*startChar = CharacterOffsetFromByteOffset(startByte);
 		*endChar = *startChar + sci->pdoc->CountCharacters(startByte, endByte);
 	}
 
-	void ByteRangeFromCharacterRange(int startChar, int endChar, Position& startByte, Position& endByte) {
+	void ByteRangeFromCharacterRange(int startChar, int endChar, Sci::Position& startByte, Sci::Position& endByte) {
 		startByte = ByteOffsetFromCharacterOffset(startChar);
 		endByte = ByteOffsetFromCharacterOffset(startByte, endChar - startChar);
 	}
 
-	Position PositionBefore(Position pos) {
+	Sci::Position PositionBefore(Sci::Position pos) {
 		return sci->pdoc->MovePositionOutsideChar(pos - 1, -1, true);
 	}
 
-	Position PositionAfter(Position pos) {
+	Sci::Position PositionAfter(Sci::Position pos) {
 		return sci->pdoc->MovePositionOutsideChar(pos + 1, 1, true);
 	}
 
-	int StyleAt(Position position, bool ensureStyle = false) {
+	int StyleAt(Sci::Position position, bool ensureStyle = false) {
 		if (ensureStyle)
 			sci->pdoc->EnsureStyledTo(position);
 		return sci->pdoc->StyleAt(position);
 	}
 
 	// For AtkText
-	gchar *GetTextRangeUTF8(Position startByte, Position endByte);
+	gchar *GetTextRangeUTF8(Sci::Position startByte, Sci::Position endByte);
 	gchar *GetText(int startChar, int endChar);
 	gchar *GetTextAfterOffset(int charOffset, AtkTextBoundary boundaryType, int *startChar, int *endChar);
 	gchar *GetTextBeforeOffset(int charOffset, AtkTextBoundary boundaryType, int *startChar, int *endChar);
@@ -118,7 +118,7 @@
 	gboolean RemoveSelection(int selection_num);
 	gboolean SetSelection(gint selection_num, int startChar, int endChar);
 	// for AtkEditableText
-	bool InsertStringUTF8(Position bytePos, const gchar *utf8, int lengthBytes);
+	bool InsertStringUTF8(Sci::Position bytePos, const gchar *utf8, Sci::Position lengthBytes);
 	void SetTextContents(const gchar *contents);
 	void InsertText(const gchar *contents, int lengthBytes, int *charPosition);
 	void CopyText(int startChar, int endChar);
diff -r 1788f6795302 -r a0f26eaf474d qt/ScintillaEdit/ScintillaDocument.cpp
--- a/qt/ScintillaEdit/ScintillaDocument.cpp	Thu Mar 30 09:11:48 2017 +1100
+++ b/qt/ScintillaEdit/ScintillaDocument.cpp	Fri Mar 31 18:19:38 2017 +1100
@@ -45,7 +45,7 @@
 	void NotifySavePoint(Document *doc, void *userData, bool atSavePoint);
 	void NotifyModified(Document *doc, DocModification mh, void *userData);
 	void NotifyDeleted(Document *doc, void *userData);
-	void NotifyStyleNeeded(Document *doc, void *userData, int endPos);
+	void NotifyStyleNeeded(Document *doc, void *userData, Sci::Position endPos);
 	void NotifyLexerChanged(Document *doc, void *userData);
 	void NotifyErrorOccurred(Document *doc, void *userData, int status);
 };
@@ -76,7 +76,7 @@
 void WatcherHelper::NotifyDeleted(Document *, void *) {
 }
 
-void WatcherHelper::NotifyStyleNeeded(Document *, void *, int endPos) {
+void WatcherHelper::NotifyStyleNeeded(Document *, void *, Sci::Position endPos) {
 	owner->emit_style_needed(endPos);
 }
 
diff -r 1788f6795302 -r a0f26eaf474d qt/ScintillaEditBase/ScintillaQt.cpp
--- a/qt/ScintillaEditBase/ScintillaQt.cpp	Thu Mar 30 09:11:48 2017 +1100
+++ b/qt/ScintillaEditBase/ScintillaQt.cpp	Fri Mar 31 18:19:38 2017 +1100
@@ -239,7 +239,7 @@
 }
 
 
-void ScintillaQt::ScrollText(int linesToMove)
+void ScintillaQt::ScrollText(Sci::Line linesToMove)
 {
 	int dy = vs.lineHeight * (linesToMove);
 	scrollArea->viewport()->scroll(0, dy);
@@ -257,7 +257,7 @@
 	emit horizontalScrolled(xOffset);
 }
 
-bool ScintillaQt::ModifyScrollBars(int nMax, int nPage)
+bool ScintillaQt::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
 {
 	bool modified = false;
 
@@ -613,7 +613,7 @@
 		}
 	}
 	inDragDrop = ddNone;
-	SetDragPosition(SelectionPosition(invalidPosition));
+	SetDragPosition(SelectionPosition(Sci::invalidPosition));
 }
 
 void ScintillaQt::CreateCallTipWindow(PRectangle rc)
@@ -740,7 +740,7 @@
 
 void ScintillaQt::DragLeave()
 {
-	SetDragPosition(SelectionPosition(invalidPosition));
+	SetDragPosition(SelectionPosition(Sci::invalidPosition));
 }
 
 void ScintillaQt::Drop(const Point &point, const QMimeData *data, bool move)
diff -r 1788f6795302 -r a0f26eaf474d qt/ScintillaEditBase/ScintillaQt.h
--- a/qt/ScintillaEditBase/ScintillaQt.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/qt/ScintillaEditBase/ScintillaQt.h	Fri Mar 31 18:19:38 2017 +1100
@@ -107,7 +107,7 @@
 	virtual void ScrollText(int linesToMove);
 	virtual void SetVerticalScrollPos();
 	virtual void SetHorizontalScrollPos();
-	virtual bool ModifyScrollBars(int nMax, int nPage);
+	virtual bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage);
 	virtual void ReconfigureScrollBars();
 	void CopyToModeClipboard(const SelectionText &selectedText, QClipboard::Mode clipboardMode_);
 	virtual void Copy();
diff -r 1788f6795302 -r a0f26eaf474d src/AutoComplete.cxx
--- a/src/AutoComplete.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/AutoComplete.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -58,7 +58,7 @@
 }
 
 void AutoComplete::Start(Window &parent, int ctrlID,
-	int position, Point location, int startLen_,
+	Sci::Position position, Point location, int startLen_,
 	int lineHeight, bool unicodeMode, int technology) {
 	if (active) {
 		Cancel();
diff -r 1788f6795302 -r a0f26eaf474d src/AutoComplete.h
--- a/src/AutoComplete.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/AutoComplete.h	Fri Mar 31 18:19:38 2017 +1100
@@ -28,7 +28,7 @@
 	bool ignoreCase;
 	bool chooseSingle;
 	ListBox *lb;
-	int posStart;
+	Sci::Position posStart;
 	int startLen;
 	/// Should autocompletion be canceled if editor's currentPos <= startPos?
 	bool cancelAtStartPos;
@@ -50,7 +50,7 @@
 	bool Active() const;
 
 	/// Display the auto completion list positioned to be near a character position
-	void Start(Window &parent, int ctrlID, int position, Point location,
+	void Start(Window &parent, int ctrlID, Sci::Position position, Point location,
 		int startLen_, int lineHeight, bool unicodeMode, int technology);
 
 	/// The stop chars are characters which, when typed, cause the auto completion list to disappear
diff -r 1788f6795302 -r a0f26eaf474d src/CallTip.cxx
--- a/src/CallTip.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/CallTip.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -250,7 +250,7 @@
 		clickPlace = 2;
 }
 
-PRectangle CallTip::CallTipStart(int pos, Point pt, int textHeight, const char *defn,
+PRectangle CallTip::CallTipStart(Sci::Position pos, Point pt, int textHeight, const char *defn,
                                  const char *faceName, int size,
                                  int codePage_, int characterSet,
 								 int technology, Window &wParent) {
diff -r 1788f6795302 -r a0f26eaf474d src/CallTip.h
--- a/src/CallTip.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/CallTip.h	Fri Mar 31 18:19:38 2017 +1100
@@ -41,7 +41,7 @@
 	Window wCallTip;
 	Window wDraw;
 	bool inCallTipMode;
-	int posStartCallTip;
+	Sci::Position posStartCallTip;
 	ColourDesired colourBG;
 	ColourDesired colourUnSel;
 	ColourDesired colourSel;
@@ -63,7 +63,7 @@
 	void MouseClick(Point pt);
 
 	/// Setup the calltip and return a rectangle of the area required.
-	PRectangle CallTipStart(int pos, Point pt, int textHeight, const char *defn,
+	PRectangle CallTipStart(Sci::Position pos, Point pt, int textHeight, const char *defn,
 		const char *faceName, int size, int codePage_,
 		int characterSet, int technology, Window &wParent);
 
diff -r 1788f6795302 -r a0f26eaf474d src/CellBuffer.cxx
--- a/src/CellBuffer.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/CellBuffer.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -45,11 +45,11 @@
 	perLine = pl;
 }
 
-void LineVector::InsertText(int line, int delta) {
+void LineVector::InsertText(Sci::Line line, Sci::Position delta) {
 	starts.InsertText(line, delta);
 }
 
-void LineVector::InsertLine(int line, int position, bool lineStart) {
+void LineVector::InsertLine(Sci::Line line, Sci::Position position, bool lineStart) {
 	starts.InsertPartition(line, position);
 	if (perLine) {
 		if ((line > 0) && lineStart)
@@ -58,18 +58,18 @@
 	}
 }
 
-void LineVector::SetLineStart(int line, int position) {
+void LineVector::SetLineStart(Sci::Line line, Sci::Position position) {
 	starts.SetPartitionStartPosition(line, position);
 }
 
-void LineVector::RemoveLine(int line) {
+void LineVector::RemoveLine(Sci::Line line) {
 	starts.RemovePartition(line);
 	if (perLine) {
 		perLine->RemoveLine(line);
 	}
 }
 
-int LineVector::LineFromPosition(int pos) const {
+Sci::Line LineVector::LineFromPosition(Sci::Position pos) const {
 	return starts.PartitionFromPosition(pos);
 }
 
@@ -85,7 +85,7 @@
 	Destroy();
 }
 
-void Action::Create(actionType at_, int position_, const char *data_, int lenData_, bool mayCoalesce_) {
+void Action::Create(actionType at_, Sci::Position position_, const char *data_, Sci::Position lenData_, bool mayCoalesce_) {
 	delete []data;
 	data = NULL;
 	position = position_;
@@ -171,7 +171,7 @@
 	}
 }
 
-const char *UndoHistory::AppendAction(actionType at, int position, const char *data, int lengthData,
+const char *UndoHistory::AppendAction(actionType at, Sci::Position position, const char *data, Sci::Position lengthData,
 	bool &startSequence, bool mayCoalesce) {
 	EnsureUndoRoom();
 	//Platform::DebugPrintf("%% %d action %d %d %d\n", at, position, lengthData, currentAction);
@@ -375,11 +375,11 @@
 CellBuffer::~CellBuffer() {
 }
 
-char CellBuffer::CharAt(int position) const {
+char CellBuffer::CharAt(Sci::Position position) const {
 	return substance.ValueAt(position);
 }
 
-void CellBuffer::GetCharRange(char *buffer, int position, int lengthRetrieve) const {
+void CellBuffer::GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
 	if (lengthRetrieve <= 0)
 		return;
 	if (position < 0)
@@ -392,11 +392,11 @@
 	substance.GetRange(buffer, position, lengthRetrieve);
 }
 
-char CellBuffer::StyleAt(int position) const {
+char CellBuffer::StyleAt(Sci::Position position) const {
 	return style.ValueAt(position);
 }
 
-void CellBuffer::GetStyleRange(unsigned char *buffer, int position, int lengthRetrieve) const {
+void CellBuffer::GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
 	if (lengthRetrieve < 0)
 		return;
 	if (position < 0)
@@ -413,16 +413,16 @@
 	return substance.BufferPointer();
 }
 
-const char *CellBuffer::RangePointer(int position, int rangeLength) {
+const char *CellBuffer::RangePointer(Sci::Position position, Sci::Position rangeLength) {
 	return substance.RangePointer(position, rangeLength);
 }
 
-int CellBuffer::GapPosition() const {
+Sci::Position CellBuffer::GapPosition() const {
 	return substance.GapPosition();
 }
 
 // The char* returned is to an allocation owned by the undo history
-const char *CellBuffer::InsertString(int position, const char *s, int insertLength, bool &startSequence) {
+const char *CellBuffer::InsertString(Sci::Position position, const char *s, Sci::Position insertLength, bool &startSequence) {
 	// InsertString and DeleteChars are the bottleneck though which all changes occur
 	const char *data = s;
 	if (!readOnly) {
@@ -437,7 +437,7 @@
 	return data;
 }
 
-bool CellBuffer::SetStyleAt(int position, char styleValue) {
+bool CellBuffer::SetStyleAt(Sci::Position position, char styleValue) {
 	char curVal = style.ValueAt(position);
 	if (curVal != styleValue) {
 		style.SetValueAt(position, styleValue);
@@ -447,7 +447,7 @@
 	}
 }
 
-bool CellBuffer::SetStyleFor(int position, int lengthStyle, char styleValue) {
+bool CellBuffer::SetStyleFor(Sci::Position position, Sci::Position lengthStyle, char styleValue) {
 	bool changed = false;
 	PLATFORM_ASSERT(lengthStyle == 0 ||
 		(lengthStyle > 0 && lengthStyle + position <= style.Length()));
@@ -463,7 +463,7 @@
 }
 
 // The char* returned is to an allocation owned by the undo history
-const char *CellBuffer::DeleteChars(int position, int deleteLength, bool &startSequence) {
+const char *CellBuffer::DeleteChars(Sci::Position position, Sci::Position deleteLength, bool &startSequence) {
 	// InsertString and DeleteChars are the bottleneck though which all changes occur
 	PLATFORM_ASSERT(deleteLength > 0);
 	const char *data = 0;
@@ -480,11 +480,11 @@
 	return data;
 }
 
-int CellBuffer::Length() const {
+Sci::Position CellBuffer::Length() const {
 	return substance.Length();
 }
 
-void CellBuffer::Allocate(int newSize) {
+void CellBuffer::Allocate(Sci::Position newSize) {
 	substance.ReAllocate(newSize);
 	style.ReAllocate(newSize);
 }
@@ -496,10 +496,10 @@
 	}
 }
 
-bool CellBuffer::ContainsLineEnd(const char *s, int length) const {
+bool CellBuffer::ContainsLineEnd(const char *s, Sci::Position length) const {
 	unsigned char chBeforePrev = 0;
 	unsigned char chPrev = 0;
-	for (int i = 0; i < length; i++) {
+	for (Sci::Position i = 0; i < length; i++) {
 		const unsigned char ch = s[i];
 		if ((ch == '\r') || (ch == '\n')) {
 			return true;
@@ -519,11 +519,11 @@
 	lv.SetPerLine(pl);
 }
 
-int CellBuffer::Lines() const {
+Sci::Line CellBuffer::Lines() const {
 	return lv.Lines();
 }
 
-int CellBuffer::LineStart(int line) const {
+Sci::Position CellBuffer::LineStart(Sci::Line line) const {
 	if (line < 0)
 		return 0;
 	else if (line >= Lines())
@@ -566,15 +566,15 @@
 
 // Without undo
 
-void CellBuffer::InsertLine(int line, int position, bool lineStart) {
+void CellBuffer::InsertLine(Sci::Line line, Sci::Position position, bool lineStart) {
 	lv.InsertLine(line, position, lineStart);
 }
 
-void CellBuffer::RemoveLine(int line) {
+void CellBuffer::RemoveLine(Sci::Line line) {
 	lv.RemoveLine(line);
 }
 
-bool CellBuffer::UTF8LineEndOverlaps(int position) const {
+bool CellBuffer::UTF8LineEndOverlaps(Sci::Position position) const {
 	unsigned char bytes[] = {
 		static_cast<unsigned char>(substance.ValueAt(position-2)),
 		static_cast<unsigned char>(substance.ValueAt(position-1)),
@@ -588,14 +588,14 @@
 	// Reinitialize line data -- too much work to preserve
 	lv.Init();
 
-	int position = 0;
-	int length = Length();
-	int lineInsert = 1;
+	Sci::Position position = 0;
+	Sci::Position length = Length();
+	Sci::Line lineInsert = 1;
 	bool atLineStart = true;
 	lv.InsertText(lineInsert-1, length);
 	unsigned char chBeforePrev = 0;
 	unsigned char chPrev = 0;
-	for (int i = 0; i < length; i++) {
+	for (Sci::Position i = 0; i < length; i++) {
 		unsigned char ch = substance.ValueAt(position + i);
 		if (ch == '\r') {
 			InsertLine(lineInsert, (position + i) + 1, atLineStart);
@@ -620,7 +620,7 @@
 	}
 }
 
-void CellBuffer::BasicInsertString(int position, const char *s, int insertLength) {
+void CellBuffer::BasicInsertString(Sci::Position position, const char *s, Sci::Position insertLength) {
 	if (insertLength == 0)
 		return;
 	PLATFORM_ASSERT(insertLength > 0);
@@ -634,7 +634,7 @@
 	substance.InsertFromArray(position, s, 0, insertLength);
 	style.InsertValue(position, insertLength, 0);
 
-	int lineInsert = lv.LineFromPosition(position) + 1;
+	Sci::Line lineInsert = lv.LineFromPosition(position) + 1;
 	bool atLineStart = lv.LineStart(lineInsert-1) == position;
 	// Point all the lines after the insertion point further along in the buffer
 	lv.InsertText(lineInsert-1, insertLength);
@@ -649,7 +649,7 @@
 		RemoveLine(lineInsert);
 	}
 	unsigned char ch = ' ';
-	for (int i = 0; i < insertLength; i++) {
+	for (Sci::Position i = 0; i < insertLength; i++) {
 		ch = s[i];
 		if (ch == '\r') {
 			InsertLine(lineInsert, (position + i) + 1, atLineStart);
@@ -697,7 +697,7 @@
 	}
 }
 
-void CellBuffer::BasicDeleteChars(int position, int deleteLength) {
+void CellBuffer::BasicDeleteChars(Sci::Position position, Sci::Position deleteLength) {
 	if (deleteLength == 0)
 		return;
 
@@ -709,7 +709,7 @@
 		// Have to fix up line positions before doing deletion as looking at text in buffer
 		// to work out which lines have been removed
 
-		int lineRemove = lv.LineFromPosition(position) + 1;
+		Sci::Line lineRemove = lv.LineFromPosition(position) + 1;
 		lv.InsertText(lineRemove-1, - (deleteLength));
 		unsigned char chPrev = substance.ValueAt(position - 1);
 		unsigned char chBefore = chPrev;
@@ -728,7 +728,7 @@
 		}
 
 		unsigned char ch = chNext;
-		for (int i = 0; i < deleteLength; i++) {
+		for (Sci::Position i = 0; i < deleteLength; i++) {
 			chNext = substance.ValueAt(position + i + 1);
 			if (ch == '\r') {
 				if (chNext != '\n') {
@@ -783,7 +783,7 @@
 	uh.EndUndoAction();
 }
 
-void CellBuffer::AddUndoAction(int token, bool mayCoalesce) {
+void CellBuffer::AddUndoAction(Sci::Position token, bool mayCoalesce) {
 	bool startSequence;
 	uh.AppendAction(containerAction, token, 0, 0, startSequence, mayCoalesce);
 }
diff -r 1788f6795302 -r a0f26eaf474d src/CellBuffer.h
--- a/src/CellBuffer.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/CellBuffer.h	Fri Mar 31 18:19:38 2017 +1100
@@ -17,8 +17,8 @@
 public:
 	virtual ~PerLine() {}
 	virtual void Init()=0;
-	virtual void InsertLine(int line)=0;
-	virtual void RemoveLine(int line)=0;
+	virtual void InsertLine(Sci::Line line)=0;
+	virtual void RemoveLine(Sci::Line line)=0;
 };
 
 /**
@@ -36,15 +36,15 @@
 	void Init();
 	void SetPerLine(PerLine *pl);
 
-	void InsertText(int line, int delta);
-	void InsertLine(int line, int position, bool lineStart);
-	void SetLineStart(int line, int position);
-	void RemoveLine(int line);
-	int Lines() const {
+	void InsertText(Sci::Line line, Sci::Position delta);
+	void InsertLine(Sci::Line line, Sci::Position position, bool lineStart);
+	void SetLineStart(Sci::Line line, Sci::Position position);
+	void RemoveLine(Sci::Line line);
+	Sci::Line Lines() const {
 		return starts.Partitions();
 	}
-	int LineFromPosition(int pos) const;
-	int LineStart(int line) const {
+	Sci::Line LineFromPosition(Sci::Position pos) const;
+	Sci::Position LineStart(Sci::Line line) const {
 		return starts.PositionFromPartition(line);
 	}
 };
@@ -57,14 +57,14 @@
 class Action {
 public:
 	actionType at;
-	int position;
+	Sci::Position position;
 	char *data;
-	int lenData;
+	Sci::Position lenData;
 	bool mayCoalesce;
 
 	Action();
 	~Action();
-	void Create(actionType at_, int position_=0, const char *data_=0, int lenData_=0, bool mayCoalesce_=true);
+	void Create(actionType at_, Sci::Position position_=0, const char *data_=0, Sci::Position lenData_=0, bool mayCoalesce_=true);
 	void Destroy();
 	void Grab(Action *source);
 };
@@ -90,7 +90,7 @@
 	UndoHistory();
 	~UndoHistory();
 
-	const char *AppendAction(actionType at, int position, const char *data, int length, bool &startSequence, bool mayCoalesce=true);
+	const char *AppendAction(actionType at, Sci::Position position, const char *data, Sci::Position length, bool &startSequence, bool mayCoalesce=true);
 
 	void BeginUndoAction();
 	void EndUndoAction();
@@ -137,11 +137,11 @@
 
 	LineVector lv;
 
-	bool UTF8LineEndOverlaps(int position) const;
+	bool UTF8LineEndOverlaps(Sci::Position position) const;
 	void ResetLineEnds();
 	/// Actions without undo
-	void BasicInsertString(int position, const char *s, int insertLength);
-	void BasicDeleteChars(int position, int deleteLength);
+	void BasicInsertString(Sci::Position position, const char *s, Sci::Position insertLength);
+	void BasicDeleteChars(Sci::Position position, Sci::Position deleteLength);
 
 public:
 
@@ -149,33 +149,33 @@
 	~CellBuffer();
 
 	/// Retrieving positions outside the range of the buffer works and returns 0
-	char CharAt(int position) const;
-	void GetCharRange(char *buffer, int position, int lengthRetrieve) const;
-	char StyleAt(int position) const;
-	void GetStyleRange(unsigned char *buffer, int position, int lengthRetrieve) const;
+	char CharAt(Sci::Position position) const;
+	void GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const;
+	char StyleAt(Sci::Position position) const;
+	void GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const;
 	const char *BufferPointer();
-	const char *RangePointer(int position, int rangeLength);
-	int GapPosition() const;
+	const char *RangePointer(Sci::Position position, Sci::Position rangeLength);
+	Sci::Position GapPosition() const;
 
-	int Length() const;
-	void Allocate(int newSize);
+	Sci::Position Length() const;
+	void Allocate(Sci::Position newSize);
 	int GetLineEndTypes() const { return utf8LineEnds; }
 	void SetLineEndTypes(int utf8LineEnds_);
-	bool ContainsLineEnd(const char *s, int length) const;
+	bool ContainsLineEnd(const char *s, Sci::Position length) const;
 	void SetPerLine(PerLine *pl);
-	int Lines() const;
-	int LineStart(int line) const;
-	int LineFromPosition(int pos) const { return lv.LineFromPosition(pos); }
-	void InsertLine(int line, int position, bool lineStart);
-	void RemoveLine(int line);
-	const char *InsertString(int position, const char *s, int insertLength, bool &startSequence);
+	Sci::Line Lines() const;
+	Sci::Position LineStart(Sci::Line line) const;
+	Sci::Line LineFromPosition(Sci::Position pos) const { return lv.LineFromPosition(pos); }
+	void InsertLine(Sci::Line line, Sci::Position position, bool lineStart);
+	void RemoveLine(Sci::Line line);
+	const char *InsertString(Sci::Position position, const char *s, Sci::Position insertLength, bool &startSequence);
 
 	/// Setting styles for positions outside the range of the buffer is safe and has no effect.
 	/// @return true if the style of a character is changed.
-	bool SetStyleAt(int position, char styleValue);
-	bool SetStyleFor(int position, int length, char styleValue);
+	bool SetStyleAt(Sci::Position position, char styleValue);
+	bool SetStyleFor(Sci::Position position, Sci::Position length, char styleValue);
 
-	const char *DeleteChars(int position, int deleteLength, bool &startSequence);
+	const char *DeleteChars(Sci::Position position, Sci::Position deleteLength, bool &startSequence);
 
 	bool IsReadOnly() const;
 	void SetReadOnly(bool set);
@@ -194,7 +194,7 @@
 	bool IsCollectingUndo() const;
 	void BeginUndoAction();
 	void EndUndoAction();
-	void AddUndoAction(int token, bool mayCoalesce);
+	void AddUndoAction(Sci::Position token, bool mayCoalesce);
 	void DeleteUndoHistory();
 
 	/// To perform an undo, StartUndo is called to retrieve the number of steps, then UndoStep is
diff -r 1788f6795302 -r a0f26eaf474d src/ContractionState.cxx
--- a/src/ContractionState.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/ContractionState.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -57,7 +57,7 @@
 	linesInDocument = 1;
 }
 
-int ContractionState::LinesInDoc() const {
+Sci::Line ContractionState::LinesInDoc() const {
 	if (OneToOne()) {
 		return linesInDocument;
 	} else {
@@ -65,7 +65,7 @@
 	}
 }
 
-int ContractionState::LinesDisplayed() const {
+Sci::Line ContractionState::LinesDisplayed() const {
 	if (OneToOne()) {
 		return linesInDocument;
 	} else {
@@ -73,7 +73,7 @@
 	}
 }
 
-int ContractionState::DisplayFromDoc(int lineDoc) const {
+Sci::Line ContractionState::DisplayFromDoc(Sci::Line lineDoc) const {
 	if (OneToOne()) {
 		return (lineDoc <= linesInDocument) ? lineDoc : linesInDocument;
 	} else {
@@ -83,11 +83,11 @@
 	}
 }
 
-int ContractionState::DisplayLastFromDoc(int lineDoc) const {
+Sci::Line ContractionState::DisplayLastFromDoc(Sci::Line lineDoc) const {
 	return DisplayFromDoc(lineDoc) + GetHeight(lineDoc) - 1;
 }
 
-int ContractionState::DocFromDisplay(int lineDisplay) const {
+Sci::Line ContractionState::DocFromDisplay(Sci::Line lineDisplay) const {
 	if (OneToOne()) {
 		return lineDisplay;
 	} else {
@@ -97,13 +97,13 @@
 		if (lineDisplay > LinesDisplayed()) {
 			return displayLines->PartitionFromPosition(LinesDisplayed());
 		}
-		int lineDoc = displayLines->PartitionFromPosition(lineDisplay);
+		Sci::Line lineDoc = displayLines->PartitionFromPosition(lineDisplay);
 		PLATFORM_ASSERT(GetVisible(lineDoc));
 		return lineDoc;
 	}
 }
 
-void ContractionState::InsertLine(int lineDoc) {
+void ContractionState::InsertLine(Sci::Line lineDoc) {
 	if (OneToOne()) {
 		linesInDocument++;
 	} else {
@@ -115,20 +115,20 @@
 		heights->SetValueAt(lineDoc, 1);
 		foldDisplayTexts->InsertSpace(lineDoc, 1);
 		foldDisplayTexts->SetValueAt(lineDoc, NULL);
-		int lineDisplay = DisplayFromDoc(lineDoc);
+		Sci::Line lineDisplay = DisplayFromDoc(lineDoc);
 		displayLines->InsertPartition(lineDoc, lineDisplay);
 		displayLines->InsertText(lineDoc, 1);
 	}
 }
 
-void ContractionState::InsertLines(int lineDoc, int lineCount) {
+void ContractionState::InsertLines(Sci::Line lineDoc, Sci::Line lineCount) {
 	for (int l = 0; l < lineCount; l++) {
 		InsertLine(lineDoc + l);
 	}
 	Check();
 }
 
-void ContractionState::DeleteLine(int lineDoc) {
+void ContractionState::DeleteLine(Sci::Line lineDoc) {
 	if (OneToOne()) {
 		linesInDocument--;
 	} else {
@@ -143,14 +143,14 @@
 	}
 }
 
-void ContractionState::DeleteLines(int lineDoc, int lineCount) {
-	for (int l = 0; l < lineCount; l++) {
+void ContractionState::DeleteLines(Sci::Line lineDoc, Sci::Line lineCount) {
+	for (Sci::Line l = 0; l < lineCount; l++) {
 		DeleteLine(lineDoc);
 	}
 	Check();
 }
 
-bool ContractionState::GetVisible(int lineDoc) const {
+bool ContractionState::GetVisible(Sci::Line lineDoc) const {
 	if (OneToOne()) {
 		return true;
 	} else {
@@ -160,15 +160,15 @@
 	}
 }
 
-bool ContractionState::SetVisible(int lineDocStart, int lineDocEnd, bool isVisible) {
+bool ContractionState::SetVisible(Sci::Line lineDocStart, Sci::Line lineDocEnd, bool isVisible) {
 	if (OneToOne() && isVisible) {
 		return false;
 	} else {
 		EnsureData();
-		int delta = 0;
+		Sci::Line delta = 0;
 		Check();
 		if ((lineDocStart <= lineDocEnd) && (lineDocStart >= 0) && (lineDocEnd < LinesInDoc())) {
-			for (int line = lineDocStart; line <= lineDocEnd; line++) {
+			for (Sci::Line line = lineDocStart; line <= lineDocEnd; line++) {
 				if (GetVisible(line) != isVisible) {
 					int difference = isVisible ? heights->ValueAt(line) : -heights->ValueAt(line);
 					visible->SetValueAt(line, isVisible ? 1 : 0);
@@ -192,12 +192,12 @@
 	}
 }
 
-const char *ContractionState::GetFoldDisplayText(int lineDoc) const {
+const char *ContractionState::GetFoldDisplayText(Sci::Line lineDoc) const {
 	Check();
 	return foldDisplayTexts->ValueAt(lineDoc);
 }
 
-bool ContractionState::SetFoldDisplayText(int lineDoc, const char *text) {
+bool ContractionState::SetFoldDisplayText(Sci::Line lineDoc, const char *text) {
 	EnsureData();
 	const char *foldText = foldDisplayTexts->ValueAt(lineDoc);
 	if (!foldText || 0 != strcmp(text, foldText)) {
@@ -210,7 +210,7 @@
 	}
 }
 
-bool ContractionState::GetExpanded(int lineDoc) const {
+bool ContractionState::GetExpanded(Sci::Line lineDoc) const {
 	if (OneToOne()) {
 		return true;
 	} else {
@@ -219,7 +219,7 @@
 	}
 }
 
-bool ContractionState::SetExpanded(int lineDoc, bool isExpanded) {
+bool ContractionState::SetExpanded(Sci::Line lineDoc, bool isExpanded) {
 	if (OneToOne() && isExpanded) {
 		return false;
 	} else {
@@ -235,11 +235,11 @@
 	}
 }
 
-bool ContractionState::GetFoldDisplayTextShown(int lineDoc) const {
+bool ContractionState::GetFoldDisplayTextShown(Sci::Line lineDoc) const {
 	return !GetExpanded(lineDoc) && GetFoldDisplayText(lineDoc);
 }
 
-int ContractionState::ContractedNext(int lineDocStart) const {
+Sci::Line ContractionState::ContractedNext(Sci::Line lineDocStart) const {
 	if (OneToOne()) {
 		return -1;
 	} else {
@@ -247,7 +247,7 @@
 		if (!expanded->ValueAt(lineDocStart)) {
 			return lineDocStart;
 		} else {
-			int lineDocNextChange = expanded->EndRun(lineDocStart);
+			Sci::Line lineDocNextChange = expanded->EndRun(lineDocStart);
 			if (lineDocNextChange < LinesInDoc())
 				return lineDocNextChange;
 			else
@@ -256,7 +256,7 @@
 	}
 }
 
-int ContractionState::GetHeight(int lineDoc) const {
+int ContractionState::GetHeight(Sci::Line lineDoc) const {
 	if (OneToOne()) {
 		return 1;
 	} else {
@@ -266,7 +266,7 @@
 
 // Set the number of display lines needed for this line.
 // Return true if this is a change.
-bool ContractionState::SetHeight(int lineDoc, int height) {
+bool ContractionState::SetHeight(Sci::Line lineDoc, int height) {
 	if (OneToOne() && (height == 1)) {
 		return false;
 	} else if (lineDoc < LinesInDoc()) {
@@ -288,7 +288,7 @@
 }
 
 void ContractionState::ShowAll() {
-	int lines = LinesInDoc();
+	Sci::Line lines = LinesInDoc();
 	Clear();
 	linesInDocument = lines;
 }
@@ -297,14 +297,14 @@
 
 void ContractionState::Check() const {
 #ifdef CHECK_CORRECTNESS
-	for (int vline = 0; vline < LinesDisplayed(); vline++) {
-		const int lineDoc = DocFromDisplay(vline);
+	for (Sci::Line vline = 0; vline < LinesDisplayed(); vline++) {
+		const Sci::Line lineDoc = DocFromDisplay(vline);
 		PLATFORM_ASSERT(GetVisible(lineDoc));
 	}
-	for (int lineDoc = 0; lineDoc < LinesInDoc(); lineDoc++) {
-		const int displayThis = DisplayFromDoc(lineDoc);
-		const int displayNext = DisplayFromDoc(lineDoc + 1);
-		const int height = displayNext - displayThis;
+	for (Sci::Line lineDoc = 0; lineDoc < LinesInDoc(); lineDoc++) {
+		const Sci::Line displayThis = DisplayFromDoc(lineDoc);
+		const Sci::Line displayNext = DisplayFromDoc(lineDoc + 1);
+		const Sci::Line height = displayNext - displayThis;
 		PLATFORM_ASSERT(height >= 0);
 		if (GetVisible(lineDoc)) {
 			PLATFORM_ASSERT(GetHeight(lineDoc) == height);
diff -r 1788f6795302 -r a0f26eaf474d src/ContractionState.h
--- a/src/ContractionState.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/ContractionState.h	Fri Mar 31 18:19:38 2017 +1100
@@ -24,7 +24,7 @@
 	RunStyles *heights;
 	SparseVector<const char *> *foldDisplayTexts;
 	Partitioning *displayLines;
-	int linesInDocument;
+	Sci::Line linesInDocument;
 
 	void EnsureData();
 
@@ -40,31 +40,31 @@
 
 	void Clear();
 
-	int LinesInDoc() const;
-	int LinesDisplayed() const;
-	int DisplayFromDoc(int lineDoc) const;
-	int DisplayLastFromDoc(int lineDoc) const;
-	int DocFromDisplay(int lineDisplay) const;
+	Sci::Line LinesInDoc() const;
+	Sci::Line LinesDisplayed() const;
+	Sci::Line DisplayFromDoc(Sci::Line lineDoc) const;
+	Sci::Line DisplayLastFromDoc(Sci::Line lineDoc) const;
+	Sci::Line DocFromDisplay(Sci::Line lineDisplay) const;
 
-	void InsertLine(int lineDoc);
-	void InsertLines(int lineDoc, int lineCount);
-	void DeleteLine(int lineDoc);
-	void DeleteLines(int lineDoc, int lineCount);
+	void InsertLine(Sci::Line lineDoc);
+	void InsertLines(Sci::Line lineDoc, Sci::Line lineCount);
+	void DeleteLine(Sci::Line lineDoc);
+	void DeleteLines(Sci::Line lineDoc, Sci::Line lineCount);
 
-	bool GetVisible(int lineDoc) const;
-	bool SetVisible(int lineDocStart, int lineDocEnd, bool isVisible);
+	bool GetVisible(Sci::Line lineDoc) const;
+	bool SetVisible(Sci::Line lineDocStart, Sci::Line lineDocEnd, bool isVisible);
 	bool HiddenLines() const;
 
-	const char *GetFoldDisplayText(int lineDoc) const;
-	bool SetFoldDisplayText(int lineDoc, const char *text);
+	const char *GetFoldDisplayText(Sci::Line lineDoc) const;
+	bool SetFoldDisplayText(Sci::Line lineDoc, const char *text);
 
-	bool GetExpanded(int lineDoc) const;
-	bool SetExpanded(int lineDoc, bool isExpanded);
-	bool GetFoldDisplayTextShown(int lineDoc) const;
-	int ContractedNext(int lineDocStart) const;
+	bool GetExpanded(Sci::Line lineDoc) const;
+	bool SetExpanded(Sci::Line lineDoc, bool isExpanded);
+	bool GetFoldDisplayTextShown(Sci::Line lineDoc) const;
+	Sci::Line ContractedNext(Sci::Line lineDocStart) const;
 
-	int GetHeight(int lineDoc) const;
-	bool SetHeight(int lineDoc, int height);
+	int GetHeight(Sci::Line lineDoc) const;
+	bool SetHeight(Sci::Line lineDoc, int height);
 
 	void ShowAll();
 	void Check() const;
diff -r 1788f6795302 -r a0f26eaf474d src/Document.cxx
--- a/src/Document.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Document.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -54,17 +54,17 @@
 using namespace Scintilla;
 #endif
 
-void LexInterface::Colourise(int start, int end) {
+void LexInterface::Colourise(Sci::Position start, Sci::Position end) {
 	if (pdoc && instance && !performingStyle) {
 		// Protect against reentrance, which may occur, for example, when
 		// fold points are discovered while performing styling and the folding
 		// code looks for child lines which may trigger styling.
 		performingStyle = true;
 
-		int lengthDoc = pdoc->Length();
+		Sci::Position lengthDoc = pdoc->Length();
 		if (end == -1)
 			end = lengthDoc;
-		int len = end - start;
+		Sci::Position len = end - start;
 
 		PLATFORM_ASSERT(len >= 0);
 		PLATFORM_ASSERT(start + len <= lengthDoc);
@@ -189,14 +189,14 @@
 	}
 }
 
-void Document::InsertLine(int line) {
+void Document::InsertLine(Sci::Line line) {
 	for (int j=0; j<ldSize; j++) {
 		if (perLineData[j])
 			perLineData[j]->InsertLine(line);
 	}
 }
 
-void Document::RemoveLine(int line) {
+void Document::RemoveLine(Sci::Line line) {
 	for (int j=0; j<ldSize; j++) {
 		if (perLineData[j])
 			perLineData[j]->RemoveLine(line);
@@ -234,7 +234,7 @@
 			int steps = cb.TentativeSteps();
 			//Platform::DebugPrintf("Steps=%d\n", steps);
 			for (int step = 0; step < steps; step++) {
-				const int prevLinesTotal = LinesTotal();
+				const Sci::Line prevLinesTotal = LinesTotal();
 				const Action &action = cb.GetUndoStep();
 				if (action.at == removeAction) {
 					NotifyModified(DocModification(
@@ -261,7 +261,7 @@
 				}
 				if (steps > 1)
 					modFlags |= SC_MULTISTEPUNDOREDO;
-				const int linesAdded = LinesTotal() - prevLinesTotal;
+				const Sci::Line linesAdded = LinesTotal() - prevLinesTotal;
 				if (linesAdded != 0)
 					multiLine = true;
 				if (step == steps - 1) {
@@ -283,15 +283,15 @@
 	}
 }
 
-int Document::GetMark(int line) {
+int Document::GetMark(Sci::Line line) {
 	return static_cast<LineMarkers *>(perLineData[ldMarkers])->MarkValue(line);
 }
 
-int Document::MarkerNext(int lineStart, int mask) const {
+Sci::Line Document::MarkerNext(Sci::Line lineStart, int mask) const {
 	return static_cast<LineMarkers *>(perLineData[ldMarkers])->MarkerNext(lineStart, mask);
 }
 
-int Document::AddMark(int line, int markerNum) {
+int Document::AddMark(Sci::Line line, int markerNum) {
 	if (line >= 0 && line <= LinesTotal()) {
 		int prev = static_cast<LineMarkers *>(perLineData[ldMarkers])->
 			AddMark(line, markerNum, LinesTotal());
@@ -303,7 +303,7 @@
 	}
 }
 
-void Document::AddMarkSet(int line, int valueSet) {
+void Document::AddMarkSet(Sci::Line line, int valueSet) {
 	if (line < 0 || line > LinesTotal()) {
 		return;
 	}
@@ -316,7 +316,7 @@
 	NotifyModified(mh);
 }
 
-void Document::DeleteMark(int line, int markerNum) {
+void Document::DeleteMark(Sci::Line line, int markerNum) {
 	static_cast<LineMarkers *>(perLineData[ldMarkers])->DeleteMark(line, markerNum, false);
 	DocModification mh(SC_MOD_CHANGEMARKER, LineStart(line), 0, 0, 0, line);
 	NotifyModified(mh);
@@ -331,7 +331,7 @@
 
 void Document::DeleteAllMarks(int markerNum) {
 	bool someChanges = false;
-	for (int line = 0; line < LinesTotal(); line++) {
+	for (Sci::Line line = 0; line < LinesTotal(); line++) {
 		if (static_cast<LineMarkers *>(perLineData[ldMarkers])->DeleteMark(line, markerNum, true))
 			someChanges = true;
 	}
@@ -342,7 +342,7 @@
 	}
 }
 
-int Document::LineFromHandle(int markerHandle) {
+Sci::Line Document::LineFromHandle(int markerHandle) {
 	return static_cast<LineMarkers *>(perLineData[ldMarkers])->LineFromHandle(markerHandle);
 }
 
@@ -350,7 +350,7 @@
 	return cb.LineStart(line);
 }
 
-bool Document::IsLineStartPosition(int position) const {
+bool Document::IsLineStartPosition(Sci::Position position) const {
 	return LineStart(LineFromPosition(position)) == position;
 }
 
@@ -358,7 +358,7 @@
 	if (line >= LinesTotal() - 1) {
 		return LineStart(line + 1);
 	} else {
-		int position = LineStart(line + 1);
+		Sci::Position position = LineStart(line + 1);
 		if (SC_CP_UTF8 == dbcsCodePage) {
 			unsigned char bytes[] = {
 				static_cast<unsigned char>(cb.CharAt(position-3)),
@@ -392,23 +392,23 @@
 	return cb.LineFromPosition(pos);
 }
 
-int Document::LineEndPosition(int position) const {
+Sci::Position Document::LineEndPosition(Sci::Position position) const {
 	return LineEnd(LineFromPosition(position));
 }
 
-bool Document::IsLineEndPosition(int position) const {
+bool Document::IsLineEndPosition(Sci::Position position) const {
 	return LineEnd(LineFromPosition(position)) == position;
 }
 
-bool Document::IsPositionInLineEnd(int position) const {
+bool Document::IsPositionInLineEnd(Sci::Position position) const {
 	return position >= LineEnd(LineFromPosition(position));
 }
 
-int Document::VCHomePosition(int position) const {
-	int line = LineFromPosition(position);
-	int startPosition = LineStart(line);
-	int endLine = LineEnd(line);
-	int startText = startPosition;
+Sci::Position Document::VCHomePosition(Sci::Position position) const {
+	Sci::Line line = LineFromPosition(position);
+	Sci::Position startPosition = LineStart(line);
+	Sci::Position endLine = LineEnd(line);
+	Sci::Position startText = startPosition;
 	while (startText < endLine && (cb.CharAt(startText) == ' ' || cb.CharAt(startText) == '\t'))
 		startText++;
 	if (position == startText)
@@ -444,12 +444,12 @@
 		return LevelNumber(levelStart) < LevelNumber(levelTry);
 }
 
-int Document::GetLastChild(int lineParent, int level, int lastLine) {
+Sci::Line Document::GetLastChild(Sci::Line lineParent, int level, Sci::Line lastLine) {
 	if (level == -1)
 		level = LevelNumber(GetLevel(lineParent));
-	int maxLine = LinesTotal();
-	int lookLastLine = (lastLine != -1) ? Platform::Minimum(LinesTotal() - 1, lastLine) : -1;
-	int lineMaxSubord = lineParent;
+	Sci::Line maxLine = LinesTotal();
+	Sci::Line lookLastLine = (lastLine != -1) ? Platform::Minimum(LinesTotal() - 1, lastLine) : -1;
+	Sci::Line lineMaxSubord = lineParent;
 	while (lineMaxSubord < maxLine - 1) {
 		EnsureStyledTo(LineStart(lineMaxSubord + 2));
 		if (!IsSubordinate(level, GetLevel(lineMaxSubord + 1)))
@@ -469,9 +469,9 @@
 	return lineMaxSubord;
 }
 
-int Document::GetFoldParent(int line) const {
+Sci::Line Document::GetFoldParent(Sci::Line line) const {
 	int level = LevelNumber(GetLevel(line));
-	int lineLook = line - 1;
+	Sci::Line lineLook = line - 1;
 	while ((lineLook > 0) && (
 	            (!(GetLevel(lineLook) & SC_FOLDLEVELHEADERFLAG)) ||
 	            (LevelNumber(GetLevel(lineLook)) >= level))
@@ -486,11 +486,11 @@
 	}
 }
 
-void Document::GetHighlightDelimiters(HighlightDelimiter &highlightDelimiter, int line, int lastLine) {
+void Document::GetHighlightDelimiters(HighlightDelimiter &highlightDelimiter, Sci::Line line, Sci::Line lastLine) {
 	int level = GetLevel(line);
-	int lookLastLine = Platform::Maximum(line, lastLine) + 1;
+	Sci::Line lookLastLine = Platform::Maximum(line, lastLine) + 1;
 
-	int lookLine = line;
+	Sci::Line lookLine = line;
 	int lookLineLevel = level;
 	int lookLineLevelNum = LevelNumber(lookLineLevel);
 	while ((lookLine > 0) && ((lookLineLevel & SC_FOLDLEVELWHITEFLAG) ||
@@ -499,14 +499,14 @@
 		lookLineLevelNum = LevelNumber(lookLineLevel);
 	}
 
-	int beginFoldBlock = (lookLineLevel & SC_FOLDLEVELHEADERFLAG) ? lookLine : GetFoldParent(lookLine);
+	Sci::Line beginFoldBlock = (lookLineLevel & SC_FOLDLEVELHEADERFLAG) ? lookLine : GetFoldParent(lookLine);
 	if (beginFoldBlock == -1) {
 		highlightDelimiter.Clear();
 		return;
 	}
 
-	int endFoldBlock = GetLastChild(beginFoldBlock, -1, lookLastLine);
-	int firstChangeableLineBefore = -1;
+	Sci::Line endFoldBlock = GetLastChild(beginFoldBlock, -1, lookLastLine);
+	Sci::Line firstChangeableLineBefore = -1;
 	if (endFoldBlock < line) {
 		lookLine = beginFoldBlock - 1;
 		lookLineLevel = GetLevel(lookLine);
@@ -538,7 +538,7 @@
 	if (firstChangeableLineBefore == -1)
 		firstChangeableLineBefore = beginFoldBlock - 1;
 
-	int firstChangeableLineAfter = -1;
+	Sci::Line firstChangeableLineAfter = -1;
 	for (lookLine = line + 1, lookLineLevel = GetLevel(lookLine), lookLineLevelNum = LevelNumber(lookLineLevel);
 		lookLine <= endFoldBlock;
 		lookLineLevel = GetLevel(++lookLine), lookLineLevelNum = LevelNumber(lookLineLevel)) {
@@ -556,11 +556,11 @@
 	highlightDelimiter.firstChangeableLineAfter = firstChangeableLineAfter;
 }
 
-int Document::ClampPositionIntoDocument(int pos) const {
+Sci::Position Document::ClampPositionIntoDocument(Sci::Position pos) const {
 	return Platform::Clamp(pos, 0, Length());
 }
 
-bool Document::IsCrLf(int pos) const {
+bool Document::IsCrLf(Sci::Position pos) const {
 	if (pos < 0)
 		return false;
 	if (pos >= (Length() - 1))
@@ -568,7 +568,7 @@
 	return (cb.CharAt(pos) == '\r') && (cb.CharAt(pos + 1) == '\n');
 }
 
-int Document::LenChar(int pos) {
+int Document::LenChar(Sci::Position pos) {
 	if (pos < 0) {
 		return 1;
 	} else if (IsCrLf(pos)) {
@@ -576,7 +576,7 @@
 	} else if (SC_CP_UTF8 == dbcsCodePage) {
 		const unsigned char leadByte = static_cast<unsigned char>(cb.CharAt(pos));
 		const int widthCharBytes = UTF8BytesOfLead[leadByte];
-		int lengthDoc = Length();
+		Sci::Position lengthDoc = Length();
 		if ((pos + widthCharBytes) > lengthDoc)
 			return lengthDoc - pos;
 		else
@@ -588,8 +588,8 @@
 	}
 }
 
-bool Document::InGoodUTF8(int pos, int &start, int &end) const {
-	int trail = pos;
+bool Document::InGoodUTF8(Sci::Position pos, Sci::Position &start, Sci::Position &end) const {
+	Sci::Position trail = pos;
 	while ((trail>0) && (pos-trail < UTF8MaxBytes) && UTF8IsTrailByte(static_cast<unsigned char>(cb.CharAt(trail-1))))
 		trail--;
 	start = (trail > 0) ? trail-1 : trail;
@@ -600,13 +600,13 @@
 		return false;
 	} else {
 		int trailBytes = widthCharBytes - 1;
-		int len = pos - start;
+		Sci::Position len = pos - start;
 		if (len > trailBytes)
 			// pos too far from lead
 			return false;
 		char charBytes[UTF8MaxBytes] = {static_cast<char>(leadByte),0,0,0};
 		for (int b=1; b<widthCharBytes && ((start+b) < Length()); b++)
-			charBytes[b] = cb.CharAt(static_cast<int>(start+b));
+			charBytes[b] = cb.CharAt(static_cast<Sci::Position>(start+b));
 		int utf8status = UTF8Classify(reinterpret_cast<const unsigned char *>(charBytes), widthCharBytes);
 		if (utf8status & UTF8MaskInvalid)
 			return false;
@@ -620,7 +620,7 @@
 // When lines are terminated with \r\n pairs which should be treated as one character.
 // When displaying DBCS text such as Japanese.
 // If moving, move the position in the indicated direction.
-int Document::MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd) const {
+Sci::Position Document::MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd) const {
 	//Platform::DebugPrintf("NoCRLF %d %d\n", pos, moveDir);
 	// If out of range, just return minimum/maximum value.
 	if (pos <= 0)
@@ -641,8 +641,8 @@
 			unsigned char ch = static_cast<unsigned char>(cb.CharAt(pos));
 			// If ch is not a trail byte then pos is valid intercharacter position
 			if (UTF8IsTrailByte(ch)) {
-				int startUTF = pos;
-				int endUTF = pos;
+				Sci::Position startUTF = pos;
+				Sci::Position endUTF = pos;
 				if (InGoodUTF8(pos, startUTF, endUTF)) {
 					// ch is a trail byte within a UTF-8 character
 					if (moveDir > 0)
@@ -655,12 +655,12 @@
 		} else {
 			// Anchor DBCS calculations at start of line because start of line can
 			// not be a DBCS trail byte.
-			int posStartLine = LineStart(LineFromPosition(pos));
+			Sci::Position posStartLine = LineStart(LineFromPosition(pos));
 			if (pos == posStartLine)
 				return pos;
 
 			// Step back until a non-lead-byte is found.
-			int posCheck = pos;
+			Sci::Position posCheck = pos;
 			while ((posCheck > posStartLine) && IsDBCSLeadByte(cb.CharAt(posCheck-1)))
 				posCheck--;
 
@@ -687,7 +687,7 @@
 // NextPosition moves between valid positions - it can not handle a position in the middle of a
 // multi-byte character. It is used to iterate through text more efficiently than MovePositionOutsideChar.
 // A \r\n pair is treated as two characters.
-int Document::NextPosition(int pos, int moveDir) const {
+Sci::Position Document::NextPosition(Sci::Position pos, int moveDir) const {
 	// If out of range, just return minimum/maximum value.
 	int increment = (moveDir > 0) ? 1 : -1;
 	if (pos + increment <= 0)
@@ -721,8 +721,8 @@
 				// If ch is not a trail byte then pos is valid intercharacter position
 				if (UTF8IsTrailByte(ch)) {
 					// If ch is a trail byte in a valid UTF-8 character then return start of character
-					int startUTF = pos;
-					int endUTF = pos;
+					Sci::Position startUTF = pos;
+					Sci::Position endUTF = pos;
 					if (InGoodUTF8(pos, startUTF, endUTF)) {
 						pos = startUTF;
 					}
@@ -738,7 +738,7 @@
 			} else {
 				// Anchor DBCS calculations at start of line because start of line can
 				// not be a DBCS trail byte.
-				int posStartLine = LineStart(LineFromPosition(pos));
+				Sci::Position posStartLine = LineStart(LineFromPosition(pos));
 				// See http://msdn.microsoft.com/en-us/library/cc194792%28v=MSDN.10%29.aspx
 				// http://msdn.microsoft.com/en-us/library/cc194790.aspx
 				if ((pos - 1) <= posStartLine) {
@@ -748,7 +748,7 @@
 					return pos - 2;
 				} else {
 					// Otherwise, step back until a non-lead-byte is found.
-					int posTemp = pos - 1;
+					Sci::Position posTemp = pos - 1;
 					while (posStartLine <= --posTemp && IsDBCSLeadByte(cb.CharAt(posTemp)))
 						;
 					// Now posTemp+1 must point to the beginning of a character,
@@ -765,9 +765,9 @@
 	return pos;
 }
 
-bool Document::NextCharacter(int &pos, int moveDir) const {
+bool Document::NextCharacter(Sci::Position &pos, int moveDir) const {
 	// Returns true if pos changed
-	int posNext = NextPosition(pos, moveDir);
+	Sci::Position posNext = NextPosition(pos, moveDir);
 	if (posNext == pos) {
 		return false;
 	} else {
@@ -776,7 +776,7 @@
 	}
 }
 
-Document::CharacterExtracted Document::CharacterAfter(int position) const {
+Document::CharacterExtracted Document::CharacterAfter(Sci::Position position) const {
 	if (position >= Length()) {
 		return CharacterExtracted(unicodeReplacementChar, 0);
 	}
@@ -806,7 +806,7 @@
 	}
 }
 
-Document::CharacterExtracted Document::CharacterBefore(int position) const {
+Document::CharacterExtracted Document::CharacterBefore(Sci::Position position) const {
 	if (position <= 0) {
 		return CharacterExtracted(unicodeReplacementChar, 0);
 	}
@@ -822,8 +822,8 @@
 		// If previousByte is not a trail byte then its invalid
 		if (UTF8IsTrailByte(previousByte)) {
 			// If previousByte is a trail byte in a valid UTF-8 character then find start of character
-			int startUTF = position;
-			int endUTF = position;
+			Sci::Position startUTF = position;
+			Sci::Position endUTF = position;
 			if (InGoodUTF8(position, startUTF, endUTF)) {
 				const int widthCharBytes = endUTF - startUTF;
 				unsigned char charBytes[UTF8MaxBytes] = { 0, 0, 0, 0 };
@@ -842,18 +842,18 @@
 		return CharacterExtracted(unicodeReplacementChar, 1);
 	} else {
 		// Moving backwards in DBCS is complex so use NextPosition
-		const int posStartCharacter = NextPosition(position, -1);
+		const Sci::Position posStartCharacter = NextPosition(position, -1);
 		return CharacterAfter(posStartCharacter);
 	}
 }
 
 // Return -1  on out-of-bounds
 Sci_Position SCI_METHOD Document::GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const {
-	int pos = positionStart;
+	Sci::Position pos = positionStart;
 	if (dbcsCodePage) {
 		const int increment = (characterOffset > 0) ? 1 : -1;
 		while (characterOffset != 0) {
-			const int posNext = NextPosition(pos, increment);
+			const Sci::Position posNext = NextPosition(pos, increment);
 			if (posNext == pos)
 				return INVALID_POSITION;
 			pos = posNext;
@@ -867,12 +867,12 @@
 	return pos;
 }
 
-int Document::GetRelativePositionUTF16(int positionStart, int characterOffset) const {
-	int pos = positionStart;
+Sci::Position Document::GetRelativePositionUTF16(Sci::Position positionStart, Sci::Position characterOffset) const {
+	Sci::Position pos = positionStart;
 	if (dbcsCodePage) {
 		const int increment = (characterOffset > 0) ? 1 : -1;
 		while (characterOffset != 0) {
-			const int posNext = NextPosition(pos, increment);
+			const Sci::Position posNext = NextPosition(pos, increment);
 			if (posNext == pos)
 				return INVALID_POSITION;
 			if (abs(pos-posNext) > 3)	// 4 byte character = 2*UTF16.
@@ -1018,7 +1018,7 @@
 		return efEightBit;
 }
 
-void Document::ModifiedAt(int pos) {
+void Document::ModifiedAt(Sci::Position pos) {
 	if (endStyled > pos)
 		endStyled = pos;
 }
@@ -1034,7 +1034,7 @@
 // Document only modified by gateways DeleteChars, InsertString, Undo, Redo, and SetStyleAt.
 // SetStyleAt does not change the persistent state of a document
 
-bool Document::DeleteChars(int pos, int len) {
+bool Document::DeleteChars(Sci::Position pos, Sci::Position len) {
 	if (pos < 0)
 		return false;
 	if (len <= 0)
@@ -1052,7 +1052,7 @@
 			        SC_MOD_BEFOREDELETE | SC_PERFORMED_USER,
 			        pos, len,
 			        0, 0));
-			int prevLinesTotal = LinesTotal();
+			Sci::Line prevLinesTotal = LinesTotal();
 			bool startSavePoint = cb.IsSavePoint();
 			bool startSequence = false;
 			const char *text = cb.DeleteChars(pos, len, startSequence);
@@ -1076,7 +1076,7 @@
 /**
  * Insert a string with a length.
  */
-int Document::InsertString(int position, const char *s, int insertLength) {
+Sci::Position Document::InsertString(Sci::Position position, const char *s, Sci::Position insertLength) {
 	if (insertLength <= 0) {
 		return 0;
 	}
@@ -1104,7 +1104,7 @@
 			SC_MOD_BEFOREINSERT | SC_PERFORMED_USER,
 			position, insertLength,
 			0, s));
-	int prevLinesTotal = LinesTotal();
+	Sci::Line prevLinesTotal = LinesTotal();
 	bool startSavePoint = cb.IsSavePoint();
 	bool startSequence = false;
 	const char *text = cb.InsertString(position, s, insertLength, startSequence);
@@ -1123,14 +1123,14 @@
 	return insertLength;
 }
 
-void Document::ChangeInsertion(const char *s, int length) {
+void Document::ChangeInsertion(const char *s, Sci::Position length) {
 	insertionSet = true;
 	insertion.assign(s, length);
 }
 
 int SCI_METHOD Document::AddData(char *data, Sci_Position length) {
 	try {
-		int position = Length();
+		Sci::Position position = Length();
 		InsertString(position, data, length);
 	} catch (std::bad_alloc &) {
 		return SC_STATUS_BADALLOC;
@@ -1144,8 +1144,8 @@
 	return this;
 }
 
-int Document::Undo() {
-	int newPos = -1;
+Sci::Position Document::Undo() {
+	Sci::Position newPos = -1;
 	CheckReadOnly();
 	if ((enteredModification == 0) && (cb.IsCollectingUndo())) {
 		enteredModification++;
@@ -1154,12 +1154,12 @@
 			bool multiLine = false;
 			int steps = cb.StartUndo();
 			//Platform::DebugPrintf("Steps=%d\n", steps);
-			int coalescedRemovePos = -1;
-			int coalescedRemoveLen = 0;
-			int prevRemoveActionPos = -1;
-			int prevRemoveActionLen = 0;
+			Sci::Position coalescedRemovePos = -1;
+			Sci::Position coalescedRemoveLen = 0;
+			Sci::Position prevRemoveActionPos = -1;
+			Sci::Position prevRemoveActionLen = 0;
 			for (int step = 0; step < steps; step++) {
-				const int prevLinesTotal = LinesTotal();
+				const Sci::Line prevLinesTotal = LinesTotal();
 				const Action &action = cb.GetUndoStep();
 				if (action.at == removeAction) {
 					NotifyModified(DocModification(
@@ -1208,7 +1208,7 @@
 				}
 				if (steps > 1)
 					modFlags |= SC_MULTISTEPUNDOREDO;
-				const int linesAdded = LinesTotal() - prevLinesTotal;
+				const Sci::Line linesAdded = LinesTotal() - prevLinesTotal;
 				if (linesAdded != 0)
 					multiLine = true;
 				if (step == steps - 1) {
@@ -1229,8 +1229,8 @@
 	return newPos;
 }
 
-int Document::Redo() {
-	int newPos = -1;
+Sci::Position Document::Redo() {
+	Sci::Position newPos = -1;
 	CheckReadOnly();
 	if ((enteredModification == 0) && (cb.IsCollectingUndo())) {
 		enteredModification++;
@@ -1239,7 +1239,7 @@
 			bool multiLine = false;
 			int steps = cb.StartRedo();
 			for (int step = 0; step < steps; step++) {
-				const int prevLinesTotal = LinesTotal();
+				const Sci::Line prevLinesTotal = LinesTotal();
 				const Action &action = cb.GetRedoStep();
 				if (action.at == insertAction) {
 					NotifyModified(DocModification(
@@ -1267,7 +1267,7 @@
 				}
 				if (steps > 1)
 					modFlags |= SC_MULTISTEPUNDOREDO;
-				const int linesAdded = LinesTotal() - prevLinesTotal;
+				const Sci::Line linesAdded = LinesTotal() - prevLinesTotal;
 				if (linesAdded != 0)
 					multiLine = true;
 				if (step == steps - 1) {
@@ -1289,28 +1289,28 @@
 	return newPos;
 }
 
-void Document::DelChar(int pos) {
+void Document::DelChar(Sci::Position pos) {
 	DeleteChars(pos, LenChar(pos));
 }
 
-void Document::DelCharBack(int pos) {
+void Document::DelCharBack(Sci::Position pos) {
 	if (pos <= 0) {
 		return;
 	} else if (IsCrLf(pos - 2)) {
 		DeleteChars(pos - 2, 2);
 	} else if (dbcsCodePage) {
-		int startChar = NextPosition(pos, -1);
+		Sci::Position startChar = NextPosition(pos, -1);
 		DeleteChars(startChar, pos - startChar);
 	} else {
 		DeleteChars(pos - 1, 1);
 	}
 }
 
-static int NextTab(int pos, int tabSize) {
+static Sci::Position NextTab(Sci::Position pos, Sci::Position tabSize) {
 	return ((pos / tabSize) + 1) * tabSize;
 }
 
-static std::string CreateIndentation(int indent, int tabSize, bool insertSpaces) {
+static std::string CreateIndentation(Sci::Position indent, int tabSize, bool insertSpaces) {
 	std::string indentation;
 	if (!insertSpaces) {
 		while (indent >= tabSize) {
@@ -1328,9 +1328,9 @@
 int SCI_METHOD Document::GetLineIndentation(Sci_Position line) {
 	int indent = 0;
 	if ((line >= 0) && (line < LinesTotal())) {
-		int lineStart = LineStart(line);
-		int length = Length();
-		for (int i = lineStart; i < length; i++) {
+		Sci::Position lineStart = LineStart(line);
+		Sci::Position length = Length();
+		for (Sci::Position i = lineStart; i < length; i++) {
 			char ch = cb.CharAt(i);
 			if (ch == ' ')
 				indent++;
@@ -1343,39 +1343,39 @@
 	return indent;
 }
 
-int Document::SetLineIndentation(int line, int indent) {
+Sci::Position Document::SetLineIndentation(Sci::Line line, Sci::Position indent) {
 	int indentOfLine = GetLineIndentation(line);
 	if (indent < 0)
 		indent = 0;
 	if (indent != indentOfLine) {
 		std::string linebuf = CreateIndentation(indent, tabInChars, !useTabs);
-		int thisLineStart = LineStart(line);
-		int indentPos = GetLineIndentPosition(line);
+		Sci::Position thisLineStart = LineStart(line);
+		Sci::Position indentPos = GetLineIndentPosition(line);
 		UndoGroup ug(this);
 		DeleteChars(thisLineStart, indentPos - thisLineStart);
 		return thisLineStart + InsertString(thisLineStart, linebuf.c_str(),
-			static_cast<int>(linebuf.length()));
+			static_cast<Sci::Position>(linebuf.length()));
 	} else {
 		return GetLineIndentPosition(line);
 	}
 }
 
-int Document::GetLineIndentPosition(int line) const {
+Sci::Position Document::GetLineIndentPosition(Sci::Line line) const {
 	if (line < 0)
 		return 0;
-	int pos = LineStart(line);
-	int length = Length();
+	Sci::Position pos = LineStart(line);
+	Sci::Position length = Length();
 	while ((pos < length) && IsSpaceOrTab(cb.CharAt(pos))) {
 		pos++;
 	}
 	return pos;
 }
 
-int Document::GetColumn(int pos) {
-	int column = 0;
-	int line = LineFromPosition(pos);
+Sci::Position Document::GetColumn(Sci::Position pos) {
+	Sci::Position column = 0;
+	Sci::Line line = LineFromPosition(pos);
 	if ((line >= 0) && (line < LinesTotal())) {
-		for (int i = LineStart(line); i < pos;) {
+		for (Sci::Position i = LineStart(line); i < pos;) {
 			char ch = cb.CharAt(i);
 			if (ch == '\t') {
 				column = NextTab(column, tabInChars);
@@ -1395,11 +1395,11 @@
 	return column;
 }
 
-int Document::CountCharacters(int startPos, int endPos) const {
+Sci::Position Document::CountCharacters(Sci::Position startPos, Sci::Position endPos) const {
 	startPos = MovePositionOutsideChar(startPos, 1, false);
 	endPos = MovePositionOutsideChar(endPos, -1, false);
-	int count = 0;
-	int i = startPos;
+	Sci::Position count = 0;
+	Sci::Position i = startPos;
 	while (i < endPos) {
 		count++;
 		i = NextPosition(i, 1);
@@ -1407,14 +1407,14 @@
 	return count;
 }
 
-int Document::CountUTF16(int startPos, int endPos) const {
+Sci::Position Document::CountUTF16(Sci::Position startPos, Sci::Position endPos) const {
 	startPos = MovePositionOutsideChar(startPos, 1, false);
 	endPos = MovePositionOutsideChar(endPos, -1, false);
-	int count = 0;
-	int i = startPos;
+	Sci::Position count = 0;
+	Sci::Position i = startPos;
 	while (i < endPos) {
 		count++;
-		const int next = NextPosition(i, 1);
+		const Sci::Position next = NextPosition(i, 1);
 		if ((next - i) > 3)
 			count++;
 		i = next;
@@ -1422,10 +1422,10 @@
 	return count;
 }
 
-int Document::FindColumn(int line, int column) {
-	int position = LineStart(line);
+Sci::Position Document::FindColumn(Sci::Line line, Sci::Position column) {
+	Sci::Position position = LineStart(line);
 	if ((line >= 0) && (line < LinesTotal())) {
-		int columnCurrent = 0;
+		Sci::Position columnCurrent = 0;
 		while ((columnCurrent < column) && (position < Length())) {
 			char ch = cb.CharAt(position);
 			if (ch == '\t') {
@@ -1446,10 +1446,10 @@
 	return position;
 }
 
-void Document::Indent(bool forwards, int lineBottom, int lineTop) {
+void Document::Indent(bool forwards, Sci::Line lineBottom, Sci::Line lineTop) {
 	// Dedent - suck white space off the front of the line to dedent by equivalent of a tab
-	for (int line = lineBottom; line >= lineTop; line--) {
-		int indentOfLine = GetLineIndentation(line);
+	for (Sci::Line line = lineBottom; line >= lineTop; line--) {
+		Sci::Position indentOfLine = GetLineIndentation(line);
 		if (forwards) {
 			if (LineStart(line) < LineEnd(line)) {
 				SetLineIndentation(line, indentOfLine + IndentSize());
@@ -1487,7 +1487,7 @@
 void Document::ConvertLineEnds(int eolModeSet) {
 	UndoGroup ug(this);
 
-	for (int pos = 0; pos < Length(); pos++) {
+	for (Sci::Position pos = 0; pos < Length(); pos++) {
 		if (cb.CharAt(pos) == '\r') {
 			if (cb.CharAt(pos + 1) == '\n') {
 				// CRLF
@@ -1522,9 +1522,9 @@
 
 }
 
-bool Document::IsWhiteLine(int line) const {
-	int currentChar = LineStart(line);
-	int endLine = LineEnd(line);
+bool Document::IsWhiteLine(Sci::Line line) const {
+	Sci::Position currentChar = LineStart(line);
+	Sci::Position endLine = LineEnd(line);
 	while (currentChar < endLine) {
 		if (cb.CharAt(currentChar) != ' ' && cb.CharAt(currentChar) != '\t') {
 			return false;
@@ -1534,8 +1534,8 @@
 	return true;
 }
 
-int Document::ParaUp(int pos) const {
-	int line = LineFromPosition(pos);
+Sci::Position Document::ParaUp(Sci::Position pos) const {
+	Sci::Line line = LineFromPosition(pos);
 	line--;
 	while (line >= 0 && IsWhiteLine(line)) { // skip empty lines
 		line--;
@@ -1547,8 +1547,8 @@
 	return LineStart(line);
 }
 
-int Document::ParaDown(int pos) const {
-	int line = LineFromPosition(pos);
+Sci::Position Document::ParaDown(Sci::Position pos) const {
+	Sci::Line line = LineFromPosition(pos);
 	while (line < LinesTotal() && !IsWhiteLine(line)) { // skip non-empty lines
 		line++;
 	}
@@ -1635,7 +1635,7 @@
  * Used by commmands that want to select whole words.
  * Finds the start of word at pos when delta < 0 or the end of the word when delta >= 0.
  */
-int Document::ExtendWordSelect(int pos, int delta, bool onlyWordCharacters) const {
+Sci::Position Document::ExtendWordSelect(Sci::Position pos, int delta, bool onlyWordCharacters) const {
 	CharClassify::cc ccStart = CharClassify::ccWord;
 	if (delta < 0) {
 		if (!onlyWordCharacters) {
@@ -1670,7 +1670,7 @@
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordStart(int pos, int delta) const {
+Sci::Position Document::NextWordStart(Sci::Position pos, int delta) const {
 	if (delta < 0) {
 		while (pos > 0) {
 			const CharacterExtracted ce = CharacterBefore(pos);
@@ -1714,7 +1714,7 @@
  * additional movement to transit white space.
  * Used by cursor movement by word commands.
  */
-int Document::NextWordEnd(int pos, int delta) const {
+Sci::Position Document::NextWordEnd(Sci::Position pos, int delta) const {
 	if (delta < 0) {
 		if (pos > 0) {
 			CharacterExtracted ce = CharacterBefore(pos);
@@ -1759,7 +1759,7 @@
  * Check that the character at the given position is a word or punctuation character and that
  * the previous character is of a different character class.
  */
-bool Document::IsWordStartAt(int pos) const {
+bool Document::IsWordStartAt(Sci::Position pos) const {
 	if (pos >= Length())
 		return false;
 	if (pos > 0) {
@@ -1777,7 +1777,7 @@
  * Check that the character at the given position is a word or punctuation character and that
  * the next character is of a different character class.
  */
-bool Document::IsWordEndAt(int pos) const {
+bool Document::IsWordEndAt(Sci::Position pos) const {
 	if (pos <= 0)
 		return false;
 	if (pos < Length()) {
@@ -1795,11 +1795,11 @@
  * Check that the given range is has transitions between character classes at both
  * ends and where the characters on the inside are word or punctuation characters.
  */
-bool Document::IsWordAt(int start, int end) const {
+bool Document::IsWordAt(Sci::Position start, Sci::Position end) const {
 	return (start < end) && IsWordStartAt(start) && IsWordEndAt(end);
 }
 
-bool Document::MatchesWordOptions(bool word, bool wordStart, int pos, int length) const {
+bool Document::MatchesWordOptions(bool word, bool wordStart, Sci::Position pos, Sci::Position length) const {
 	return (!word && !wordStart) ||
 			(word && IsWordAt(pos, pos + length)) ||
 			(wordStart && IsWordStartAt(pos));
@@ -1814,7 +1814,7 @@
 	pcf = pcf_;
 }
 
-Document::CharacterExtracted Document::ExtractCharacter(int position) const {
+Document::CharacterExtracted Document::ExtractCharacter(Sci::Position position) const {
 	const unsigned char leadByte = static_cast<unsigned char>(cb.CharAt(position));
 	if (UTF8IsAscii(leadByte)) {
 		// Common case: ASCII character
@@ -1838,8 +1838,8 @@
  * searches (just pass minPos > maxPos to do a backward search)
  * Has not been tested with backwards DBCS searches yet.
  */
-long Document::FindText(int minPos, int maxPos, const char *search,
-                        int flags, int *length) {
+long Document::FindText(Sci::Position minPos, Sci::Position maxPos, const char *search,
+                        int flags, Sci::Position *length) {
 	if (*length <= 0)
 		return minPos;
 	const bool caseSensitive = (flags & SCFIND_MATCHCASE) != 0;
@@ -1856,21 +1856,21 @@
 		const int increment = forward ? 1 : -1;
 
 		// Range endpoints should not be inside DBCS characters, but just in case, move them.
-		const int startPos = MovePositionOutsideChar(minPos, increment, false);
-		const int endPos = MovePositionOutsideChar(maxPos, increment, false);
+		const Sci::Position startPos = MovePositionOutsideChar(minPos, increment, false);
+		const Sci::Position endPos = MovePositionOutsideChar(maxPos, increment, false);
 
 		// Compute actual search ranges needed
-		const int lengthFind = *length;
+		const Sci::Position lengthFind = *length;
 
 		//Platform::DebugPrintf("Find %d %d %s %d\n", startPos, endPos, ft->lpstrText, lengthFind);
-		const int limitPos = Platform::Maximum(startPos, endPos);
-		int pos = startPos;
+		const Sci::Position limitPos = Platform::Maximum(startPos, endPos);
+		Sci::Position pos = startPos;
 		if (!forward) {
 			// Back all of a character
 			pos = NextPosition(pos, increment);
 		}
 		if (caseSensitive) {
-			const int endSearch = (startPos <= endPos) ? endPos - lengthFind + 1 : endPos;
+			const Sci::Position endSearch = (startPos <= endPos) ? endPos - lengthFind + 1 : endPos;
 			const char charStartSearch =  search[0];
 			while (forward ? (pos < endSearch) : (pos >= endSearch)) {
 				if (CharAt(pos) == charStartSearch) {
@@ -1894,7 +1894,7 @@
 			char folded[UTF8MaxBytes * maxFoldingExpansion + 1];
 			while (forward ? (pos < endPos) : (pos >= endPos)) {
 				int widthFirstCharacter = 0;
-				int posIndexDocument = pos;
+				Sci::Position posIndexDocument = pos;
 				int indexSearch = 0;
 				bool characterMatches = true;
 				for (;;) {
@@ -1978,7 +1978,7 @@
 					break;
 			}
 		} else {
-			const int endSearch = (startPos <= endPos) ? endPos - lengthFind + 1 : endPos;
+			const Sci::Position endSearch = (startPos <= endPos) ? endPos - lengthFind + 1 : endPos;
 			std::vector<char> searchThing(lengthFind + 1);
 			pcf->Fold(&searchThing[0], searchThing.size(), search, lengthFind);
 			while (forward ? (pos < endSearch) : (pos >= endSearch)) {
@@ -2001,14 +2001,14 @@
 	return -1;
 }
 
-const char *Document::SubstituteByPosition(const char *text, int *length) {
+const char *Document::SubstituteByPosition(const char *text, Sci::Position *length) {
 	if (regex)
 		return regex->SubstituteByPosition(this, text, length);
 	else
 		return 0;
 }
 
-int Document::LinesTotal() const {
+Sci::Line Document::LinesTotal() const {
 	return cb.Lines();
 }
 
@@ -2033,7 +2033,7 @@
 		return false;
 	} else {
 		enteredStyling++;
-		int prevEndStyled = endStyled;
+		Sci::Position prevEndStyled = endStyled;
 		if (cb.SetStyleFor(endStyled, length, style)) {
 			DocModification mh(SC_MOD_CHANGESTYLE | SC_PERFORMED_USER,
 			                   prevEndStyled, length);
@@ -2051,8 +2051,8 @@
 	} else {
 		enteredStyling++;
 		bool didChange = false;
-		int startMod = 0;
-		int endMod = 0;
+		Sci::Position startMod = 0;
+		Sci::Position endMod = 0;
 		for (int iPos = 0; iPos < length; iPos++, endStyled++) {
 			PLATFORM_ASSERT(endStyled < Length());
 			if (cb.SetStyleAt(endStyled, styles[iPos])) {
@@ -2073,12 +2073,12 @@
 	}
 }
 
-void Document::EnsureStyledTo(int pos) {
+void Document::EnsureStyledTo(Sci::Position pos) {
 	if ((enteredStyling == 0) && (pos > GetEndStyled())) {
 		IncrementStyleClock();
 		if (pli && !pli->UseContainerLexing()) {
-			int lineEndStyled = LineFromPosition(GetEndStyled());
-			int endStyledTo = LineStart(lineEndStyled);
+			Sci::Line lineEndStyled = LineFromPosition(GetEndStyled());
+			Sci::Position endStyledTo = LineStart(lineEndStyled);
 			pli->Colourise(endStyledTo, pos);
 		} else {
 			// Ask the watchers to style, and stop as soon as one responds.
@@ -2090,7 +2090,7 @@
 	}
 }
 
-void Document::StyleToAdjustingLineDuration(int pos) {
+void Document::StyleToAdjustingLineDuration(Sci::Position pos) {
 	// Place bounds on the duration used to avoid glitches spiking it
 	// and so causing slow styling or non-responsive scrolling
 	const double minDurationOneLine = 0.000001;
@@ -2100,11 +2100,11 @@
 	// Most recent value contributes 25% to smoothed value.
 	const double alpha = 0.25;
 
-	const Sci_Position lineFirst = LineFromPosition(GetEndStyled());
+	const Sci::Line lineFirst = LineFromPosition(GetEndStyled());
 	ElapsedTime etStyling;
 	EnsureStyledTo(pos);
 	const double durationStyling = etStyling.Duration();
-	const Sci_Position lineLast = LineFromPosition(GetEndStyled());
+	const Sci::Line lineLast = LineFromPosition(GetEndStyled());
 	if (lineLast >= lineFirst + 8) {
 		// Only adjust for styling multiple lines to avoid instability
 		const double durationOneLine = durationStyling / (lineLast - lineFirst);
@@ -2137,7 +2137,7 @@
 	return static_cast<LineState *>(perLineData[ldState])->GetLineState(line);
 }
 
-int Document::GetMaxLineState() {
+Sci::Line Document::GetMaxLineState() {
 	return static_cast<LineState *>(perLineData[ldState])->GetMaxLineState();
 }
 
@@ -2146,45 +2146,45 @@
 	NotifyModified(mh);
 }
 
-StyledText Document::MarginStyledText(int line) const {
+StyledText Document::MarginStyledText(Sci::Line line) const {
 	LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldMargin]);
 	return StyledText(pla->Length(line), pla->Text(line),
 		pla->MultipleStyles(line), pla->Style(line), pla->Styles(line));
 }
 
-void Document::MarginSetText(int line, const char *text) {
+void Document::MarginSetText(Sci::Line line, const char *text) {
 	static_cast<LineAnnotation *>(perLineData[ldMargin])->SetText(line, text);
 	DocModification mh(SC_MOD_CHANGEMARGIN, LineStart(line), 0, 0, 0, line);
 	NotifyModified(mh);
 }
 
-void Document::MarginSetStyle(int line, int style) {
+void Document::MarginSetStyle(Sci::Line line, int style) {
 	static_cast<LineAnnotation *>(perLineData[ldMargin])->SetStyle(line, style);
 	NotifyModified(DocModification(SC_MOD_CHANGEMARGIN, LineStart(line), 0, 0, 0, line));
 }
 
-void Document::MarginSetStyles(int line, const unsigned char *styles) {
+void Document::MarginSetStyles(Sci::Line line, const unsigned char *styles) {
 	static_cast<LineAnnotation *>(perLineData[ldMargin])->SetStyles(line, styles);
 	NotifyModified(DocModification(SC_MOD_CHANGEMARGIN, LineStart(line), 0, 0, 0, line));
 }
 
 void Document::MarginClearAll() {
-	int maxEditorLine = LinesTotal();
-	for (int l=0; l<maxEditorLine; l++)
+	Sci::Line maxEditorLine = LinesTotal();
+	for (Sci::Line l=0; l<maxEditorLine; l++)
 		MarginSetText(l, 0);
 	// Free remaining data
 	static_cast<LineAnnotation *>(perLineData[ldMargin])->ClearAll();
 }
 
-StyledText Document::AnnotationStyledText(int line) const {
+StyledText Document::AnnotationStyledText(Sci::Line line) const {
 	LineAnnotation *pla = static_cast<LineAnnotation *>(perLineData[ldAnnotation]);
 	return StyledText(pla->Length(line), pla->Text(line),
 		pla->MultipleStyles(line), pla->Style(line), pla->Styles(line));
 }
 
-void Document::AnnotationSetText(int line, const char *text) {
+void Document::AnnotationSetText(Sci::Line line, const char *text) {
 	if (line >= 0 && line < LinesTotal()) {
-		const int linesBefore = AnnotationLines(line);
+		const Sci::Line linesBefore = AnnotationLines(line);
 		static_cast<LineAnnotation *>(perLineData[ldAnnotation])->SetText(line, text);
 		const int linesAfter = AnnotationLines(line);
 		DocModification mh(SC_MOD_CHANGEANNOTATION, LineStart(line), 0, 0, 0, line);
@@ -2193,25 +2193,25 @@
 	}
 }
 
-void Document::AnnotationSetStyle(int line, int style) {
+void Document::AnnotationSetStyle(Sci::Line line, int style) {
 	static_cast<LineAnnotation *>(perLineData[ldAnnotation])->SetStyle(line, style);
 	DocModification mh(SC_MOD_CHANGEANNOTATION, LineStart(line), 0, 0, 0, line);
 	NotifyModified(mh);
 }
 
-void Document::AnnotationSetStyles(int line, const unsigned char *styles) {
+void Document::AnnotationSetStyles(Sci::Line line, const unsigned char *styles) {
 	if (line >= 0 && line < LinesTotal()) {
 		static_cast<LineAnnotation *>(perLineData[ldAnnotation])->SetStyles(line, styles);
 	}
 }
 
-int Document::AnnotationLines(int line) const {
+int Document::AnnotationLines(Sci::Line line) const {
 	return static_cast<LineAnnotation *>(perLineData[ldAnnotation])->Lines(line);
 }
 
 void Document::AnnotationClearAll() {
-	int maxEditorLine = LinesTotal();
-	for (int l=0; l<maxEditorLine; l++)
+	Sci::Line maxEditorLine = LinesTotal();
+	for (Sci::Line l=0; l<maxEditorLine; l++)
 		AnnotationSetText(l, 0);
 	// Free remaining data
 	static_cast<LineAnnotation *>(perLineData[ldAnnotation])->ClearAll();
@@ -2317,7 +2317,7 @@
 	return (WordCharacterClass(ch) == CharClassify::ccWord) && IsASCIIPunctuationCharacter(ch);
 }
 
-int Document::WordPartLeft(int pos) const {
+Sci::Position Document::WordPartLeft(Sci::Position pos) const {
 	if (pos > 0) {
 		pos -= CharacterBefore(pos).widthBytes;
 		CharacterExtracted ceStart = CharacterAfter(pos);
@@ -2367,9 +2367,9 @@
 	return pos;
 }
 
-int Document::WordPartRight(int pos) const {
+Sci::Position Document::WordPartRight(Sci::Position pos) const {
 	CharacterExtracted ceStart = CharacterAfter(pos);
-	const int length = Length();
+	const Sci::Position length = Length();
 	if (IsWordPartSeparator(ceStart.character)) {
 		while (pos < length && IsWordPartSeparator(CharacterAfter(pos).character))
 			pos += CharacterAfter(pos).widthBytes;
@@ -2411,7 +2411,7 @@
 	return (c == '\n' || c == '\r');
 }
 
-int Document::ExtendStyleRange(int pos, int delta, bool singleLine) {
+Sci::Position Document::ExtendStyleRange(Sci::Position pos, int delta, bool singleLine) {
 	int sStart = cb.StyleAt(pos);
 	if (delta < 0) {
 		while (pos > 0 && (cb.StyleAt(pos) == sStart) && (!singleLine || !IsLineEndChar(cb.CharAt(pos))))
@@ -2448,7 +2448,7 @@
 }
 
 // TODO: should be able to extend styled region to find matching brace
-int Document::BraceMatch(int position, int /*maxReStyle*/) {
+Sci::Position Document::BraceMatch(Sci::Position position, Sci::Position /*maxReStyle*/) {
 	char chBrace = CharAt(position);
 	char chSeek = BraceOpposite(chBrace);
 	if (chSeek == '\0')
@@ -2470,7 +2470,7 @@
 			if (depth == 0)
 				return position;
 		}
-		int positionBeforeMove = position;
+		Sci::Position positionBeforeMove = position;
 		position = NextPosition(position, direction);
 		if (position == positionBeforeMove)
 			break;
@@ -2488,11 +2488,11 @@
 	virtual ~BuiltinRegex() {
 	}
 
-	virtual long FindText(Document *doc, int minPos, int maxPos, const char *s,
+	virtual long FindText(Document *doc, Sci::Position minPos, Sci::Position maxPos, const char *s,
                         bool caseSensitive, bool word, bool wordStart, int flags,
-                        int *length);
+                        Sci::Position *length);
 
-	virtual const char *SubstituteByPosition(Document *doc, const char *text, int *length);
+	virtual const char *SubstituteByPosition(Document *doc, const char *text, Sci::Position *length);
 
 private:
 	RESearch search;
@@ -2508,12 +2508,12 @@
 public:
 	const Document *doc;
 	int increment;
-	int startPos;
-	int endPos;
-	int lineRangeStart;
-	int lineRangeEnd;
-	int lineRangeBreak;
-	RESearchRange(const Document *doc_, int minPos, int maxPos) : doc(doc_) {
+	Sci::Position startPos;
+	Sci::Position endPos;
+	Sci::Line lineRangeStart;
+	Sci::Line lineRangeEnd;
+	Sci::Line lineRangeBreak;
+	RESearchRange(const Document *doc_, Sci::Position minPos, Sci::Position maxPos) : doc(doc_) {
 		increment = (minPos <= maxPos) ? 1 : -1;
 
 		// Range endpoints should not be inside DBCS characters, but just in case, move them.
@@ -2537,7 +2537,7 @@
 		}
 		lineRangeBreak = lineRangeEnd + increment;
 	}
-	Range LineRange(int line) const {
+	Range LineRange(Sci::Line line) const {
 		Range range(doc->LineStart(line), doc->LineEnd(line));
 		if (increment == 1) {
 			if (line == lineRangeStart)
@@ -2557,16 +2557,16 @@
 // Define a way for the Regular Expression code to access the document
 class DocumentIndexer : public CharacterIndexer {
 	Document *pdoc;
-	int end;
+	Sci::Position end;
 public:
-	DocumentIndexer(Document *pdoc_, int end_) :
+	DocumentIndexer(Document *pdoc_, Sci::Position end_) :
 		pdoc(pdoc_), end(end_) {
 	}
 
 	virtual ~DocumentIndexer() {
 	}
 
-	virtual char CharAt(int index) {
+	virtual char CharAt(Sci::Position index) {
 		if (index < 0 || index >= end)
 			return 0;
 		else
@@ -2579,8 +2579,8 @@
 class ByteIterator : public std::iterator<std::bidirectional_iterator_tag, char> {
 public:
 	const Document *doc;
-	Position position;
-	ByteIterator(const Document *doc_ = 0, Position position_ = 0) : doc(doc_), position(position_) {
+	Sci::Position position;
+	ByteIterator(const Document *doc_ = 0, Sci::Position position_ = 0) : doc(doc_), position(position_) {
 	}
 	ByteIterator(const ByteIterator &other) NOEXCEPT {
 		doc = other.doc;
@@ -2615,10 +2615,10 @@
 	bool operator!=(const ByteIterator &other) const {
 		return doc != other.doc || position != other.position;
 	}
-	int Pos() const {
+	Sci::Position Pos() const {
 		return position;
 	}
-	int PosRoundUp() const {
+	Sci::Position PosRoundUp() const {
 		return position;
 	}
 };
@@ -2642,14 +2642,14 @@
 class UTF8Iterator : public std::iterator<std::bidirectional_iterator_tag, wchar_t> {
 	// These 3 fields determine the iterator position and are used for comparisons
 	const Document *doc;
-	Position position;
+	Sci::Position position;
 	size_t characterIndex;
 	// Remaining fields are derived from the determining fields so are excluded in comparisons
 	unsigned int lenBytes;
 	size_t lenCharacters;
 	wchar_t buffered[2];
 public:
-	UTF8Iterator(const Document *doc_ = 0, Position position_ = 0) :
+	UTF8Iterator(const Document *doc_ = 0, Sci::Position position_ = 0) :
 		doc(doc_), position(position_), characterIndex(0), lenBytes(0), lenCharacters(0) {
 		buffered[0] = 0;
 		buffered[1] = 0;
@@ -2725,10 +2725,10 @@
 			position != other.position ||
 			characterIndex != other.characterIndex;
 	}
-	int Pos() const {
+	Sci::Position Pos() const {
 		return position;
 	}
-	int PosRoundUp() const {
+	Sci::Position PosRoundUp() const {
 		if (characterIndex)
 			return position + lenBytes;	// Force to end of character
 		else
@@ -2753,9 +2753,9 @@
 
 class UTF8Iterator : public std::iterator<std::bidirectional_iterator_tag, wchar_t> {
 	const Document *doc;
-	Position position;
+	Sci::Position position;
 public:
-	UTF8Iterator(const Document *doc_=0, Position position_=0) : doc(doc_), position(position_) {
+	UTF8Iterator(const Document *doc_=0, Sci::Position position_=0) : doc(doc_), position(position_) {
 	}
 	UTF8Iterator(const UTF8Iterator &other) NOEXCEPT {
 		doc = other.doc;
@@ -2791,17 +2791,17 @@
 	bool operator!=(const UTF8Iterator &other) const {
 		return doc != other.doc || position != other.position;
 	}
-	int Pos() const {
+	Sci::Position Pos() const {
 		return position;
 	}
-	int PosRoundUp() const {
+	Sci::Position PosRoundUp() const {
 		return position;
 	}
 };
 
 #endif
 
-std::regex_constants::match_flag_type MatchFlags(const Document *doc, int startPos, int endPos) {
+std::regex_constants::match_flag_type MatchFlags(const Document *doc, Sci::Position startPos, Sci::Position endPos) {
 	std::regex_constants::match_flag_type flagsMatch = std::regex_constants::match_default;
 	if (!doc->IsLineStartPosition(startPos))
 		flagsMatch |= std::regex_constants::match_not_bol;
@@ -2824,7 +2824,7 @@
 	//	matched = std::regex_search(uiStart, uiEnd, match, regexp, flagsMatch);
 
 	// Line by line.
-	for (int line = resr.lineRangeStart; line != resr.lineRangeBreak; line += resr.increment) {
+	for (Sci::Line line = resr.lineRangeStart; line != resr.lineRangeBreak; line += resr.increment) {
 		const Range lineRange = resr.LineRange(line);
 		Iterator itStart(doc, lineRange.start);
 		Iterator itEnd(doc, lineRange.end);
@@ -2865,8 +2865,8 @@
 	return matched;
 }
 
-long Cxx11RegexFindText(Document *doc, int minPos, int maxPos, const char *s,
-	bool caseSensitive, int *length, RESearch &search) {
+Sci::Position Cxx11RegexFindText(Document *doc, Sci::Position minPos, Sci::Position maxPos, const char *s,
+	bool caseSensitive, Sci::Position *length, RESearch &search) {
 	const RESearchRange resr(doc, minPos, maxPos);
 	try {
 		//ElapsedTime et;
@@ -2906,7 +2906,7 @@
 			matched = MatchOnLines<ByteIterator>(doc, regexp, resr, search);
 		}
 
-		int posMatch = -1;
+		Sci::Position posMatch = -1;
 		if (matched) {
 			posMatch = search.bopat[0];
 			*length = search.eopat[0] - search.bopat[0];
@@ -2930,9 +2930,9 @@
 
 }
 
-long BuiltinRegex::FindText(Document *doc, int minPos, int maxPos, const char *s,
+long BuiltinRegex::FindText(Document *doc, Sci::Position minPos, Sci::Position maxPos, const char *s,
                         bool caseSensitive, bool, bool, int flags,
-                        int *length) {
+                        Sci::Position *length) {
 
 #ifndef NO_CXX11_REGEX
 	if (flags & SCFIND_CXX11REGEX) {
@@ -2953,13 +2953,13 @@
 	// Replace first '.' with '-' in each property file variable reference:
 	//     Search: \$(\([A-Za-z0-9_-]+\)\.\([A-Za-z0-9_.]+\))
 	//     Replace: $(\1-\2)
-	int pos = -1;
-	int lenRet = 0;
+	Sci::Position pos = -1;
+	Sci::Position lenRet = 0;
 	const char searchEnd = s[*length - 1];
 	const char searchEndPrev = (*length > 1) ? s[*length - 2] : '\0';
-	for (int line = resr.lineRangeStart; line != resr.lineRangeBreak; line += resr.increment) {
-		int startOfLine = doc->LineStart(line);
-		int endOfLine = doc->LineEnd(line);
+	for (Sci::Line line = resr.lineRangeStart; line != resr.lineRangeBreak; line += resr.increment) {
+		Sci::Position startOfLine = doc->LineStart(line);
+		Sci::Position endOfLine = doc->LineEnd(line);
 		if (resr.increment == 1) {
 			if (line == resr.lineRangeStart) {
 				if ((resr.startPos != startOfLine) && (s[0] == '^'))
@@ -3014,7 +3014,7 @@
 	return pos;
 }
 
-const char *BuiltinRegex::SubstituteByPosition(Document *doc, const char *text, int *length) {
+const char *BuiltinRegex::SubstituteByPosition(Document *doc, const char *text, Sci::Position *length) {
 	substituted.clear();
 	DocumentIndexer di(doc, doc->Length());
 	search.GrabMatches(di);
@@ -3022,7 +3022,7 @@
 		if (text[j] == '\\') {
 			if (text[j + 1] >= '0' && text[j + 1] <= '9') {
 				unsigned int patNum = text[j + 1] - '0';
-				unsigned int len = search.eopat[patNum] - search.bopat[patNum];
+				Sci::Position len = search.eopat[patNum] - search.bopat[patNum];
 				if (!search.pat[patNum].empty())	// Will be null if try for a match that did not occur
 					substituted.append(search.pat[patNum].c_str(), len);
 				j++;
diff -r 1788f6795302 -r a0f26eaf474d src/Document.h
--- a/src/Document.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Document.h	Fri Mar 31 18:19:38 2017 +1100
@@ -12,13 +12,6 @@
 namespace Scintilla {
 #endif
 
-/**
- * A Position is a position within a document between two characters or at the beginning or end.
- * Sometimes used as a character index where it identifies the character after the position.
- */
-typedef int Position;
-const Position invalidPosition = -1;
-
 enum EncodingFamily { efEightBit, efUnicode, efDBCS };
 
 /**
@@ -29,13 +22,13 @@
  */
 class Range {
 public:
-	Position start;
-	Position end;
+	Sci::Position start;
+	Sci::Position end;
 
-	explicit Range(Position pos=0) :
+	explicit Range(Sci::Position pos=0) :
 		start(pos), end(pos) {
 	}
-	Range(Position start_, Position end_) :
+	Range(Sci::Position start_, Sci::Position end_) :
 		start(start_), end(end_) {
 	}
 
@@ -44,19 +37,19 @@
 	}
 
 	bool Valid() const {
-		return (start != invalidPosition) && (end != invalidPosition);
+		return (start != Sci::invalidPosition) && (end != Sci::invalidPosition);
 	}
 
-	Position First() const {
+	Sci::Position First() const {
 		return (start <= end) ? start : end;
 	}
 
-	Position Last() const {
+	Sci::Position Last() const {
 		return (start > end) ? start : end;
 	}
 
 	// Is the position within the range?
-	bool Contains(Position pos) const {
+	bool Contains(Sci::Position pos) const {
 		if (start < end) {
 			return (pos >= start && pos <= end);
 		} else {
@@ -65,7 +58,7 @@
 	}
 
 	// Is the character after pos within the range?
-	bool ContainsCharacter(Position pos) const {
+	bool ContainsCharacter(Sci::Position pos) const {
 		if (start < end) {
 			return (pos >= start && pos < end);
 		} else {
@@ -97,11 +90,11 @@
 public:
 	virtual ~RegexSearchBase() {}
 
-	virtual long FindText(Document *doc, int minPos, int maxPos, const char *s,
-                        bool caseSensitive, bool word, bool wordStart, int flags, int *length) = 0;
+	virtual long FindText(Document *doc, Sci::Position minPos, Sci::Position maxPos, const char *s,
+                        bool caseSensitive, bool word, bool wordStart, int flags, Sci::Position *length) = 0;
 
 	///@return String with the substitutions, must remain valid until the next call or destruction
-	virtual const char *SubstituteByPosition(Document *doc, const char *text, int *length) = 0;
+	virtual const char *SubstituteByPosition(Document *doc, const char *text, Sci::Position *length) = 0;
 };
 
 /// Factory function for RegexSearchBase
@@ -142,30 +135,30 @@
 		firstChangeableLineAfter = -1;
 	}
 
-	bool NeedsDrawing(int line) const {
+	bool NeedsDrawing(Sci::Line line) const {
 		return isEnabled && (line <= firstChangeableLineBefore || line >= firstChangeableLineAfter);
 	}
 
-	bool IsFoldBlockHighlighted(int line) const {
+	bool IsFoldBlockHighlighted(Sci::Line line) const {
 		return isEnabled && beginFoldBlock != -1 && beginFoldBlock <= line && line <= endFoldBlock;
 	}
 
-	bool IsHeadOfFoldBlock(int line) const {
+	bool IsHeadOfFoldBlock(Sci::Line line) const {
 		return beginFoldBlock == line && line < endFoldBlock;
 	}
 
-	bool IsBodyOfFoldBlock(int line) const {
+	bool IsBodyOfFoldBlock(Sci::Line line) const {
 		return beginFoldBlock != -1 && beginFoldBlock < line && line < endFoldBlock;
 	}
 
-	bool IsTailOfFoldBlock(int line) const {
+	bool IsTailOfFoldBlock(Sci::Line line) const {
 		return beginFoldBlock != -1 && beginFoldBlock < line && line == endFoldBlock;
 	}
 
-	int beginFoldBlock;	// Begin of current fold block
-	int endFoldBlock;	// End of current fold block
-	int firstChangeableLineBefore;	// First line that triggers repaint before starting line that determined current fold block
-	int firstChangeableLineAfter;	// First line that triggers repaint after starting line that determined current fold block
+	Sci::Line beginFoldBlock;	// Begin of current fold block
+	Sci::Line endFoldBlock;	// End of current fold block
+	Sci::Line firstChangeableLineBefore;	// First line that triggers repaint before starting line that determined current fold block
+	Sci::Line firstChangeableLineAfter;	// First line that triggers repaint after starting line that determined current fold block
 	bool isEnabled;
 };
 
@@ -185,7 +178,7 @@
 	}
 	virtual ~LexInterface() {
 	}
-	void Colourise(int start, int end);
+	void Colourise(Sci::Position start, Sci::Position end);
 	int LineEndTypesSupported();
 	bool UseContainerLexing() const {
 		return instance == 0;
@@ -218,7 +211,7 @@
 	CellBuffer cb;
 	CharClassify charClass;
 	CaseFolder *pcf;
-	int endStyled;
+	Sci::Position endStyled;
 	int styleClock;
 	int enteredModification;
 	int enteredStyling;
@@ -278,8 +271,8 @@
 	int GetLineEndTypesAllowed() const { return cb.GetLineEndTypes(); }
 	bool SetLineEndTypesAllowed(int lineEndBitSet_);
 	int GetLineEndTypesActive() const { return cb.GetLineEndTypes(); }
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
 	int SCI_METHOD Version() const {
 		return dvLineEnd;
@@ -288,18 +281,18 @@
 	void SCI_METHOD SetErrorStatus(int status);
 
 	Sci_Position SCI_METHOD LineFromPosition(Sci_Position pos) const;
-	int ClampPositionIntoDocument(int pos) const;
-	bool ContainsLineEnd(const char *s, int length) const { return cb.ContainsLineEnd(s, length); }
-	bool IsCrLf(int pos) const;
-	int LenChar(int pos);
-	bool InGoodUTF8(int pos, int &start, int &end) const;
-	int MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd=true) const;
-	int NextPosition(int pos, int moveDir) const;
-	bool NextCharacter(int &pos, int moveDir) const;	// Returns true if pos changed
-	Document::CharacterExtracted CharacterAfter(int position) const;
-	Document::CharacterExtracted CharacterBefore(int position) const;
+	Sci::Position ClampPositionIntoDocument(Sci::Position pos) const;
+	bool ContainsLineEnd(const char *s, Sci::Position length) const { return cb.ContainsLineEnd(s, length); }
+	bool IsCrLf(Sci::Position pos) const;
+	int LenChar(Sci::Position pos);
+	bool InGoodUTF8(Sci::Position pos, Sci::Position &start, Sci::Position &end) const;
+	Sci::Position MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd=true) const;
+	Sci::Position NextPosition(Sci::Position pos, int moveDir) const;
+	bool NextCharacter(Sci::Position &pos, int moveDir) const;	// Returns true if pos changed
+	Document::CharacterExtracted CharacterAfter(Sci::Position position) const;
+	Document::CharacterExtracted CharacterBefore(Sci::Position position) const;
 	Sci_Position SCI_METHOD GetRelativePosition(Sci_Position positionStart, Sci_Position characterOffset) const;
-	int GetRelativePositionUTF16(int positionStart, int characterOffset) const;
+	Sci::Position GetRelativePositionUTF16(Sci::Position positionStart, Sci::Position characterOffset) const;
 	int SCI_METHOD GetCharacterAndWidth(Sci_Position position, Sci_Position *pWidth) const;
 	int SCI_METHOD CodePage() const;
 	bool SCI_METHOD IsDBCSLeadByte(char ch) const;
@@ -307,15 +300,15 @@
 	EncodingFamily CodePageFamily() const;
 
 	// Gateways to modifying document
-	void ModifiedAt(int pos);
+	void ModifiedAt(Sci::Position pos);
 	void CheckReadOnly();
-	bool DeleteChars(int pos, int len);
-	int InsertString(int position, const char *s, int insertLength);
-	void ChangeInsertion(const char *s, int length);
+	bool DeleteChars(Sci::Position pos, Sci::Position len);
+	Sci::Position InsertString(Sci::Position position, const char *s, Sci::Position insertLength);
+	void ChangeInsertion(const char *s, Sci::Position length);
 	int SCI_METHOD AddData(char *data, Sci_Position length);
 	void * SCI_METHOD ConvertToDocument();
-	int Undo();
-	int Redo();
+	Sci::Position Undo();
+	Sci::Position Redo();
 	bool CanUndo() const { return cb.CanUndo(); }
 	bool CanRedo() const { return cb.CanRedo(); }
 	void DeleteUndoHistory() { cb.DeleteUndoHistory(); }
@@ -325,7 +318,7 @@
 	bool IsCollectingUndo() const { return cb.IsCollectingUndo(); }
 	void BeginUndoAction() { cb.BeginUndoAction(); }
 	void EndUndoAction() { cb.EndUndoAction(); }
-	void AddUndoAction(int token, bool mayCoalesce) { cb.AddUndoAction(token, mayCoalesce); }
+	void AddUndoAction(Sci::Position token, bool mayCoalesce) { cb.AddUndoAction(token, mayCoalesce); }
 	void SetSavePoint();
 	bool IsSavePoint() const { return cb.IsSavePoint(); }
 
@@ -335,76 +328,76 @@
 	bool TentativeActive() const { return cb.TentativeActive(); }
 
 	const char * SCI_METHOD BufferPointer() { return cb.BufferPointer(); }
-	const char *RangePointer(int position, int rangeLength) { return cb.RangePointer(position, rangeLength); }
-	int GapPosition() const { return cb.GapPosition(); }
+	const char *RangePointer(Sci::Position position, Sci::Position rangeLength) { return cb.RangePointer(position, rangeLength); }
+	Sci::Position GapPosition() const { return cb.GapPosition(); }
 
 	int SCI_METHOD GetLineIndentation(Sci_Position line);
-	int SetLineIndentation(int line, int indent);
-	int GetLineIndentPosition(int line) const;
-	int GetColumn(int position);
-	int CountCharacters(int startPos, int endPos) const;
-	int CountUTF16(int startPos, int endPos) const;
-	int FindColumn(int line, int column);
-	void Indent(bool forwards, int lineBottom, int lineTop);
+	Sci::Position SetLineIndentation(Sci::Line line, Sci::Position indent);
+	Sci::Position GetLineIndentPosition(Sci::Line line) const;
+	Sci::Position GetColumn(Sci::Position position);
+	Sci::Position CountCharacters(Sci::Position startPos, Sci::Position endPos) const;
+	Sci::Position CountUTF16(Sci::Position startPos, Sci::Position endPos) const;
+	Sci::Position FindColumn(Sci::Line line, Sci::Position column);
+	void Indent(bool forwards, Sci::Line lineBottom, Sci::Line lineTop);
 	static std::string TransformLineEnds(const char *s, size_t len, int eolModeWanted);
 	void ConvertLineEnds(int eolModeSet);
 	void SetReadOnly(bool set) { cb.SetReadOnly(set); }
 	bool IsReadOnly() const { return cb.IsReadOnly(); }
 
-	void DelChar(int pos);
-	void DelCharBack(int pos);
+	void DelChar(Sci::Position pos);
+	void DelCharBack(Sci::Position pos);
 
-	char CharAt(int position) const { return cb.CharAt(position); }
+	char CharAt(Sci::Position position) const { return cb.CharAt(position); }
 	void SCI_METHOD GetCharRange(char *buffer, Sci_Position position, Sci_Position lengthRetrieve) const {
 		cb.GetCharRange(buffer, position, lengthRetrieve);
 	}
 	char SCI_METHOD StyleAt(Sci_Position position) const { return cb.StyleAt(position); }
 	int StyleIndexAt(Sci_Position position) const { return static_cast<unsigned char>(cb.StyleAt(position)); }
-	void GetStyleRange(unsigned char *buffer, int position, int lengthRetrieve) const {
+	void GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const {
 		cb.GetStyleRange(buffer, position, lengthRetrieve);
 	}
-	int GetMark(int line);
-	int MarkerNext(int lineStart, int mask) const;
-	int AddMark(int line, int markerNum);
-	void AddMarkSet(int line, int valueSet);
-	void DeleteMark(int line, int markerNum);
+	int GetMark(Sci::Line line);
+	Sci::Line MarkerNext(Sci::Line lineStart, int mask) const;
+	int AddMark(Sci::Line line, int markerNum);
+	void AddMarkSet(Sci::Line line, int valueSet);
+	void DeleteMark(Sci::Line line, int markerNum);
 	void DeleteMarkFromHandle(int markerHandle);
 	void DeleteAllMarks(int markerNum);
-	int LineFromHandle(int markerHandle);
+	Sci::Line LineFromHandle(int markerHandle);
 	Sci_Position SCI_METHOD LineStart(Sci_Position line) const;
-	bool IsLineStartPosition(int position) const;
+	bool IsLineStartPosition(Sci::Position position) const;
 	Sci_Position SCI_METHOD LineEnd(Sci_Position line) const;
-	int LineEndPosition(int position) const;
-	bool IsLineEndPosition(int position) const;
-	bool IsPositionInLineEnd(int position) const;
-	int VCHomePosition(int position) const;
+	Sci::Position LineEndPosition(Sci::Position position) const;
+	bool IsLineEndPosition(Sci::Position position) const;
+	bool IsPositionInLineEnd(Sci::Position position) const;
+	Sci::Position VCHomePosition(Sci::Position position) const;
 
 	int SCI_METHOD SetLevel(Sci_Position line, int level);
 	int SCI_METHOD GetLevel(Sci_Position line) const;
 	void ClearLevels();
-	int GetLastChild(int lineParent, int level=-1, int lastLine=-1);
-	int GetFoldParent(int line) const;
-	void GetHighlightDelimiters(HighlightDelimiter &hDelimiter, int line, int lastLine);
+	Sci::Line GetLastChild(Sci::Line lineParent, int level=-1, Sci::Line lastLine=-1);
+	Sci::Line GetFoldParent(Sci::Line line) const;
+	void GetHighlightDelimiters(HighlightDelimiter &hDelimiter, Sci::Line line, Sci::Line lastLine);
 
 	void Indent(bool forwards);
-	int ExtendWordSelect(int pos, int delta, bool onlyWordCharacters=false) const;
-	int NextWordStart(int pos, int delta) const;
-	int NextWordEnd(int pos, int delta) const;
+	Sci::Position ExtendWordSelect(Sci::Position pos, int delta, bool onlyWordCharacters=false) const;
+	Sci::Position NextWordStart(Sci::Position pos, int delta) const;
+	Sci::Position NextWordEnd(Sci::Position pos, int delta) const;
 	Sci_Position SCI_METHOD Length() const { return cb.Length(); }
-	void Allocate(int newSize) { cb.Allocate(newSize); }
+	void Allocate(Sci::Position newSize) { cb.Allocate(newSize); }
 
-	CharacterExtracted ExtractCharacter(int position) const;
+	CharacterExtracted ExtractCharacter(Sci::Position position) const;
 
-	bool IsWordStartAt(int pos) const;
-	bool IsWordEndAt(int pos) const;
-	bool IsWordAt(int start, int end) const;
+	bool IsWordStartAt(Sci::Position pos) const;
+	bool IsWordEndAt(Sci::Position pos) const;
+	bool IsWordAt(Sci::Position start, Sci::Position end) const;
 
-	bool MatchesWordOptions(bool word, bool wordStart, int pos, int length) const;
+	bool MatchesWordOptions(bool word, bool wordStart, Sci::Position pos, Sci::Position length) const;
 	bool HasCaseFolder() const;
 	void SetCaseFolder(CaseFolder *pcf_);
-	long FindText(int minPos, int maxPos, const char *search, int flags, int *length);
-	const char *SubstituteByPosition(const char *text, int *length);
-	int LinesTotal() const;
+	long FindText(Sci::Position minPos, Sci::Position maxPos, const char *search, int flags, Sci::Position *length);
+	const char *SubstituteByPosition(const char *text, Sci::Position *length);
+	Sci::Line LinesTotal() const;
 
 	void SetDefaultCharClasses(bool includeWordClass);
 	void SetCharClasses(const unsigned char *chars, CharClassify::cc newCharClass);
@@ -412,9 +405,9 @@
 	void SCI_METHOD StartStyling(Sci_Position position, char mask);
 	bool SCI_METHOD SetStyleFor(Sci_Position length, char style);
 	bool SCI_METHOD SetStyles(Sci_Position length, const char *styles);
-	int GetEndStyled() const { return endStyled; }
-	void EnsureStyledTo(int pos);
-	void StyleToAdjustingLineDuration(int pos);
+	Sci::Position GetEndStyled() const { return endStyled; }
+	void EnsureStyledTo(Sci::Position pos);
+	void StyleToAdjustingLineDuration(Sci::Position pos);
 	void LexerChanged();
 	int GetStyleClock() const { return styleClock; }
 	void IncrementStyleClock();
@@ -425,20 +418,20 @@
 
 	int SCI_METHOD SetLineState(Sci_Position line, int state);
 	int SCI_METHOD GetLineState(Sci_Position line) const;
-	int GetMaxLineState();
+	Sci::Line GetMaxLineState();
 	void SCI_METHOD ChangeLexerState(Sci_Position start, Sci_Position end);
 
-	StyledText MarginStyledText(int line) const;
-	void MarginSetStyle(int line, int style);
-	void MarginSetStyles(int line, const unsigned char *styles);
-	void MarginSetText(int line, const char *text);
+	StyledText MarginStyledText(Sci::Line line) const;
+	void MarginSetStyle(Sci::Line line, int style);
+	void MarginSetStyles(Sci::Line line, const unsigned char *styles);
+	void MarginSetText(Sci::Line line, const char *text);
 	void MarginClearAll();
 
-	StyledText AnnotationStyledText(int line) const;
-	void AnnotationSetText(int line, const char *text);
-	void AnnotationSetStyle(int line, int style);
-	void AnnotationSetStyles(int line, const unsigned char *styles);
-	int AnnotationLines(int line) const;
+	StyledText AnnotationStyledText(Sci::Line line) const;
+	void AnnotationSetText(Sci::Line line, const char *text);
+	void AnnotationSetStyle(Sci::Line line, int style);
+	void AnnotationSetStyles(Sci::Line line, const unsigned char *styles);
+	int AnnotationLines(Sci::Line line) const;
 	void AnnotationClearAll();
 
 	bool AddWatcher(DocWatcher *watcher, void *userData);
@@ -447,14 +440,14 @@
 	bool IsASCIIWordByte(unsigned char ch) const;
 	CharClassify::cc WordCharacterClass(unsigned int ch) const;
 	bool IsWordPartSeparator(unsigned int ch) const;
-	int WordPartLeft(int pos) const;
-	int WordPartRight(int pos) const;
-	int ExtendStyleRange(int pos, int delta, bool singleLine = false);
-	bool IsWhiteLine(int line) const;
-	int ParaUp(int pos) const;
-	int ParaDown(int pos) const;
+	Sci::Position WordPartLeft(Sci::Position pos) const;
+	Sci::Position WordPartRight(Sci::Position pos) const;
+	Sci::Position ExtendStyleRange(Sci::Position pos, int delta, bool singleLine = false);
+	bool IsWhiteLine(Sci::Line line) const;
+	Sci::Position ParaUp(Sci::Position pos) const;
+	Sci::Position ParaDown(Sci::Position pos) const;
 	int IndentSize() const { return actualIndentInChars; }
-	int BraceMatch(int position, int maxReStyle);
+	Sci::Position BraceMatch(Sci::Position position, Sci::Position maxReStyle);
 
 private:
 	void NotifyModifyAttempt();
@@ -491,18 +484,18 @@
 class DocModification {
 public:
 	int modificationType;
-	int position;
-	int length;
-	int linesAdded;	/**< Negative if lines deleted. */
+	Sci::Position position;
+	Sci::Position length;
+	Sci::Line linesAdded;	/**< Negative if lines deleted. */
 	const char *text;	/**< Only valid for changes to text, not for changes to style. */
-	int line;
+	Sci::Line line;
 	int foldLevelNow;
 	int foldLevelPrev;
-	int annotationLinesAdded;
-	int token;
+	Sci::Line annotationLinesAdded;
+	Sci::Position token;
 
-	DocModification(int modificationType_, int position_=0, int length_=0,
-		int linesAdded_=0, const char *text_=0, int line_=0) :
+	DocModification(int modificationType_, Sci::Position position_=0, Sci::Position length_=0,
+		Sci::Line linesAdded_=0, const char *text_=0, Sci::Line line_=0) :
 		modificationType(modificationType_),
 		position(position_),
 		length(length_),
@@ -514,7 +507,7 @@
 		annotationLinesAdded(0),
 		token(0) {}
 
-	DocModification(int modificationType_, const Action &act, int linesAdded_=0) :
+	DocModification(int modificationType_, const Action &act, Sci::Line linesAdded_=0) :
 		modificationType(modificationType_),
 		position(act.position),
 		length(act.lenData),
@@ -539,7 +532,7 @@
 	virtual void NotifySavePoint(Document *doc, void *userData, bool atSavePoint) = 0;
 	virtual void NotifyModified(Document *doc, DocModification mh, void *userData) = 0;
 	virtual void NotifyDeleted(Document *doc, void *userData) = 0;
-	virtual void NotifyStyleNeeded(Document *doc, void *userData, int endPos) = 0;
+	virtual void NotifyStyleNeeded(Document *doc, void *userData, Sci::Position endPos) = 0;
 	virtual void NotifyLexerChanged(Document *doc, void *userData) = 0;
 	virtual void NotifyErrorOccurred(Document *doc, void *userData, int status) = 0;
 };
diff -r 1788f6795302 -r a0f26eaf474d src/EditModel.cxx
--- a/src/EditModel.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/EditModel.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -57,17 +57,17 @@
 	inOverstrike = false;
 	xOffset = 0;
 	trackLineWidth = false;
-	posDrag = SelectionPosition(invalidPosition);
-	braces[0] = invalidPosition;
-	braces[1] = invalidPosition;
+	posDrag = SelectionPosition(Sci::invalidPosition);
+	braces[0] = Sci::invalidPosition;
+	braces[1] = Sci::invalidPosition;
 	bracesMatchStyle = STYLE_BRACEBAD;
 	highlightGuideColumn = 0;
 	primarySelection = true;
 	imeInteraction = imeWindowed;
 	foldFlags = 0;
 	foldDisplayTextStyle = SC_FOLDDISPLAYTEXT_HIDDEN;
-	hotspot = Range(invalidPosition);
-	hoverIndicatorPos = invalidPosition;
+	hotspot = Range(Sci::invalidPosition);
+	hoverIndicatorPos = Sci::invalidPosition;
 	wrapWidth = LineLayout::wrapWidthInfinite;
 	pdoc = new Document();
 	pdoc->AddRef();
diff -r 1788f6795302 -r a0f26eaf474d src/EditModel.h
--- a/src/EditModel.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/EditModel.h	Fri Mar 31 18:19:38 2017 +1100
@@ -36,7 +36,7 @@
 	SpecialRepresentations reprs;
 	Caret caret;
 	SelectionPosition posDrag;
-	Position braces[2];
+	Sci::Position braces[2];
 	int bracesMatchStyle;
 	int highlightGuideColumn;
 	Selection sel;
@@ -49,7 +49,7 @@
 	ContractionState cs;
 	// Hotspot support
 	Range hotspot;
-	int hoverIndicatorPos;
+	Sci::Position hoverIndicatorPos;
 
 	// Wrapping support
 	int wrapWidth;
@@ -58,9 +58,9 @@
 
 	EditModel();
 	virtual ~EditModel();
-	virtual int TopLineOfMain() const = 0;
+	virtual Sci::Line TopLineOfMain() const = 0;
 	virtual Point GetVisibleOriginInMain() const = 0;
-	virtual int LinesOnScreen() const = 0;
+	virtual Sci::Line LinesOnScreen() const = 0;
 	virtual Range GetHotSpotRange() const = 0;
 };
 
diff -r 1788f6795302 -r a0f26eaf474d src/EditView.cxx
--- a/src/EditView.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/EditView.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -222,19 +222,19 @@
 	ldTabstops = 0;
 }
 
-XYPOSITION EditView::NextTabstopPos(int line, XYPOSITION x, XYPOSITION tabWidth) const {
+XYPOSITION EditView::NextTabstopPos(Sci::Line line, XYPOSITION x, XYPOSITION tabWidth) const {
 	int next = GetNextTabstop(line, static_cast<int>(x + tabWidthMinimumPixels));
 	if (next > 0)
 		return static_cast<XYPOSITION>(next);
 	return (static_cast<int>((x + tabWidthMinimumPixels) / tabWidth) + 1) * tabWidth;
 }
 
-bool EditView::ClearTabstops(int line) {
+bool EditView::ClearTabstops(Sci::Line line) {
 	LineTabstops *lt = static_cast<LineTabstops *>(ldTabstops);
 	return lt && lt->ClearTabstops(line);
 }
 
-bool EditView::AddTabstop(int line, int x) {
+bool EditView::AddTabstop(Sci::Line line, int x) {
 	if (!ldTabstops) {
 		ldTabstops = new LineTabstops();
 	}
@@ -242,7 +242,7 @@
 	return lt && lt->AddTabstop(line, x);
 }
 
-int EditView::GetNextTabstop(int line, int x) const {
+int EditView::GetNextTabstop(Sci::Line line, int x) const {
 	LineTabstops *lt = static_cast<LineTabstops *>(ldTabstops);
 	if (lt) {
 		return lt->GetNextTabstop(line, x);
@@ -251,14 +251,14 @@
 	}
 }
 
-void EditView::LinesAddedOrRemoved(int lineOfPos, int linesAdded) {
+void EditView::LinesAddedOrRemoved(Sci::Line lineOfPos, Sci::Line linesAdded) {
 	if (ldTabstops) {
 		if (linesAdded > 0) {
-			for (int line = lineOfPos; line < lineOfPos + linesAdded; line++) {
+			for (Sci::Line line = lineOfPos; line < lineOfPos + linesAdded; line++) {
 				ldTabstops->InsertLine(line);
 			}
 		} else {
-			for (int line = (lineOfPos + -linesAdded) - 1; line >= lineOfPos; line--) {
+			for (Sci::Line line = (lineOfPos + -linesAdded) - 1; line >= lineOfPos; line--) {
 				ldTabstops->RemoveLine(line);
 			}
 		}
@@ -345,11 +345,11 @@
 	}
 }
 
-LineLayout *EditView::RetrieveLineLayout(int lineNumber, const EditModel &model) {
-	int posLineStart = model.pdoc->LineStart(lineNumber);
-	int posLineEnd = model.pdoc->LineStart(lineNumber + 1);
+LineLayout *EditView::RetrieveLineLayout(Sci::Line lineNumber, const EditModel &model) {
+	Sci::Position posLineStart = model.pdoc->LineStart(lineNumber);
+	Sci::Position posLineEnd = model.pdoc->LineStart(lineNumber + 1);
 	PLATFORM_ASSERT(posLineEnd >= posLineStart);
-	int lineCaret = model.pdoc->LineFromPosition(model.sel.MainCaret());
+	Sci::Line lineCaret = model.pdoc->LineFromPosition(model.sel.MainCaret());
 	return llc.Retrieve(lineNumber, lineCaret,
 		posLineEnd - posLineStart, model.pdoc->GetStyleClock(),
 		model.LinesOnScreen() + 1, model.pdoc->LinesTotal());
@@ -360,20 +360,20 @@
 * Copy the given @a line and its styles from the document into local arrays.
 * Also determine the x position at which each character starts.
 */
-void EditView::LayoutLine(const EditModel &model, int line, Surface *surface, const ViewStyle &vstyle, LineLayout *ll, int width) {
+void EditView::LayoutLine(const EditModel &model, Sci::Line line, Surface *surface, const ViewStyle &vstyle, LineLayout *ll, int width) {
 	if (!ll)
 		return;
 
 	PLATFORM_ASSERT(line < model.pdoc->LinesTotal());
 	PLATFORM_ASSERT(ll->chars != NULL);
-	int posLineStart = model.pdoc->LineStart(line);
-	int posLineEnd = model.pdoc->LineStart(line + 1);
+	Sci::Position posLineStart = model.pdoc->LineStart(line);
+	Sci::Position posLineEnd = model.pdoc->LineStart(line + 1);
 	// If the line is very long, limit the treatment to a length that should fit in the viewport
 	if (posLineEnd >(posLineStart + ll->maxLineLength)) {
 		posLineEnd = posLineStart + ll->maxLineLength;
 	}
 	if (ll->validity == LineLayout::llCheckTextAndStyle) {
-		int lineLength = posLineEnd - posLineStart;
+		Sci::Position lineLength = posLineEnd - posLineStart;
 		if (!vstyle.viewEOL) {
 			lineLength = model.pdoc->LineEnd(line) - posLineStart;
 		}
@@ -384,7 +384,7 @@
 			int styleByte = 0;
 			int numCharsInLine = 0;
 			while (numCharsInLine < lineLength) {
-				int charInDoc = numCharsInLine + posLineStart;
+				Sci::Position charInDoc = numCharsInLine + posLineStart;
 				char chDoc = model.pdoc->CharAt(charInDoc);
 				styleByte = model.pdoc->StyleIndexAt(charInDoc);
 				allSame = allSame &&
@@ -436,7 +436,7 @@
 		model.pdoc->GetStyleRange(ll->styles, posLineStart, lineLength);
 		int numCharsBeforeEOL = model.pdoc->LineEnd(line) - posLineStart;
 		const int numCharsInLine = (vstyle.viewEOL) ? lineLength : numCharsBeforeEOL;
-		for (int styleInLine = 0; styleInLine < numCharsInLine; styleInLine++) {
+		for (Sci::Position styleInLine = 0; styleInLine < numCharsInLine; styleInLine++) {
 			const unsigned char styleByte = ll->styles[styleInLine];
 			ll->styles[styleInLine] = styleByte;
 		}
@@ -503,7 +503,7 @@
 				lastSegItalics = (!ts.representation) && ((ll->chars[ts.end() - 1] != ' ') && vstyle.styles[ll->styles[ts.start]].italic);
 			}
 
-			for (int posToIncrease = ts.start + 1; posToIncrease <= ts.end(); posToIncrease++) {
+			for (Sci::Position posToIncrease = ts.start + 1; posToIncrease <= ts.end(); posToIncrease++) {
 				ll->positions[posToIncrease] += ll->positions[ts.start];
 			}
 		}
@@ -600,19 +600,19 @@
 	}
 }
 
-Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine,
+Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, Sci::Line topLine,
 				     const ViewStyle &vs, PointEnd pe) {
 	Point pt;
 	if (pos.Position() == INVALID_POSITION)
 		return pt;
-	int lineDoc = model.pdoc->LineFromPosition(pos.Position());
-	int posLineStart = model.pdoc->LineStart(lineDoc);
+	Sci::Line lineDoc = model.pdoc->LineFromPosition(pos.Position());
+	Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
 	if ((pe & peLineEnd) && (lineDoc > 0) && (pos.Position() == posLineStart)) {
 		// Want point at end of first line
 		lineDoc--;
 		posLineStart = model.pdoc->LineStart(lineDoc);
 	}
-	const int lineVisible = model.cs.DisplayFromDoc(lineDoc);
+	const Sci::Line lineVisible = model.cs.DisplayFromDoc(lineDoc);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
@@ -625,17 +625,17 @@
 	return pt;
 }
 
-Range EditView::RangeDisplayLine(Surface *surface, const EditModel &model, int lineVisible, const ViewStyle &vs) {
+Range EditView::RangeDisplayLine(Surface *surface, const EditModel &model, Sci::Line lineVisible, const ViewStyle &vs) {
 	Range rangeSubLine = Range(0,0);
 	if (lineVisible < 0) {
 		return rangeSubLine;
 	}
-	const int lineDoc = model.cs.DocFromDisplay(lineVisible);
-	const int positionLineStart = model.pdoc->LineStart(lineDoc);
+	const Sci::Line lineDoc = model.cs.DocFromDisplay(lineVisible);
+	const Sci::Position positionLineStart = model.pdoc->LineStart(lineDoc);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
-		const int lineStartSet = model.cs.DisplayFromDoc(lineDoc);
+		const Sci::Line lineStartSet = model.cs.DisplayFromDoc(lineDoc);
 		const int subLine = lineVisible - lineStartSet;
 		if (subLine < ll->lines) {
 			rangeSubLine = ll->SubLineRange(subLine);
@@ -652,26 +652,26 @@
 
 SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid, bool charPosition, bool virtualSpace, const ViewStyle &vs) {
 	pt.x = pt.x - vs.textStart;
-	int visibleLine = static_cast<int>(floor(pt.y / vs.lineHeight));
+	Sci::Line visibleLine = static_cast<int>(floor(pt.y / vs.lineHeight));
 	if (!canReturnInvalid && (visibleLine < 0))
 		visibleLine = 0;
-	const int lineDoc = model.cs.DocFromDisplay(visibleLine);
+	const Sci::Line lineDoc = model.cs.DocFromDisplay(visibleLine);
 	if (canReturnInvalid && (lineDoc < 0))
 		return SelectionPosition(INVALID_POSITION);
 	if (lineDoc >= model.pdoc->LinesTotal())
 		return SelectionPosition(canReturnInvalid ? INVALID_POSITION : model.pdoc->Length());
-	const int posLineStart = model.pdoc->LineStart(lineDoc);
+	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
-		const int lineStartSet = model.cs.DisplayFromDoc(lineDoc);
+		const Sci::Line lineStartSet = model.cs.DisplayFromDoc(lineDoc);
 		const int subLine = visibleLine - lineStartSet;
 		if (subLine < ll->lines) {
 			const Range rangeSubLine = ll->SubLineRange(subLine);
 			const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
 			if (subLine > 0)	// Wrapped
 				pt.x -= ll->wrapIndent;
-			const int positionInLine = ll->FindPositionFromX(static_cast<XYPOSITION>(pt.x + subLineStart),
+			const Sci::Position positionInLine = ll->FindPositionFromX(static_cast<XYPOSITION>(pt.x + subLineStart),
 				rangeSubLine, charPosition);
 			if (positionInLine < rangeSubLine.end) {
 				return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
@@ -700,14 +700,14 @@
 * Ensure is between whole characters when document is in multi-byte or UTF-8 mode.
 * This method is used for rectangular selections and does not work on wrapped lines.
 */
-SelectionPosition EditView::SPositionFromLineX(Surface *surface, const EditModel &model, int lineDoc, int x, const ViewStyle &vs) {
+SelectionPosition EditView::SPositionFromLineX(Surface *surface, const EditModel &model, Sci::Line lineDoc, int x, const ViewStyle &vs) {
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
-		const int posLineStart = model.pdoc->LineStart(lineDoc);
+		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
 		const Range rangeSubLine = ll->SubLineRange(0);
 		const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
-		const int positionInLine = ll->FindPositionFromX(x + subLineStart, rangeSubLine, false);
+		const Sci::Position positionInLine = ll->FindPositionFromX(x + subLineStart, rangeSubLine, false);
 		if (positionInLine < rangeSubLine.end) {
 			return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
 		}
@@ -719,14 +719,14 @@
 	return SelectionPosition(0);
 }
 
-int EditView::DisplayFromPosition(Surface *surface, const EditModel &model, int pos, const ViewStyle &vs) {
-	int lineDoc = model.pdoc->LineFromPosition(pos);
-	int lineDisplay = model.cs.DisplayFromDoc(lineDoc);
+Sci::Line EditView::DisplayFromPosition(Surface *surface, const EditModel &model, int pos, const ViewStyle &vs) {
+	Sci::Line lineDoc = model.pdoc->LineFromPosition(pos);
+	Sci::Line lineDisplay = model.cs.DisplayFromDoc(lineDoc);
 	AutoLineLayout ll(llc, RetrieveLineLayout(lineDoc, model));
 	if (surface && ll) {
 		LayoutLine(model, lineDoc, surface, vs, ll, model.wrapWidth);
-		unsigned int posLineStart = model.pdoc->LineStart(lineDoc);
-		int posInLine = pos - posLineStart;
+		Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
+		Sci::Position posInLine = pos - posLineStart;
 		lineDisplay--; // To make up for first increment ahead.
 		for (int subLine = 0; subLine < ll->lines; subLine++) {
 			if (posInLine >= ll->LineStart(subLine)) {
@@ -737,14 +737,14 @@
 	return lineDisplay;
 }
 
-int EditView::StartEndDisplayLine(Surface *surface, const EditModel &model, int pos, bool start, const ViewStyle &vs) {
-	int line = model.pdoc->LineFromPosition(pos);
+Sci::Position EditView::StartEndDisplayLine(Surface *surface, const EditModel &model, Sci::Position pos, bool start, const ViewStyle &vs) {
+	Sci::Line line = model.pdoc->LineFromPosition(pos);
 	AutoLineLayout ll(llc, RetrieveLineLayout(line, model));
-	int posRet = INVALID_POSITION;
+	Sci::Position posRet = INVALID_POSITION;
 	if (surface && ll) {
-		unsigned int posLineStart = model.pdoc->LineStart(line);
+		Sci::Position posLineStart = model.pdoc->LineStart(line);
 		LayoutLine(model, line, surface, vs, ll, model.wrapWidth);
-		int posInLine = pos - posLineStart;
+		Sci::Position posInLine = pos - posLineStart;
 		if (posInLine <= ll->maxLineLength) {
 			for (int subLine = 0; subLine < ll->lines; subLine++) {
 				if ((posInLine >= ll->LineStart(subLine)) &&
@@ -772,7 +772,7 @@
 }
 
 static ColourDesired TextBackground(const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	ColourOptional background, int inSelection, bool inHotspot, int styleMain, int i) {
+	ColourOptional background, int inSelection, bool inHotspot, int styleMain, Sci::Position i) {
 	if (inSelection == 1) {
 		if (vsDraw.selColours.back.isSet && (vsDraw.selAlpha == SC_ALPHA_NOALPHA)) {
 			return SelectionBackground(vsDraw, true, model.primarySelection);
@@ -796,7 +796,7 @@
 	}
 }
 
-void EditView::DrawIndentGuide(Surface *surface, int lineVisible, int lineHeight, int start, PRectangle rcSegment, bool highlight) {
+void EditView::DrawIndentGuide(Surface *surface, Sci::Line lineVisible, int lineHeight, Sci::Position start, PRectangle rcSegment, bool highlight) {
 	Point from = Point::FromInts(0, ((lineVisible & 1) && (lineHeight & 1)) ? 1 : 0);
 	PRectangle rcCopyArea = PRectangle::FromInts(start + 1, static_cast<int>(rcSegment.top), start + 2, static_cast<int>(rcSegment.bottom));
 	surface->Copy(rcCopyArea, from,
@@ -836,10 +836,10 @@
 }
 
 void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	PRectangle rcLine, int line, int lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
+	PRectangle rcLine, Sci::Line line, Sci::Position lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
 	ColourOptional background) {
 
-	const int posLineStart = model.pdoc->LineStart(line);
+	const Sci::Position posLineStart = model.pdoc->LineStart(line);
 	PRectangle rcSegment = rcLine;
 
 	const bool lastSubLine = subLine == (ll->lines - 1);
@@ -879,7 +879,7 @@
 	int eolInSelection = 0;
 	int alpha = SC_ALPHA_NOALPHA;
 	if (!hideSelection) {
-		int posAfterLineEnd = model.pdoc->LineStart(line + 1);
+		Sci::Position posAfterLineEnd = model.pdoc->LineStart(line + 1);
 		eolInSelection = (lastSubLine == true) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
 		alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 	}
@@ -887,7 +887,7 @@
 	// Draw the [CR], [LF], or [CR][LF] blobs if visible line ends are on
 	XYPOSITION blobsWidth = 0;
 	if (lastSubLine) {
-		for (int eolPos = ll->numCharsBeforeEOL; eolPos<ll->numCharsInLine; eolPos++) {
+		for (Sci::Position eolPos = ll->numCharsBeforeEOL; eolPos<ll->numCharsInLine; eolPos++) {
 			rcSegment.left = xStart + ll->positions[eolPos] - static_cast<XYPOSITION>(subLineStart)+virtualSpace;
 			rcSegment.right = xStart + ll->positions[eolPos + 1] - static_cast<XYPOSITION>(subLineStart)+virtualSpace;
 			blobsWidth += rcSegment.Width();
@@ -987,8 +987,8 @@
 	}
 }
 
-static void DrawIndicator(int indicNum, int startPos, int endPos, Surface *surface, const ViewStyle &vsDraw,
-	const LineLayout *ll, int xStart, PRectangle rcLine, int secondCharacter, int subLine, Indicator::DrawState drawState, int value) {
+static void DrawIndicator(int indicNum, Sci::Position startPos, Sci::Position endPos, Surface *surface, const ViewStyle &vsDraw,
+	const LineLayout *ll, int xStart, PRectangle rcLine, Sci::Position secondCharacter, int subLine, Indicator::DrawState drawState, int value) {
 	const XYPOSITION subLineStart = ll->positions[ll->LineStart(subLine)];
 	PRectangle rcIndic(
 		ll->positions[startPos] + xStart - subLineStart,
@@ -1008,26 +1008,26 @@
 }
 
 static void DrawIndicators(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, int xStart, PRectangle rcLine, int subLine, int lineEnd, bool under, int hoverIndicatorPos) {
+	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Position lineEnd, bool under, Sci::Position hoverIndicatorPos) {
 	// Draw decorators
-	const int posLineStart = model.pdoc->LineStart(line);
-	const int lineStart = ll->LineStart(subLine);
-	const int posLineEnd = posLineStart + lineEnd;
+	const Sci::Position posLineStart = model.pdoc->LineStart(line);
+	const Sci::Position lineStart = ll->LineStart(subLine);
+	const Sci::Position posLineEnd = posLineStart + lineEnd;
 
 	for (Decoration *deco = model.pdoc->decorations.root; deco; deco = deco->next) {
 		if (under == vsDraw.indicators[deco->indicator].under) {
-			int startPos = posLineStart + lineStart;
+			Sci::Position startPos = posLineStart + lineStart;
 			if (!deco->rs.ValueAt(startPos)) {
 				startPos = deco->rs.EndRun(startPos);
 			}
 			while ((startPos < posLineEnd) && (deco->rs.ValueAt(startPos))) {
 				const Range rangeRun(deco->rs.StartRun(startPos), deco->rs.EndRun(startPos));
-				const int endPos = std::min(rangeRun.end, posLineEnd);
+				const Sci::Position endPos = std::min(rangeRun.end, posLineEnd);
 				const bool hover = vsDraw.indicators[deco->indicator].IsDynamic() &&
 					rangeRun.ContainsCharacter(hoverIndicatorPos);
 				const int value = deco->rs.ValueAt(startPos);
 				Indicator::DrawState drawState = hover ? Indicator::drawHover : Indicator::drawNormal;
-				const int posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
+				const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
 				DrawIndicator(deco->indicator, startPos - posLineStart, endPos - posLineStart,
 					surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, drawState, value);
 				startPos = endPos;
@@ -1045,16 +1045,16 @@
 		if (under == vsDraw.indicators[braceIndicator].under) {
 			Range rangeLine(posLineStart + lineStart, posLineEnd);
 			if (rangeLine.ContainsCharacter(model.braces[0])) {
-				int braceOffset = model.braces[0] - posLineStart;
+				Sci::Position braceOffset = model.braces[0] - posLineStart;
 				if (braceOffset < ll->numCharsInLine) {
-					const int secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[0] + 1, 1) - posLineStart;
+					const Sci::Position secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[0] + 1, 1) - posLineStart;
 					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, secondOffset, subLine, Indicator::drawNormal, 1);
 				}
 			}
 			if (rangeLine.ContainsCharacter(model.braces[1])) {
-				int braceOffset = model.braces[1] - posLineStart;
+				Sci::Position braceOffset = model.braces[1] - posLineStart;
 				if (braceOffset < ll->numCharsInLine) {
-					const int secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[1] + 1, 1) - posLineStart;
+					const Sci::Position secondOffset = model.pdoc->MovePositionOutsideChar(model.braces[1] + 1, 1) - posLineStart;
 					DrawIndicator(braceIndicator, braceOffset, braceOffset + 1, surface, vsDraw, ll, xStart, rcLine, secondOffset, subLine, Indicator::drawNormal, 1);
 				}
 			}
@@ -1063,7 +1063,7 @@
 }
 
 void EditView::DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-							  int line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase) {
+							  Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase) {
 	const bool lastSubLine = subLine == (ll->lines - 1);
 	if (!lastSubLine)
 		return;
@@ -1080,7 +1080,7 @@
 	int eolInSelection = 0;
 	int alpha = SC_ALPHA_NOALPHA;
 	if (!hideSelection) {
-		int posAfterLineEnd = model.pdoc->LineStart(line + 1);
+		Sci::Position posAfterLineEnd = model.pdoc->LineStart(line + 1);
 		eolInSelection = (subLine == (ll->lines - 1)) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
 		alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 	}
@@ -1159,7 +1159,7 @@
 }
 
 void EditView::DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
+	Sci::Line line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
 	int indent = static_cast<int>(model.pdoc->GetLineIndentation(line) * vsDraw.spaceWidth);
 	PRectangle rcSegment = rcLine;
 	int annotationLine = subLine - ll->lines;
@@ -1216,18 +1216,18 @@
 }
 
 static void DrawBlockCaret(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int subLine, int xStart, int offset, int posCaret, PRectangle rcCaret, ColourDesired caretColour) {
+	int subLine, int xStart, Sci::Position offset, Sci::Position posCaret, PRectangle rcCaret, ColourDesired caretColour) {
 
-	int lineStart = ll->LineStart(subLine);
-	int posBefore = posCaret;
-	int posAfter = model.pdoc->MovePositionOutsideChar(posCaret + 1, 1);
-	int numCharsToDraw = posAfter - posCaret;
+	Sci::Position lineStart = ll->LineStart(subLine);
+	Sci::Position posBefore = posCaret;
+	Sci::Position posAfter = model.pdoc->MovePositionOutsideChar(posCaret + 1, 1);
+	Sci::Position numCharsToDraw = posAfter - posCaret;
 
 	// Work out where the starting and ending offsets are. We need to
 	// see if the previous character shares horizontal space, such as a
 	// glyph / combining character. If so we'll need to draw that too.
-	int offsetFirstChar = offset;
-	int offsetLastChar = offset + (posAfter - posCaret);
+	Sci::Position offsetFirstChar = offset;
+	Sci::Position offsetLastChar = offset + (posAfter - posCaret);
 	while ((posBefore > 0) && ((offsetLastChar - numCharsToDraw) >= lineStart)) {
 		if ((ll->positions[offsetLastChar] - ll->positions[offsetLastChar - numCharsToDraw]) > 0) {
 			// The char does not share horizontal space
@@ -1282,12 +1282,12 @@
 }
 
 void EditView::DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int lineDoc, int xStart, PRectangle rcLine, int subLine) const {
+	Sci::Line lineDoc, int xStart, PRectangle rcLine, int subLine) const {
 	// When drag is active it is the only caret drawn
 	bool drawDrag = model.posDrag.IsValid();
 	if (hideSelection && !drawDrag)
 		return;
-	const int posLineStart = model.pdoc->LineStart(lineDoc);
+	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
 	// For each selection draw
 	for (size_t r = 0; (r<model.sel.Count()) || drawDrag; r++) {
 		const bool mainCaret = r == model.sel.Main();
@@ -1304,7 +1304,7 @@
 		if (ll->InLine(offset, subLine) && offset <= ll->numCharsBeforeEOL) {
 			XYPOSITION xposCaret = ll->positions[offset] + virtualOffset - ll->positions[ll->LineStart(subLine)];
 			if (ll->wrapIndent != 0) {
-				int lineStart = ll->LineStart(subLine);
+				Sci::Position lineStart = ll->LineStart(subLine);
 				if (lineStart != 0)	// Wrapped
 					xposCaret += ll->wrapIndent;
 			}
@@ -1399,7 +1399,7 @@
 }
 
 void EditView::DrawBackground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	PRectangle rcLine, Range lineRange, int posLineStart, int xStart,
+	PRectangle rcLine, Range lineRange, Sci::Position posLineStart, int xStart,
 	int subLine, ColourOptional background) const {
 
 	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
@@ -1416,8 +1416,8 @@
 	while (bfBack.More()) {
 
 		const TextSegment ts = bfBack.Next();
-		const int i = ts.end() - 1;
-		const int iDoc = i + posLineStart;
+		const Sci::Position i = ts.end() - 1;
+		const Sci::Position iDoc = i + posLineStart;
 
 		PRectangle rcSegment = rcLine;
 		rcSegment.left = ll->positions[ts.start] + xStart - static_cast<XYPOSITION>(subLineStart);
@@ -1498,7 +1498,7 @@
 
 // Draw underline mark as part of background if not transparent
 static void DrawMarkUnderline(Surface *surface, const EditModel &model, const ViewStyle &vsDraw,
-	int line, PRectangle rcLine) {
+	Sci::Line line, PRectangle rcLine) {
 	int marks = model.pdoc->GetMark(line);
 	for (int markBit = 0; (markBit < 32) && marks; markBit++) {
 		if ((marks & 1) && (vsDraw.markers[markBit].markType == SC_MARK_UNDERLINE) &&
@@ -1511,12 +1511,12 @@
 	}
 }
 static void DrawTranslucentSelection(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, PRectangle rcLine, int subLine, Range lineRange, int xStart) {
+	Sci::Line line, PRectangle rcLine, int subLine, Range lineRange, int xStart) {
 	if ((vsDraw.selAlpha != SC_ALPHA_NOALPHA) || (vsDraw.selAdditionalAlpha != SC_ALPHA_NOALPHA)) {
-		const int posLineStart = model.pdoc->LineStart(line);
+		const Sci::Position posLineStart = model.pdoc->LineStart(line);
 		const XYACCUMULATOR subLineStart = ll->positions[lineRange.start];
 		// For each selection draw
-		int virtualSpaces = 0;
+		Sci::Position virtualSpaces = 0;
 		if (subLine == (ll->lines - 1)) {
 			virtualSpaces = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line));
 		}
@@ -1550,7 +1550,7 @@
 
 // Draw any translucent whole line states
 static void DrawTranslucentLineState(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, PRectangle rcLine) {
+	Sci::Line line, PRectangle rcLine) {
 	if ((model.caret.active || vsDraw.alwaysShowCaretLineBackground) && vsDraw.showCaretLineBackground && ll->containsCaret) {
 		SimpleAlphaRectangle(surface, rcLine, vsDraw.caretLineBackground, vsDraw.caretLineAlpha);
 	}
@@ -1578,7 +1578,7 @@
 }
 
 void EditView::DrawForeground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int lineVisible, PRectangle rcLine, Range lineRange, int posLineStart, int xStart,
+	Sci::Line lineVisible, PRectangle rcLine, Range lineRange, Sci::Position posLineStart, int xStart,
 	int subLine, ColourOptional background) {
 
 	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
@@ -1598,8 +1598,8 @@
 	while (bfFore.More()) {
 
 		const TextSegment ts = bfFore.Next();
-		const int i = ts.end() - 1;
-		const int iDoc = i + posLineStart;
+		const Sci::Position i = ts.end() - 1;
+		const Sci::Position iDoc = i + posLineStart;
 
 		PRectangle rcSegment = rcLine;
 		rcSegment.left = ll->positions[ts.start] + xStart - static_cast<XYPOSITION>(subLineStart);
@@ -1770,16 +1770,16 @@
 }
 
 void EditView::DrawIndentGuidesOverEmpty(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, int lineVisible, PRectangle rcLine, int xStart, int subLine) {
+	Sci::Line line, Sci::Line lineVisible, PRectangle rcLine, int xStart, int subLine) {
 	if ((vsDraw.viewIndentationGuides == ivLookForward || vsDraw.viewIndentationGuides == ivLookBoth)
 		&& (subLine == 0)) {
-		const int posLineStart = model.pdoc->LineStart(line);
+		const Sci::Position posLineStart = model.pdoc->LineStart(line);
 		int indentSpace = model.pdoc->GetLineIndentation(line);
 		int xStartText = static_cast<int>(ll->positions[model.pdoc->GetLineIndentPosition(line) - posLineStart]);
 
 		// Find the most recent line with some text
 
-		int lineLastWithText = line;
+		Sci::Line lineLastWithText = line;
 		while (lineLastWithText > Platform::Maximum(line - 20, 0) && model.pdoc->IsWhiteLine(lineLastWithText)) {
 			lineLastWithText--;
 		}
@@ -1802,7 +1802,7 @@
 			}
 		}
 
-		int lineNextWithText = line;
+		Sci::Line lineNextWithText = line;
 		while (lineNextWithText < Platform::Minimum(line + 20, model.pdoc->LinesTotal()) && model.pdoc->IsWhiteLine(lineNextWithText)) {
 			lineNextWithText++;
 		}
@@ -1824,7 +1824,7 @@
 }
 
 void EditView::DrawLine(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, int lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
+	Sci::Line line, Sci::Line lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
 
 	if (subLine >= ll->lines) {
 		DrawAnnotation(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, phase);
@@ -1834,7 +1834,7 @@
 	// See if something overrides the line background color.
 	const ColourOptional background = vsDraw.Background(model.pdoc->GetMark(line), model.caret.active, ll->containsCaret);
 
-	const int posLineStart = model.pdoc->LineStart(line);
+	const Sci::Position posLineStart = model.pdoc->LineStart(line);
 
 	const Range lineRange = ll->SubLineRange(subLine);
 	const XYACCUMULATOR subLineStart = ll->positions[lineRange.start];
@@ -1894,7 +1894,7 @@
 	}
 }
 
-static void DrawFoldLines(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, int line, PRectangle rcLine) {
+static void DrawFoldLines(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, Sci::Line line, PRectangle rcLine) {
 	bool expanded = model.cs.GetExpanded(line);
 	const int level = model.pdoc->GetLevel(line);
 	const int levelNext = model.pdoc->GetLevel(line + 1);
@@ -1944,7 +1944,7 @@
 		SelectionPosition posCaret = model.sel.RangeMain().caret;
 		if (model.posDrag.IsValid())
 			posCaret = model.posDrag;
-		const int lineCaret = model.pdoc->LineFromPosition(posCaret.Position());
+		const Sci::Line lineCaret = model.pdoc->LineFromPosition(posCaret.Position());
 
 		PRectangle rcTextArea = rcClient;
 		if (vsDraw.marginInside) {
@@ -1971,7 +1971,7 @@
 		const bool bracesIgnoreStyle = ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == STYLE_BRACELIGHT)) ||
 			(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == STYLE_BRACEBAD)));
 
-		int lineDocPrevious = -1;	// Used to avoid laying out one document line multiple times
+		Sci::Line lineDocPrevious = -1;	// Used to avoid laying out one document line multiple times
 		AutoLineLayout ll(llc, 0);
 		std::vector<DrawPhase> phases;
 		if ((phasesDraw == phasesMultiple) && !bufferedDraw) {
@@ -1986,13 +1986,13 @@
 			if (!bufferedDraw)
 				ypos += screenLinePaintFirst * vsDraw.lineHeight;
 			int yposScreen = screenLinePaintFirst * vsDraw.lineHeight;
-			int visibleLine = model.TopLineOfMain() + screenLinePaintFirst;
+			Sci::Line visibleLine = model.TopLineOfMain() + screenLinePaintFirst;
 			while (visibleLine < model.cs.LinesDisplayed() && yposScreen < rcArea.bottom) {
 
-				const int lineDoc = model.cs.DocFromDisplay(visibleLine);
+				const Sci::Line lineDoc = model.cs.DocFromDisplay(visibleLine);
 				// Only visible lines should be handled by the code within the loop
 				PLATFORM_ASSERT(model.cs.GetVisible(lineDoc));
-				const int lineStartSet = model.cs.DisplayFromDoc(lineDoc);
+				const Sci::Line lineStartSet = model.cs.DisplayFromDoc(lineDoc);
 				const int subLine = visibleLine - lineStartSet;
 
 				// Copy this line and its styles from the document into local arrays
@@ -2099,11 +2099,11 @@
 }
 
 void EditView::FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-	int line, PRectangle rcArea, int subLine) const {
+	Sci::Line line, PRectangle rcArea, int subLine) const {
 		int eolInSelection = 0;
 		int alpha = SC_ALPHA_NOALPHA;
 		if (!hideSelection) {
-			int posAfterLineEnd = model.pdoc->LineStart(line + 1);
+			Sci::Position posAfterLineEnd = model.pdoc->LineStart(line + 1);
 			eolInSelection = (subLine == (ll->lines - 1)) ? model.sel.InSelectionForEOL(posAfterLineEnd) : 0;
 			alpha = (eolInSelection == 1) ? vsDraw.selAlpha : vsDraw.selAdditionalAlpha;
 		}
@@ -2212,17 +2212,17 @@
 		vsPrint.Refresh(*surfaceMeasure, model.pdoc->tabInChars);	// Recalculate fixedColumnWidth
 	}
 
-	int linePrintStart = model.pdoc->LineFromPosition(static_cast<int>(pfr->chrg.cpMin));
-	int linePrintLast = linePrintStart + (pfr->rc.bottom - pfr->rc.top) / vsPrint.lineHeight - 1;
+	Sci::Line linePrintStart = model.pdoc->LineFromPosition(static_cast<int>(pfr->chrg.cpMin));
+	Sci::Line linePrintLast = linePrintStart + (pfr->rc.bottom - pfr->rc.top) / vsPrint.lineHeight - 1;
 	if (linePrintLast < linePrintStart)
 		linePrintLast = linePrintStart;
-	int linePrintMax = model.pdoc->LineFromPosition(static_cast<int>(pfr->chrg.cpMax));
+	Sci::Line linePrintMax = model.pdoc->LineFromPosition(static_cast<int>(pfr->chrg.cpMax));
 	if (linePrintLast > linePrintMax)
 		linePrintLast = linePrintMax;
 	//Platform::DebugPrintf("Formatting lines=[%0d,%0d,%0d] top=%0d bottom=%0d line=%0d %0d\n",
 	//      linePrintStart, linePrintLast, linePrintMax, pfr->rc.top, pfr->rc.bottom, vsPrint.lineHeight,
 	//      surfaceMeasure->Height(vsPrint.styles[STYLE_LINENUMBER].font));
-	int endPosPrint = model.pdoc->Length();
+	Sci::Position endPosPrint = model.pdoc->Length();
 	if (linePrintLast < model.pdoc->LinesTotal())
 		endPosPrint = model.pdoc->LineStart(linePrintLast + 1);
 
@@ -2232,9 +2232,9 @@
 	int xStart = vsPrint.fixedColumnWidth + pfr->rc.left;
 	int ypos = pfr->rc.top;
 
-	int lineDoc = linePrintStart;
+	Sci::Line lineDoc = linePrintStart;
 
-	int nPrintPos = static_cast<int>(pfr->chrg.cpMin);
+	Sci::Position nPrintPos = static_cast<Sci::Position>(pfr->chrg.cpMin);
 	int visibleLine = 0;
 	int widthPrint = pfr->rc.right - pfr->rc.left - vsPrint.fixedColumnWidth;
 	if (printParameters.wrapState == eWrapNone)
@@ -2265,7 +2265,7 @@
 		// to start printing from to ensure a particular position is on the first
 		// line of the page.
 		if (visibleLine == 0) {
-			int startWithinLine = nPrintPos - model.pdoc->LineStart(lineDoc);
+			Sci::Position startWithinLine = nPrintPos - model.pdoc->LineStart(lineDoc);
 			for (int iwl = 0; iwl < ll.lines - 1; iwl++) {
 				if (ll.LineStart(iwl) <= startWithinLine && ll.LineStart(iwl + 1) >= startWithinLine) {
 					visibleLine = -iwl;
diff -r 1788f6795302 -r a0f26eaf474d src/EditView.h
--- a/src/EditView.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/EditView.h	Fri Mar 31 18:19:38 2017 +1100
@@ -97,53 +97,53 @@
 	bool LinesOverlap() const;
 
 	void ClearAllTabstops();
-	XYPOSITION NextTabstopPos(int line, XYPOSITION x, XYPOSITION tabWidth) const;
-	bool ClearTabstops(int line);
-	bool AddTabstop(int line, int x);
-	int GetNextTabstop(int line, int x) const;
-	void LinesAddedOrRemoved(int lineOfPos, int linesAdded);
+	XYPOSITION NextTabstopPos(Sci::Line line, XYPOSITION x, XYPOSITION tabWidth) const;
+	bool ClearTabstops(Sci::Line line);
+	bool AddTabstop(Sci::Line line, int x);
+	int GetNextTabstop(Sci::Line line, int x) const;
+	void LinesAddedOrRemoved(Sci::Line lineOfPos, Sci::Line linesAdded);
 
 	void DropGraphics(bool freeObjects);
 	void AllocateGraphics(const ViewStyle &vsDraw);
 	void RefreshPixMaps(Surface *surfaceWindow, WindowID wid, const ViewStyle &vsDraw);
 
-	LineLayout *RetrieveLineLayout(int lineNumber, const EditModel &model);
-	void LayoutLine(const EditModel &model, int line, Surface *surface, const ViewStyle &vstyle,
+	LineLayout *RetrieveLineLayout(Sci::Line lineNumber, const EditModel &model);
+	void LayoutLine(const EditModel &model, Sci::Line line, Surface *surface, const ViewStyle &vstyle,
 		LineLayout *ll, int width = LineLayout::wrapWidthInfinite);
 
-	Point LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, int topLine,
+	Point LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, Sci::Line topLine,
 				   const ViewStyle &vs, PointEnd pe);
-	Range RangeDisplayLine(Surface *surface, const EditModel &model, int lineVisible, const ViewStyle &vs);
+	Range RangeDisplayLine(Surface *surface, const EditModel &model, Sci::Line lineVisible, const ViewStyle &vs);
 	SelectionPosition SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid,
 		bool charPosition, bool virtualSpace, const ViewStyle &vs);
-	SelectionPosition SPositionFromLineX(Surface *surface, const EditModel &model, int lineDoc, int x, const ViewStyle &vs);
-	int DisplayFromPosition(Surface *surface, const EditModel &model, int pos, const ViewStyle &vs);
-	int StartEndDisplayLine(Surface *surface, const EditModel &model, int pos, bool start, const ViewStyle &vs);
+	SelectionPosition SPositionFromLineX(Surface *surface, const EditModel &model, Sci::Line lineDoc, int x, const ViewStyle &vs);
+	Sci::Line DisplayFromPosition(Surface *surface, const EditModel &model, int pos, const ViewStyle &vs);
+	Sci::Position StartEndDisplayLine(Surface *surface, const EditModel &model, Sci::Position pos, bool start, const ViewStyle &vs);
 
-	void DrawIndentGuide(Surface *surface, int lineVisible, int lineHeight, int start, PRectangle rcSegment, bool highlight);
+	void DrawIndentGuide(Surface *surface, Sci::Line lineVisible, int lineHeight, Sci::Position start, PRectangle rcSegment, bool highlight);
 	void DrawEOL(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, PRectangle rcLine,
-		int line, int lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
+		Sci::Line line, Sci::Position lineEnd, int xStart, int subLine, XYACCUMULATOR subLineStart,
 		ColourOptional background);
 	void DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-		int line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase);
+		Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYACCUMULATOR subLineStart, DrawPhase phase);
 	void DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-		int line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
-	void DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, int line,
+		Sci::Line line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
+	void DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, Sci::Line line,
 		int xStart, PRectangle rcLine, int subLine) const;
 	void DrawBackground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, PRectangle rcLine,
-		Range lineRange, int posLineStart, int xStart,
+		Range lineRange, Sci::Position posLineStart, int xStart,
 		int subLine, ColourOptional background) const;
-	void DrawForeground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, int lineVisible,
-		PRectangle rcLine, Range lineRange, int posLineStart, int xStart,
+	void DrawForeground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, Sci::Line lineVisible,
+		PRectangle rcLine, Range lineRange, Sci::Position posLineStart, int xStart,
 		int subLine, ColourOptional background);
 	void DrawIndentGuidesOverEmpty(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-		int line, int lineVisible, PRectangle rcLine, int xStart, int subLine);
-	void DrawLine(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, int line,
-		int lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
+		Sci::Line line, Sci::Line lineVisible, PRectangle rcLine, int xStart, int subLine);
+	void DrawLine(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll, Sci::Line line,
+		Sci::Line lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase);
 	void PaintText(Surface *surfaceWindow, const EditModel &model, PRectangle rcArea, PRectangle rcClient,
 		const ViewStyle &vsDraw);
 	void FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
-		int line, PRectangle rcArea, int subLine) const;
+		Sci::Line line, PRectangle rcArea, int subLine) const;
 	long FormatRange(bool draw, Sci_RangeToFormat *pfr, Surface *surface, Surface *surfaceMeasure,
 		const EditModel &model, const ViewStyle &vs);
 };
diff -r 1788f6795302 -r a0f26eaf474d src/Editor.cxx
--- a/src/Editor.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Editor.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -123,7 +123,7 @@
 	ptMouseLast.y = 0;
 	inDragDrop = ddNone;
 	dropWentOutside = false;
-	posDrop = SelectionPosition(invalidPosition);
+	posDrop = SelectionPosition(Sci::invalidPosition);
 	hotSpotClickPos = INVALID_POSITION;
 	selectionType = selChar;
 
@@ -296,7 +296,7 @@
 	return ptDocument;
 }
 
-int Editor::TopLineOfMain() const {
+Sci::Line Editor::TopLineOfMain() const {
 	if (wMargin.GetID())
 		return 0;
 	else
@@ -319,25 +319,25 @@
 	return rc;
 }
 
-int Editor::LinesOnScreen() const {
+Sci::Line Editor::LinesOnScreen() const {
 	PRectangle rcClient = GetClientRectangle();
 	int htClient = static_cast<int>(rcClient.bottom - rcClient.top);
 	//Platform::DebugPrintf("lines on screen = %d\n", htClient / lineHeight + 1);
 	return htClient / vs.lineHeight;
 }
 
-int Editor::LinesToScroll() const {
-	int retVal = LinesOnScreen() - 1;
+Sci::Line Editor::LinesToScroll() const {
+	Sci::Line retVal = LinesOnScreen() - 1;
 	if (retVal < 1)
 		return 1;
 	else
 		return retVal;
 }
 
-int Editor::MaxScrollPos() const {
+Sci::Line Editor::MaxScrollPos() const {
 	//Platform::DebugPrintf("Lines %d screen = %d maxScroll = %d\n",
 	//LinesTotal(), LinesOnScreen(), LinesTotal() - LinesOnScreen() + 1);
-	int retVal = cs.LinesDisplayed();
+	Sci::Line retVal = cs.LinesDisplayed();
 	if (endAtLastLine) {
 		retVal -= LinesOnScreen();
 	} else {
@@ -369,11 +369,11 @@
 	return view.LocationFromPosition(surface, *this, pos, topLine, vs, pe);
 }
 
-Point Editor::LocationFromPosition(int pos, PointEnd pe) {
+Point Editor::LocationFromPosition(Sci::Position pos, PointEnd pe) {
 	return LocationFromPosition(SelectionPosition(pos), pe);
 }
 
-int Editor::XFromPosition(int pos) {
+int Editor::XFromPosition(Sci::Position pos) {
 	Point pt = LocationFromPosition(pos);
 	return static_cast<int>(pt.x) - vs.textStart + xOffset;
 }
@@ -403,7 +403,7 @@
 	return view.SPositionFromLocation(surface, *this, ptdoc, canReturnInvalid, charPosition, virtualSpace, vs);
 }
 
-int Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
+Sci::Position Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
 	return SPositionFromLocation(pt, canReturnInvalid, charPosition, false).Position();
 }
 
@@ -412,7 +412,7 @@
 * Ensure is between whole characters when document is in multi-byte or UTF-8 mode.
 * This method is used for rectangular selections and does not work on wrapped lines.
 */
-SelectionPosition Editor::SPositionFromLineX(int lineDoc, int x) {
+SelectionPosition Editor::SPositionFromLineX(Sci::Line lineDoc, int x) {
 	RefreshStyleData();
 	if (lineDoc >= pdoc->LinesTotal())
 		return SelectionPosition(pdoc->Length());
@@ -421,15 +421,15 @@
 	return view.SPositionFromLineX(surface, *this, lineDoc, x, vs);
 }
 
-int Editor::PositionFromLineX(int lineDoc, int x) {
+Sci::Position Editor::PositionFromLineX(Sci::Line lineDoc, int x) {
 	return SPositionFromLineX(lineDoc, x).Position();
 }
 
-int Editor::LineFromLocation(Point pt) const {
+Sci::Line Editor::LineFromLocation(Point pt) const {
 	return cs.DocFromDisplay(static_cast<int>(pt.y) / vs.lineHeight + topLine);
 }
 
-void Editor::SetTopLine(int topLineNew) {
+void Editor::SetTopLine(Sci::Line topLineNew) {
 	if ((topLine != topLineNew) && (topLineNew >= 0)) {
 		topLine = topLineNew;
 		ContainerNeedsUpdate(SC_UPDATE_V_SCROLL);
@@ -480,7 +480,7 @@
 	//wMain.InvalidateAll();
 }
 
-void Editor::RedrawSelMargin(int line, bool allAfter) {
+void Editor::RedrawSelMargin(Sci::Line line, bool allAfter) {
 	const bool markersInText = vs.maskInLine || vs.maskDrawInText;
 	if (!wMargin.GetID() || markersInText) {	// May affect text area so may need to abandon and retry
 		if (AbandonPaint()) {
@@ -526,8 +526,8 @@
 }
 
 PRectangle Editor::RectangleFromRange(Range r, int overlap) {
-	const int minLine = cs.DisplayFromDoc(pdoc->LineFromPosition(r.First()));
-	const int maxLine = cs.DisplayLastFromDoc(pdoc->LineFromPosition(r.Last()));
+	const Sci::Line minLine = cs.DisplayFromDoc(pdoc->LineFromPosition(r.First()));
+	const Sci::Line maxLine = cs.DisplayLastFromDoc(pdoc->LineFromPosition(r.Last()));
 	const PRectangle rcClientDrawing = GetClientDrawingRectangle();
 	PRectangle rc;
 	const int leftTextOverlap = ((xOffset == 0) && (vs.leftMarginWidth > 0)) ? 1 : 0;
@@ -542,11 +542,11 @@
 	return rc;
 }
 
-void Editor::InvalidateRange(int start, int end) {
+void Editor::InvalidateRange(Sci::Position start, Sci::Position end) {
 	RedrawRect(RectangleFromRange(Range(start, end), view.LinesOverlap() ? vs.lineOverlap : 0));
 }
 
-int Editor::CurrentPosition() const {
+Sci::Position Editor::CurrentPosition() const {
 	return sel.MainCaret();
 }
 
@@ -569,10 +569,10 @@
 		if (sel.selType == Selection::selThin) {
 			xCaret = xAnchor;
 		}
-		int lineAnchorRect = pdoc->LineFromPosition(sel.Rectangular().anchor.Position());
-		int lineCaret = pdoc->LineFromPosition(sel.Rectangular().caret.Position());
+		Sci::Line lineAnchorRect = pdoc->LineFromPosition(sel.Rectangular().anchor.Position());
+		Sci::Line lineCaret = pdoc->LineFromPosition(sel.Rectangular().caret.Position());
 		int increment = (lineCaret > lineAnchorRect) ? 1 : -1;
-		for (int line=lineAnchorRect; line != lineCaret+increment; line += increment) {
+		for (Sci::Line line=lineAnchorRect; line != lineCaret+increment; line += increment) {
 			SelectionRange range(SPositionFromLineX(line, xCaret), SPositionFromLineX(line, xAnchor));
 			if ((virtualSpaceOptions & SCVS_RECTANGULARSELECTION) == 0)
 				range.ClearVirtualSpace();
@@ -600,9 +600,9 @@
 	if (sel.Count() > 1 || !(sel.RangeMain().anchor == newMain.anchor) || sel.IsRectangular()) {
 		invalidateWholeSelection = true;
 	}
-	int firstAffected = Platform::Minimum(sel.RangeMain().Start().Position(), newMain.Start().Position());
+	Sci::Position firstAffected = Platform::Minimum(sel.RangeMain().Start().Position(), newMain.Start().Position());
 	// +1 for lastAffected ensures caret repainted
-	int lastAffected = Platform::Maximum(newMain.caret.Position()+1, newMain.anchor.Position());
+	Sci::Position lastAffected = Platform::Maximum(newMain.caret.Position()+1, newMain.anchor.Position());
 	lastAffected = Platform::Maximum(lastAffected, sel.RangeMain().End().Position());
 	if (invalidateWholeSelection) {
 		for (size_t r=0; r<sel.Count(); r++) {
@@ -623,7 +623,7 @@
 void Editor::SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_) {
 	currentPos_ = ClampPositionIntoDocument(currentPos_);
 	anchor_ = ClampPositionIntoDocument(anchor_);
-	int currentLine = pdoc->LineFromPosition(currentPos_.Position());
+	Sci::Line currentLine = pdoc->LineFromPosition(currentPos_.Position());
 	/* For Line selection - ensure the anchor and caret are always
 	   at the beginning and end of the region lines. */
 	if (sel.selType == Selection::selLines) {
@@ -650,14 +650,14 @@
 	QueueIdleWork(WorkNeeded::workUpdateUI);
 }
 
-void Editor::SetSelection(int currentPos_, int anchor_) {
+void Editor::SetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
 	SetSelection(SelectionPosition(currentPos_), SelectionPosition(anchor_));
 }
 
 // Just move the caret on the main selection
 void Editor::SetSelection(SelectionPosition currentPos_) {
 	currentPos_ = ClampPositionIntoDocument(currentPos_);
-	int currentLine = pdoc->LineFromPosition(currentPos_.Position());
+	Sci::Line currentLine = pdoc->LineFromPosition(currentPos_.Position());
 	if (sel.Count() > 1 || !(sel.RangeMain().caret == currentPos_)) {
 		InvalidateSelection(SelectionRange(currentPos_));
 	}
@@ -683,7 +683,7 @@
 }
 
 void Editor::SetEmptySelection(SelectionPosition currentPos_) {
-	int currentLine = pdoc->LineFromPosition(currentPos_.Position());
+	Sci::Line currentLine = pdoc->LineFromPosition(currentPos_.Position());
 	SelectionRange rangeNew(ClampPositionIntoDocument(currentPos_));
 	if (sel.Count() > 1 || !(sel.RangeMain() == rangeNew)) {
 		InvalidateSelection(rangeNew);
@@ -700,15 +700,15 @@
 	QueueIdleWork(WorkNeeded::workUpdateUI);
 }
 
-void Editor::SetEmptySelection(int currentPos_) {
+void Editor::SetEmptySelection(Sci::Position currentPos_) {
 	SetEmptySelection(SelectionPosition(currentPos_));
 }
 
 void Editor::MultipleSelectAdd(AddNumber addNumber) {
 	if (SelectionEmpty() || !multipleSelection) {
 		// Select word at caret
-		const int startWord = pdoc->ExtendWordSelect(sel.MainCaret(), -1, true);
-		const int endWord = pdoc->ExtendWordSelect(startWord, 1, true);
+		const Sci::Position startWord = pdoc->ExtendWordSelect(sel.MainCaret(), -1, true);
+		const Sci::Position endWord = pdoc->ExtendWordSelect(startWord, 1, true);
 		TrimAndSetSelection(endWord, startWord);
 
 	} else {
@@ -736,11 +736,11 @@
 		}
 
 		for (std::vector<Range>::const_iterator it = searchRanges.begin(); it != searchRanges.end(); ++it) {
-			int searchStart = it->start;
-			const int searchEnd = it->end;
+			Sci::Position searchStart = it->start;
+			const Sci::Position searchEnd = it->end;
 			for (;;) {
-				int lengthFound = static_cast<int>(selectedText.length());
-				int pos = static_cast<int>(pdoc->FindText(searchStart, searchEnd,
+				Sci::Position lengthFound = static_cast<Sci::Position>(selectedText.length());
+				Sci::Position pos = static_cast<Sci::Position>(pdoc->FindText(searchStart, searchEnd,
 					selectedText.c_str(), searchFlags, &lengthFound));
 				if (pos >= 0) {
 					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
@@ -757,14 +757,14 @@
 	}
 }
 
-bool Editor::RangeContainsProtected(int start, int end) const {
+bool Editor::RangeContainsProtected(Sci::Position start, Sci::Position end) const {
 	if (vs.ProtectionActive()) {
 		if (start > end) {
-			int t = start;
+			Sci::Position t = start;
 			start = end;
 			end = t;
 		}
-		for (int pos = start; pos < end; pos++) {
+		for (Sci::Position pos = start; pos < end; pos++) {
 			if (vs.styles[pdoc->StyleIndexAt(pos)].IsProtected())
 				return true;
 		}
@@ -785,12 +785,12 @@
 /**
  * Asks document to find a good position and then moves out of any invisible positions.
  */
-int Editor::MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd) const {
+Sci::Position Editor::MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd) const {
 	return MovePositionOutsideChar(SelectionPosition(pos), moveDir, checkLineEnd).Position();
 }
 
-SelectionPosition Editor::MovePositionOutsideChar(SelectionPosition pos, int moveDir, bool checkLineEnd) const {
-	int posMoved = pdoc->MovePositionOutsideChar(pos.Position(), moveDir, checkLineEnd);
+SelectionPosition Editor::MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd) const {
+	Sci::Position posMoved = pdoc->MovePositionOutsideChar(pos.Position(), moveDir, checkLineEnd);
 	if (posMoved != pos.Position())
 		pos.SetPosition(posMoved);
 	if (vs.ProtectionActive()) {
@@ -812,7 +812,7 @@
 }
 
 void Editor::MovedCaret(SelectionPosition newPos, SelectionPosition previousPos, bool ensureVisible) {
-	const int currentLine = pdoc->LineFromPosition(newPos.Position());
+	const Sci::Line currentLine = pdoc->LineFromPosition(newPos.Position());
 	if (ensureVisible) {
 		// In case in need of wrapping to ensure DisplayFromDoc works.
 		if (currentLine >= wrapPending.start)
@@ -844,7 +844,7 @@
 	const SelectionPosition spCaret = ((sel.Count() == 1) && sel.Empty()) ?
 		sel.Last() : SelectionPosition(INVALID_POSITION);
 
-	int delta = newPos.Position() - sel.MainCaret();
+	Sci::Position delta = newPos.Position() - sel.MainCaret();
 	newPos = ClampPositionIntoDocument(newPos);
 	newPos = MovePositionOutsideChar(newPos, delta);
 	if (!multipleSelection && sel.IsRectangular() && (selt == Selection::selStream)) {
@@ -871,18 +871,18 @@
 	MovedCaret(newPos, spCaret, ensureVisible);
 }
 
-void Editor::MovePositionTo(int newPos, Selection::selTypes selt, bool ensureVisible) {
+void Editor::MovePositionTo(Sci::Position newPos, Selection::selTypes selt, bool ensureVisible) {
 	MovePositionTo(SelectionPosition(newPos), selt, ensureVisible);
 }
 
 SelectionPosition Editor::MovePositionSoVisible(SelectionPosition pos, int moveDir) {
 	pos = ClampPositionIntoDocument(pos);
 	pos = MovePositionOutsideChar(pos, moveDir);
-	int lineDoc = pdoc->LineFromPosition(pos.Position());
+	Sci::Line lineDoc = pdoc->LineFromPosition(pos.Position());
 	if (cs.GetVisible(lineDoc)) {
 		return pos;
 	} else {
-		int lineDisplay = cs.DisplayFromDoc(lineDoc);
+		Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
 		if (moveDir > 0) {
 			// lineDisplay is already line before fold as lines in fold use display line of line after fold
 			lineDisplay = Platform::Clamp(lineDisplay, 0, cs.LinesDisplayed());
@@ -894,7 +894,7 @@
 	}
 }
 
-SelectionPosition Editor::MovePositionSoVisible(int pos, int moveDir) {
+SelectionPosition Editor::MovePositionSoVisible(Sci::Position pos, int moveDir) {
 	return MovePositionSoVisible(SelectionPosition(pos), moveDir);
 }
 
@@ -908,15 +908,15 @@
  */
 void Editor::SetLastXChosen() {
 	Point pt = PointMainCaret();
-	lastXChosen = static_cast<int>(pt.x) + xOffset;
-}
-
-void Editor::ScrollTo(int line, bool moveThumb) {
-	int topLineNew = Platform::Clamp(line, 0, MaxScrollPos());
+	lastXChosen = static_cast<Sci::Position>(pt.x) + xOffset;
+}
+
+void Editor::ScrollTo(Sci::Line line, bool moveThumb) {
+	Sci::Line topLineNew = Platform::Clamp(line, 0, MaxScrollPos());
 	if (topLineNew != topLine) {
 		// Try to optimise small scrolls
 #ifndef UNDER_CE
-		int linesToMove = topLine - topLineNew;
+		Sci::Line linesToMove = topLine - topLineNew;
 		bool performBlit = (abs(linesToMove) <= 10) && (paintState == notPainting);
 		willRedrawAll = !performBlit;
 #endif
@@ -941,7 +941,7 @@
 	}
 }
 
-void Editor::ScrollText(int /* linesToMove */) {
+void Editor::ScrollText(Sci::Line /* linesToMove */) {
 	//Platform::DebugPrintf("Editor::ScrollText %d\n", linesToMove);
 	Redraw();
 }
@@ -959,9 +959,9 @@
 }
 
 void Editor::VerticalCentreCaret() {
-	int lineDoc = pdoc->LineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
-	int lineDisplay = cs.DisplayFromDoc(lineDoc);
-	int newTop = lineDisplay - (LinesOnScreen() / 2);
+	Sci::Line lineDoc = pdoc->LineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
+	Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
+	Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
 	if (topLine != newTop) {
 		SetTopLine(newTop > 0 ? newTop : 0);
 		RedrawRect(GetClientRectangle());
@@ -977,16 +977,16 @@
 void Editor::MoveSelectedLines(int lineDelta) {
 
 	// if selection doesn't start at the beginning of the line, set the new start
-	int selectionStart = SelectionStart().Position();
-	int startLine = pdoc->LineFromPosition(selectionStart);
-	int beginningOfStartLine = pdoc->LineStart(startLine);
+	Sci::Position selectionStart = SelectionStart().Position();
+	Sci::Line startLine = pdoc->LineFromPosition(selectionStart);
+	Sci::Position beginningOfStartLine = pdoc->LineStart(startLine);
 	selectionStart = beginningOfStartLine;
 
 	// if selection doesn't end at the beginning of a line greater than that of the start,
 	// then set it at the beginning of the next one
-	int selectionEnd = SelectionEnd().Position();
-	int endLine = pdoc->LineFromPosition(selectionEnd);
-	int beginningOfEndLine = pdoc->LineStart(endLine);
+	Sci::Position selectionEnd = SelectionEnd().Position();
+	Sci::Line endLine = pdoc->LineFromPosition(selectionEnd);
+	Sci::Position beginningOfEndLine = pdoc->LineStart(endLine);
 	bool appendEol = false;
 	if (selectionEnd > beginningOfEndLine
 		|| selectionStart == selectionEnd) {
@@ -1015,9 +1015,9 @@
 	SelectionText selectedText;
 	CopySelectionRange(&selectedText);
 
-	int selectionLength = SelectionRange(selectionStart, selectionEnd).Length();
+	Sci::Position selectionLength = SelectionRange(selectionStart, selectionEnd).Length();
 	Point currentLocation = LocationFromPosition(CurrentPosition());
-	int currentLine = LineFromLocation(currentLocation);
+	Sci::Line currentLine = LineFromLocation(currentLocation);
 
 	if (appendEol)
 		SetSelection(pdoc->MovePositionOutsideChar(selectionStart - 1, -1), selectionEnd);
@@ -1030,7 +1030,7 @@
 
 	selectionLength = pdoc->InsertString(CurrentPosition(), selectedText.Data(), selectionLength);
 	if (appendEol) {
-		const int lengthInserted = pdoc->InsertString(CurrentPosition() + selectionLength, eol, istrlen(eol));
+		const Sci::Position lengthInserted = pdoc->InsertString(CurrentPosition() + selectionLength, eol, istrlen(eol));
 		selectionLength += lengthInserted;
 	}
 	SetSelection(CurrentPosition(), CurrentPosition() + selectionLength);
@@ -1053,7 +1053,7 @@
 					false, false, UserVirtualSpace()),
 					Selection::noSel, ensureVisible);
 	} else if ((pt.y + vs.lineHeight - 1) > rcClient.bottom) {
-		int yOfLastLineFullyDisplayed = static_cast<int>(rcClient.top) + (LinesOnScreen() - 1) * vs.lineHeight;
+		Sci::Position yOfLastLineFullyDisplayed = static_cast<Sci::Position>(rcClient.top) + (LinesOnScreen() - 1) * vs.lineHeight;
 		MovePositionTo(SPositionFromLocation(
 		            Point::FromInts(lastXChosen - xOffset, static_cast<int>(rcClient.top) + yOfLastLineFullyDisplayed),
 					false, false, UserVirtualSpace()),
@@ -1061,7 +1061,7 @@
 	}
 }
 
-int Editor::DisplayFromPosition(int pos) {
+Sci::Line Editor::DisplayFromPosition(Sci::Position pos) {
 	AutoSurface surface(this);
 	return view.DisplayFromPosition(surface, *this, pos, vs);
 }
@@ -1130,9 +1130,9 @@
 
 	// Vertical positioning
 	if ((options & xysVertical) && (pt.y < rcClient.top || ptBottomCaret.y >= rcClient.bottom || (caretYPolicy & CARET_STRICT) != 0)) {
-		const int lineCaret = DisplayFromPosition(range.caret.Position());
-		const int linesOnScreen = LinesOnScreen();
-		const int halfScreen = Platform::Maximum(linesOnScreen - 1, 2) / 2;
+		const Sci::Line lineCaret = DisplayFromPosition(range.caret.Position());
+		const Sci::Line linesOnScreen = LinesOnScreen();
+		const Sci::Line halfScreen = Platform::Maximum(linesOnScreen - 1, 2) / 2;
 		const bool bSlop = (caretYPolicy & CARET_SLOP) != 0;
 		const bool bStrict = (caretYPolicy & CARET_STRICT) != 0;
 		const bool bJump = (caretYPolicy & CARET_JUMPS) != 0;
@@ -1141,9 +1141,9 @@
 		// It should be possible to scroll the window to show the caret,
 		// but this fails to remove the caret on GTK+
 		if (bSlop) {	// A margin is defined
-			int yMoveT, yMoveB;
+			Sci::Line yMoveT, yMoveB;
 			if (bStrict) {
-				int yMarginT, yMarginB;
+				Sci::Line yMarginT, yMarginB;
 				if (!(options & xysUseMargin)) {
 					// In drag mode, avoid moves
 					// otherwise, a double click will select several lines.
@@ -1215,7 +1215,7 @@
 			}
 		}
 		if (!(range.caret == range.anchor)) {
-			const int lineAnchor = DisplayFromPosition(range.anchor.Position());
+			const Sci::Line lineAnchor = DisplayFromPosition(range.anchor.Position());
 			if (lineAnchor < lineCaret) {
 				// Shift up to show anchor or as much of range as possible
 				newXY.topLine = std::min(newXY.topLine, lineAnchor);
@@ -1339,8 +1339,8 @@
 				newXY.xOffset = std::max(newXY.xOffset, minOffset);
 			} else {
 				// Shift to right to show anchor or as much of range as possible
-				int minOffset = static_cast<int>(ptAnchor.x + xOffset - rcClient.right) + 1;
-				int maxOffset = static_cast<int>(pt.x + xOffset - rcClient.left) - 1;
+				int minOffset = static_cast<Sci::Position>(ptAnchor.x + xOffset - rcClient.right) + 1;
+				int maxOffset = static_cast<Sci::Position>(pt.x + xOffset - rcClient.left) - 1;
 				newXY.xOffset = std::max(newXY.xOffset, minOffset);
 				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
 			}
@@ -1366,7 +1366,7 @@
 				PRectangle rcText = GetTextRectangle();
 				if (horizontalScrollBarVisible &&
 					rcText.Width() + xOffset > scrollWidth) {
-					scrollWidth = xOffset + static_cast<int>(rcText.Width());
+					scrollWidth = xOffset + static_cast<Sci::Position>(rcText.Width());
 					SetScrollBars();
 				}
 			}
@@ -1449,7 +1449,7 @@
 	return vs.wrapState != eWrapNone;
 }
 
-void Editor::NeedWrapping(int docLineStart, int docLineEnd) {
+void Editor::NeedWrapping(Sci::Line docLineStart, Sci::Line docLineEnd) {
 //Platform::DebugPrintf("\nNeedWrapping: %0d..%0d\n", docLineStart, docLineEnd);
 	if (wrapPending.AddRange(docLineStart, docLineEnd)) {
 		view.llc.Invalidate(LineLayout::llPositions);
@@ -1460,7 +1460,7 @@
 	}
 }
 
-bool Editor::WrapOneLine(Surface *surface, int lineToWrap) {
+bool Editor::WrapOneLine(Surface *surface, Sci::Line lineToWrap) {
 	AutoLineLayout ll(view.llc, view.RetrieveLineLayout(lineToWrap, *this));
 	int linesWrapped = 1;
 	if (ll) {
@@ -1477,12 +1477,12 @@
 // wsIdle: wrap one page + 100 lines
 // Return true if wrapping occurred.
 bool Editor::WrapLines(enum wrapScope ws) {
-	int goodTopLine = topLine;
+	Sci::Line goodTopLine = topLine;
 	bool wrapOccurred = false;
 	if (!Wrapping()) {
 		if (wrapWidth != LineLayout::wrapWidthInfinite) {
 			wrapWidth = LineLayout::wrapWidthInfinite;
-			for (int lineDoc = 0; lineDoc < pdoc->LinesTotal(); lineDoc++) {
+			for (Sci::Line lineDoc = 0; lineDoc < pdoc->LinesTotal(); lineDoc++) {
 				cs.SetHeight(lineDoc, 1 +
 					(vs.annotationVisible ? pdoc->AnnotationLines(lineDoc) : 0));
 			}
@@ -1497,9 +1497,9 @@
 			ws = WrapScope::wsAll;
 		}
 		// Decide where to start wrapping
-		int lineToWrap = wrapPending.start;
-		int lineToWrapEnd = std::min(wrapPending.end, pdoc->LinesTotal());
-		const int lineDocTop = cs.DocFromDisplay(topLine);
+		Sci::Line lineToWrap = wrapPending.start;
+		Sci::Line lineToWrapEnd = std::min(wrapPending.end, pdoc->LinesTotal());
+		const Sci::Line lineDocTop = cs.DocFromDisplay(topLine);
 		const int subLineTop = topLine - cs.DisplayFromDoc(lineDocTop);
 		if (ws == WrapScope::wsVisible) {
 			lineToWrap = Platform::Clamp(lineDocTop-5, wrapPending.start, pdoc->LinesTotal());
@@ -1507,7 +1507,7 @@
 			// Since wrapping could reduce display lines, treat each
 			// as taking only one display line.
 			lineToWrapEnd = lineDocTop;
-			int lines = LinesOnScreen() + 1;
+			Sci::Line lines = LinesOnScreen() + 1;
 			while ((lineToWrapEnd < cs.LinesInDoc()) && (lines>0)) {
 				if (cs.GetVisible(lineToWrapEnd))
 					lines--;
@@ -1521,7 +1521,7 @@
 		} else if (ws == WrapScope::wsIdle) {
 			lineToWrapEnd = lineToWrap + LinesOnScreen() + 100;
 		}
-		const int lineEndNeedWrap = std::min(wrapPending.end, pdoc->LinesTotal());
+		const Sci::Line lineEndNeedWrap = std::min(wrapPending.end, pdoc->LinesTotal());
 		lineToWrapEnd = std::min(lineToWrapEnd, lineEndNeedWrap);
 
 		// Ensure all lines being wrapped are styled.
@@ -1569,13 +1569,13 @@
 	if (!RangeContainsProtected(targetStart, targetEnd)) {
 		UndoGroup ug(pdoc);
 		bool prevNonWS = true;
-		for (int pos = targetStart; pos < targetEnd; pos++) {
+		for (Sci::Position pos = targetStart; pos < targetEnd; pos++) {
 			if (pdoc->IsPositionInLineEnd(pos)) {
 				targetEnd -= pdoc->LenChar(pos);
 				pdoc->DelChar(pos);
 				if (prevNonWS) {
 					// Ensure at least one space separating previous lines
-					const int lengthInserted = pdoc->InsertString(pos, " ", 1);
+					const Sci::Position lengthInserted = pdoc->InsertString(pos, " ", 1);
 					targetEnd += lengthInserted;
 				}
 			} else {
@@ -1601,19 +1601,19 @@
 			PRectangle rcText = GetTextRectangle();
 			pixelWidth = static_cast<int>(rcText.Width());
 		}
-		int lineStart = pdoc->LineFromPosition(targetStart);
-		int lineEnd = pdoc->LineFromPosition(targetEnd);
+		Sci::Line lineStart = pdoc->LineFromPosition(targetStart);
+		Sci::Line lineEnd = pdoc->LineFromPosition(targetEnd);
 		const char *eol = StringFromEOLMode(pdoc->eolMode);
 		UndoGroup ug(pdoc);
-		for (int line = lineStart; line <= lineEnd; line++) {
+		for (Sci::Line line = lineStart; line <= lineEnd; line++) {
 			AutoSurface surface(this);
 			AutoLineLayout ll(view.llc, view.RetrieveLineLayout(line, *this));
 			if (surface && ll) {
-				unsigned int posLineStart = pdoc->LineStart(line);
+				Sci::Position posLineStart = pdoc->LineStart(line);
 				view.LayoutLine(*this, line, surface, vs, ll, pixelWidth);
-				int lengthInsertedTotal = 0;
+				Sci::Position lengthInsertedTotal = 0;
 				for (int subLine = 1; subLine < ll->lines; subLine++) {
-					const int lengthInserted = pdoc->InsertString(
+					const Sci::Position lengthInserted = pdoc->InsertString(
 						static_cast<int>(posLineStart + lengthInsertedTotal +
 							ll->LineStart(subLine)),
 							eol, istrlen(eol));
@@ -1803,8 +1803,8 @@
 void Editor::SetScrollBars() {
 	RefreshStyleData();
 
-	int nMax = MaxScrollPos();
-	int nPage = LinesOnScreen();
+	Sci::Line nMax = MaxScrollPos();
+	Sci::Line nPage = LinesOnScreen();
 	bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
 	if (modified) {
 		DwellEnd(true);
@@ -1838,15 +1838,15 @@
 	}
 }
 
-int Editor::RealizeVirtualSpace(int position, unsigned int virtualSpace) {
+Sci::Position Editor::RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace) {
 	if (virtualSpace > 0) {
-		const int line = pdoc->LineFromPosition(position);
-		const int indent = pdoc->GetLineIndentPosition(line);
+		const Sci::Line line = pdoc->LineFromPosition(position);
+		const Sci::Position indent = pdoc->GetLineIndentPosition(line);
 		if (indent == position) {
 			return pdoc->SetLineIndentation(line, pdoc->GetLineIndentation(line) + virtualSpace);
 		} else {
 			std::string spaceText(virtualSpace, ' ');
-			const int lengthInserted = pdoc->InsertString(position, spaceText.c_str(), virtualSpace);
+			const Sci::Position lengthInserted = pdoc->InsertString(position, spaceText.c_str(), virtualSpace);
 			position += lengthInserted;
 		}
 	}
@@ -1893,7 +1893,7 @@
 			SelectionRange *currentSel = *rit;
 			if (!RangeContainsProtected(currentSel->Start().Position(),
 				currentSel->End().Position())) {
-				int positionInsert = currentSel->Start().Position();
+				Sci::Position positionInsert = currentSel->Start().Position();
 				if (!currentSel->Empty()) {
 					if (currentSel->Length()) {
 						pdoc->DeleteChars(positionInsert, currentSel->Length());
@@ -1911,7 +1911,7 @@
 					}
 				}
 				positionInsert = RealizeVirtualSpace(positionInsert, currentSel->caret.VirtualSpace());
-				const int lengthInserted = pdoc->InsertString(positionInsert, s, len);
+				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, s, len);
 				if (lengthInserted > 0) {
 					currentSel->caret.SetPosition(positionInsert + lengthInserted);
 					currentSel->anchor.SetPosition(positionInsert + lengthInserted);
@@ -1974,7 +1974,7 @@
 	for (size_t r = 0; r<sel.Count(); r++) {
 		if (!RangeContainsProtected(sel.Range(r).Start().Position(),
 			sel.Range(r).End().Position())) {
-			int positionInsert = sel.Range(r).Start().Position();
+			Sci::Position positionInsert = sel.Range(r).Start().Position();
 			if (!sel.Range(r).Empty()) {
 				if (sel.Range(r).Length()) {
 					pdoc->DeleteChars(positionInsert, sel.Range(r).Length());
@@ -1994,7 +1994,7 @@
 	if (multiPasteMode == SC_MULTIPASTE_ONCE) {
 		SelectionPosition selStart = sel.Start();
 		selStart = RealizeVirtualSpace(selStart);
-		const int lengthInserted = pdoc->InsertString(selStart.Position(), text, len);
+		const Sci::Position lengthInserted = pdoc->InsertString(selStart.Position(), text, len);
 		if (lengthInserted > 0) {
 			SetEmptySelection(selStart.Position() + lengthInserted);
 		}
@@ -2003,7 +2003,7 @@
 		for (size_t r=0; r<sel.Count(); r++) {
 			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
 				sel.Range(r).End().Position())) {
-				int positionInsert = sel.Range(r).Start().Position();
+				Sci::Position positionInsert = sel.Range(r).Start().Position();
 				if (!sel.Range(r).Empty()) {
 					if (sel.Range(r).Length()) {
 						pdoc->DeleteChars(positionInsert, sel.Range(r).Length());
@@ -2014,7 +2014,7 @@
 					}
 				}
 				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
-				const int lengthInserted = pdoc->InsertString(positionInsert, text, len);
+				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, text, len);
 				if (lengthInserted > 0) {
 					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
 					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
@@ -2037,8 +2037,8 @@
 		PasteRectangular(sel.Start(), text, len);
 	} else {
 		if (shape == pasteLine) {
-			int insertPos = pdoc->LineStart(pdoc->LineFromPosition(sel.MainCaret()));
-			int lengthInserted = pdoc->InsertString(insertPos, text, len);
+			Sci::Position insertPos = pdoc->LineStart(pdoc->LineFromPosition(sel.MainCaret()));
+			Sci::Position lengthInserted = pdoc->InsertString(insertPos, text, len);
 			// add the newline if necessary
 			if ((len > 0) && (text[len - 1] != '\n' && text[len - 1] != '\r')) {
 				const char *endline = StringFromEOLMode(pdoc->eolMode);
@@ -2127,20 +2127,20 @@
 	}
 }
 
-void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, int len) {
+void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len) {
 	if (pdoc->IsReadOnly() || SelectionContainsProtected()) {
 		return;
 	}
 	sel.Clear();
 	sel.RangeMain() = SelectionRange(pos);
-	int line = pdoc->LineFromPosition(sel.MainCaret());
+	Sci::Line line = pdoc->LineFromPosition(sel.MainCaret());
 	UndoGroup ug(pdoc);
 	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
 	int xInsert = XFromPosition(sel.RangeMain().caret);
 	bool prevCr = false;
 	while ((len > 0) && IsEOLChar(ptr[len-1]))
 		len--;
-	for (int i = 0; i < len; i++) {
+	for (Sci::Position i = 0; i < len; i++) {
 		if (IsEOLChar(ptr[i])) {
 			if ((ptr[i] == '\r') || (!prevCr))
 				line++;
@@ -2155,13 +2155,13 @@
 			if ((XFromPosition(sel.MainCaret()) < xInsert) && (i + 1 < len)) {
 				while (XFromPosition(sel.MainCaret()) < xInsert) {
 					assert(pdoc);
-					const int lengthInserted = pdoc->InsertString(sel.MainCaret(), " ", 1);
+					const Sci::Position lengthInserted = pdoc->InsertString(sel.MainCaret(), " ", 1);
 					sel.RangeMain().caret.Add(lengthInserted);
 				}
 			}
 			prevCr = ptr[i] == '\r';
 		} else {
-			const int lengthInserted = pdoc->InsertString(sel.MainCaret(), ptr + i, 1);
+			const Sci::Position lengthInserted = pdoc->InsertString(sel.MainCaret(), ptr + i, 1);
 			sel.RangeMain().caret.Add(lengthInserted);
 			prevCr = false;
 		}
@@ -2215,7 +2215,7 @@
 void Editor::Undo() {
 	if (pdoc->CanUndo()) {
 		InvalidateCaret();
-		int newPos = pdoc->Undo();
+		Sci::Position newPos = pdoc->Undo();
 		if (newPos >= 0)
 			SetEmptySelection(newPos);
 		EnsureCaretVisible();
@@ -2224,7 +2224,7 @@
 
 void Editor::Redo() {
 	if (pdoc->CanRedo()) {
-		int newPos = pdoc->Redo();
+		Sci::Position newPos = pdoc->Redo();
 		if (newPos >= 0)
 			SetEmptySelection(newPos);
 		EnsureCaretVisible();
@@ -2245,7 +2245,7 @@
 					sel.Range(r).caret.SetVirtualSpace(sel.Range(r).caret.VirtualSpace() - 1);
 					sel.Range(r).anchor.SetVirtualSpace(sel.Range(r).caret.VirtualSpace());
 				} else {
-					int lineCurrentPos = pdoc->LineFromPosition(sel.Range(r).caret.Position());
+					Sci::Line lineCurrentPos = pdoc->LineFromPosition(sel.Range(r).caret.Position());
 					if (allowLineStartDeletion || (pdoc->LineStart(lineCurrentPos) != sel.Range(r).caret.Position())) {
 						if (pdoc->GetColumn(sel.Range(r).caret.Position()) <= pdoc->GetLineIndentation(lineCurrentPos) &&
 								pdoc->GetColumn(sel.Range(r).caret.Position()) > 0 && pdoc->backspaceUnindents) {
@@ -2255,7 +2255,7 @@
 							int indentationChange = indentation % indentationStep;
 							if (indentationChange == 0)
 								indentationChange = indentationStep;
-							const int posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationChange);
+							const Sci::Position posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationChange);
 							// SetEmptySelection
 							sel.Range(r) = SelectionRange(posSelect);
 						} else {
@@ -2296,14 +2296,14 @@
 	ctrlID = identifier;
 }
 
-void Editor::NotifyStyleToNeeded(int endStyleNeeded) {
+void Editor::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_STYLENEEDED;
 	scn.position = endStyleNeeded;
 	NotifyParent(scn);
 }
 
-void Editor::NotifyStyleNeeded(Document *, void *, int endStyleNeeded) {
+void Editor::NotifyStyleNeeded(Document *, void *, Sci::Position endStyleNeeded) {
 	NotifyStyleToNeeded(endStyleNeeded);
 }
 
@@ -2350,7 +2350,7 @@
 	NotifyDoubleClick(pt, ModifierFlags(shift, ctrl, alt));
 }
 
-void Editor::NotifyHotSpotDoubleClicked(int position, int modifiers) {
+void Editor::NotifyHotSpotDoubleClicked(Sci::Position position, int modifiers) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_HOTSPOTDOUBLECLICK;
 	scn.position = position;
@@ -2358,11 +2358,11 @@
 	NotifyParent(scn);
 }
 
-void Editor::NotifyHotSpotDoubleClicked(int position, bool shift, bool ctrl, bool alt) {
+void Editor::NotifyHotSpotDoubleClicked(Sci::Position position, bool shift, bool ctrl, bool alt) {
 	NotifyHotSpotDoubleClicked(position, ModifierFlags(shift, ctrl, alt));
 }
 
-void Editor::NotifyHotSpotClicked(int position, int modifiers) {
+void Editor::NotifyHotSpotClicked(Sci::Position position, int modifiers) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_HOTSPOTCLICK;
 	scn.position = position;
@@ -2370,11 +2370,11 @@
 	NotifyParent(scn);
 }
 
-void Editor::NotifyHotSpotClicked(int position, bool shift, bool ctrl, bool alt) {
+void Editor::NotifyHotSpotClicked(Sci::Position position, bool shift, bool ctrl, bool alt) {
 	NotifyHotSpotClicked(position, ModifierFlags(shift, ctrl, alt));
 }
 
-void Editor::NotifyHotSpotReleaseClick(int position, int modifiers) {
+void Editor::NotifyHotSpotReleaseClick(Sci::Position position, int modifiers) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_HOTSPOTRELEASECLICK;
 	scn.position = position;
@@ -2382,7 +2382,7 @@
 	NotifyParent(scn);
 }
 
-void Editor::NotifyHotSpotReleaseClick(int position, bool shift, bool ctrl, bool alt) {
+void Editor::NotifyHotSpotReleaseClick(Sci::Position position, bool shift, bool ctrl, bool alt) {
 	NotifyHotSpotReleaseClick(position, ModifierFlags(shift, ctrl, alt));
 }
 
@@ -2404,7 +2404,7 @@
 	NotifyParent(scn);
 }
 
-void Editor::NotifyIndicatorClick(bool click, int position, int modifiers) {
+void Editor::NotifyIndicatorClick(bool click, Sci::Position position, int modifiers) {
 	int mask = pdoc->decorations.AllOnFor(position);
 	if ((click && mask) || pdoc->decorations.clickNotified) {
 		SCNotification scn = {};
@@ -2416,18 +2416,18 @@
 	}
 }
 
-void Editor::NotifyIndicatorClick(bool click, int position, bool shift, bool ctrl, bool alt) {
+void Editor::NotifyIndicatorClick(bool click, Sci::Position position, bool shift, bool ctrl, bool alt) {
 	NotifyIndicatorClick(click, position, ModifierFlags(shift, ctrl, alt));
 }
 
 bool Editor::NotifyMarginClick(Point pt, int modifiers) {
 	const int marginClicked = vs.MarginFromLocation(pt);
 	if ((marginClicked >= 0) && vs.ms[marginClicked].sensitive) {
-		int position = pdoc->LineStart(LineFromLocation(pt));
+		Sci::Position position = pdoc->LineStart(LineFromLocation(pt));
 		if ((vs.ms[marginClicked].mask & SC_MASK_FOLDERS) && (foldAutomatic & SC_AUTOMATICFOLD_CLICK)) {
 			const bool ctrl = (modifiers & SCI_CTRL) != 0;
 			const bool shift = (modifiers & SCI_SHIFT) != 0;
-			int lineClick = pdoc->LineFromPosition(position);
+			Sci::Line lineClick = pdoc->LineFromPosition(position);
 			if (shift && ctrl) {
 				FoldAll(SC_FOLDACTION_TOGGLE);
 			} else {
@@ -2465,7 +2465,7 @@
 bool Editor::NotifyMarginRightClick(Point pt, int modifiers) {
 	int marginRightClicked = vs.MarginFromLocation(pt);
 	if ((marginRightClicked >= 0) && vs.ms[marginRightClicked].sensitive) {
-		int position = pdoc->LineStart(LineFromLocation(pt));
+		Sci::Position position = pdoc->LineStart(LineFromLocation(pt));
 		SCNotification scn = {};
 		scn.nmhdr.code = SCN_MARGINRIGHTCLICK;
 		scn.modifiers = modifiers;
@@ -2478,7 +2478,7 @@
 	}
 }
 
-void Editor::NotifyNeedShown(int pos, int len) {
+void Editor::NotifyNeedShown(Sci::Position pos, Sci::Position len) {
 	SCNotification scn = {};
 	scn.nmhdr.code = SCN_NEEDSHOWN;
 	scn.position = pos;
@@ -2515,8 +2515,8 @@
 void Editor::CheckModificationForWrap(DocModification mh) {
 	if (mh.modificationType & (SC_MOD_INSERTTEXT | SC_MOD_DELETETEXT)) {
 		view.llc.Invalidate(LineLayout::llCheckTextAndStyle);
-		int lineDoc = pdoc->LineFromPosition(mh.position);
-		int lines = Platform::Maximum(0, mh.linesAdded);
+		Sci::Line lineDoc = pdoc->LineFromPosition(mh.position);
+		Sci::Line lines = std::max(static_cast<Sci::Line>(0), mh.linesAdded);
 		if (Wrapping()) {
 			NeedWrapping(lineDoc, lineDoc + lines + 1);
 		}
@@ -2527,7 +2527,7 @@
 }
 
 // Move a position so it is still after the same character as before the insertion.
-static inline int MovePositionForInsertion(int position, int startInsertion, int length) {
+static inline Sci::Position MovePositionForInsertion(Sci::Position position, Sci::Position startInsertion, Sci::Position length) {
 	if (position > startInsertion) {
 		return position + length;
 	}
@@ -2536,9 +2536,9 @@
 
 // Move a position so it is still after the same character as before the deletion if that
 // character is still present else after the previous surviving character.
-static inline int MovePositionForDeletion(int position, int startDeletion, int length) {
+static inline Sci::Position MovePositionForDeletion(Sci::Position position, Sci::Position startDeletion, Sci::Position length) {
 	if (position > startDeletion) {
-		int endDeletion = startDeletion + length;
+		Sci::Position endDeletion = startDeletion + length;
 		if (position > endDeletion) {
 			return position - length;
 		} else {
@@ -2602,17 +2602,17 @@
 		}
 		if ((mh.modificationType & (SC_MOD_BEFOREINSERT | SC_MOD_BEFOREDELETE)) && cs.HiddenLines()) {
 			// Some lines are hidden so may need shown.
-			const int lineOfPos = pdoc->LineFromPosition(mh.position);
-			int endNeedShown = mh.position;
+			const Sci::Line lineOfPos = pdoc->LineFromPosition(mh.position);
+			Sci::Position endNeedShown = mh.position;
 			if (mh.modificationType & SC_MOD_BEFOREINSERT) {
 				if (pdoc->ContainsLineEnd(mh.text, mh.length) && (mh.position != pdoc->LineStart(lineOfPos)))
 					endNeedShown = pdoc->LineStart(lineOfPos+1);
 			} else if (mh.modificationType & SC_MOD_BEFOREDELETE) {
 				// If the deletion includes any EOL then we extend the need shown area.
 				endNeedShown = mh.position + mh.length;
-				int lineLast = pdoc->LineFromPosition(mh.position+mh.length);
-				for (int line = lineOfPos + 1; line <= lineLast; line++) {
-					const int lineMaxSubord = pdoc->GetLastChild(line, -1, -1);
+				Sci::Line lineLast = pdoc->LineFromPosition(mh.position+mh.length);
+				for (Sci::Line line = lineOfPos + 1; line <= lineLast; line++) {
+					const Sci::Line lineMaxSubord = pdoc->GetLastChild(line, -1, -1);
 					if (lineLast < lineMaxSubord) {
 						lineLast = lineMaxSubord;
 						endNeedShown = pdoc->LineEnd(lineLast);
@@ -2624,7 +2624,7 @@
 		if (mh.linesAdded != 0) {
 			// Update contraction state for inserted and removed lines
 			// lineOfPos should be calculated in context of state before modification, shouldn't it
-			int lineOfPos = pdoc->LineFromPosition(mh.position);
+			Sci::Line lineOfPos = pdoc->LineFromPosition(mh.position);
 			if (mh.position > pdoc->LineStart(lineOfPos))
 				lineOfPos++;	// Affecting subsequent lines
 			if (mh.linesAdded > 0) {
@@ -2635,7 +2635,7 @@
 			view.LinesAddedOrRemoved(lineOfPos, mh.linesAdded);
 		}
 		if (mh.modificationType & SC_MOD_CHANGEANNOTATION) {
-			int lineDoc = pdoc->LineFromPosition(mh.position);
+			Sci::Line lineDoc = pdoc->LineFromPosition(mh.position);
 			if (vs.annotationVisible) {
 				cs.SetHeight(lineDoc, cs.GetHeight(lineDoc) + mh.annotationLinesAdded);
 				Redraw();
@@ -2645,7 +2645,7 @@
 		if (mh.linesAdded != 0) {
 			// Avoid scrolling of display if change before current display
 			if (mh.position < posTopLine && !CanDeferToLastStep(mh)) {
-				int newTop = Platform::Clamp(topLine + mh.linesAdded, 0, MaxScrollPos());
+				Sci::Line newTop = Platform::Clamp(topLine + mh.linesAdded, 0, MaxScrollPos());
 				if (newTop != topLine) {
 					SetTopLine(newTop);
 					SetVerticalScrollPos();
@@ -2857,12 +2857,12 @@
  * If stuttered = true and already at first/last row, scroll as normal.
  */
 void Editor::PageMove(int direction, Selection::selTypes selt, bool stuttered) {
-	int topLineNew;
+	Sci::Line topLineNew;
 	SelectionPosition newPos;
 
-	int currentLine = pdoc->LineFromPosition(sel.MainCaret());
-	int topStutterLine = topLine + caretYSlop;
-	int bottomStutterLine =
+	Sci::Line currentLine = pdoc->LineFromPosition(sel.MainCaret());
+	Sci::Line topStutterLine = topLine + caretYSlop;
+	Sci::Line bottomStutterLine =
 	    pdoc->LineFromPosition(PositionFromLocation(
 	                Point::FromInts(lastXChosen - xOffset, direction * vs.lineHeight * LinesToScroll())))
 	    - caretYSlop - 1;
@@ -2921,15 +2921,15 @@
 				}
 				size_t endDifferenceText = sText.size() - 1 - lastDifferenceText;
 				pdoc->DeleteChars(
-					static_cast<int>(currentNoVS.Start().Position() + firstDifference),
-					static_cast<int>(rangeBytes - firstDifference - endDifferenceText));
-				const int lengthChange = static_cast<int>(lastDifferenceMapped - firstDifference + 1);
-				const int lengthInserted = pdoc->InsertString(
+					static_cast<Sci::Position>(currentNoVS.Start().Position() + firstDifference),
+					static_cast<Sci::Position>(rangeBytes - firstDifference - endDifferenceText));
+				const Sci::Position lengthChange = static_cast<Sci::Position>(lastDifferenceMapped - firstDifference + 1);
+				const Sci::Position lengthInserted = pdoc->InsertString(
 					static_cast<int>(currentNoVS.Start().Position() + firstDifference),
 					sMapped.c_str() + firstDifference,
 					lengthChange);
 				// Automatic movement changes selection so reset to exactly the same as it was.
-				int diffSizes = static_cast<int>(sMapped.size() - sText.size()) + lengthInserted - lengthChange;
+				Sci::Position diffSizes = static_cast<Sci::Position>(sMapped.size() - sText.size()) + lengthInserted - lengthChange;
 				if (diffSizes != 0) {
 					if (current.anchor > current.caret)
 						current.anchor.Add(diffSizes);
@@ -2943,24 +2943,24 @@
 }
 
 void Editor::LineTranspose() {
-	int line = pdoc->LineFromPosition(sel.MainCaret());
+	Sci::Line line = pdoc->LineFromPosition(sel.MainCaret());
 	if (line > 0) {
 		UndoGroup ug(pdoc);
 
-		const int startPrevious = pdoc->LineStart(line - 1);
+		const Sci::Position startPrevious = pdoc->LineStart(line - 1);
 		const std::string linePrevious = RangeText(startPrevious, pdoc->LineEnd(line - 1));
 
-		int startCurrent = pdoc->LineStart(line);
+		Sci::Position startCurrent = pdoc->LineStart(line);
 		const std::string lineCurrent = RangeText(startCurrent, pdoc->LineEnd(line));
 
-		pdoc->DeleteChars(startCurrent, static_cast<int>(lineCurrent.length()));
-		pdoc->DeleteChars(startPrevious, static_cast<int>(linePrevious.length()));
-		startCurrent -= static_cast<int>(linePrevious.length());
+		pdoc->DeleteChars(startCurrent, static_cast<Sci::Position>(lineCurrent.length()));
+		pdoc->DeleteChars(startPrevious, static_cast<Sci::Position>(linePrevious.length()));
+		startCurrent -= static_cast<Sci::Position>(linePrevious.length());
 
 		startCurrent += pdoc->InsertString(startPrevious, lineCurrent.c_str(),
-			static_cast<int>(lineCurrent.length()));
+			static_cast<Sci::Position>(lineCurrent.length()));
 		pdoc->InsertString(startCurrent, linePrevious.c_str(),
-			static_cast<int>(linePrevious.length()));
+			static_cast<Sci::Position>(linePrevious.length()));
 		// Move caret to start of current line
 		MovePositionTo(SelectionPosition(startCurrent));
 	}
@@ -2981,20 +2981,20 @@
 		SelectionPosition start = sel.Range(r).Start();
 		SelectionPosition end = sel.Range(r).End();
 		if (forLine) {
-			int line = pdoc->LineFromPosition(sel.Range(r).caret.Position());
+			Sci::Line line = pdoc->LineFromPosition(sel.Range(r).caret.Position());
 			start = SelectionPosition(pdoc->LineStart(line));
 			end = SelectionPosition(pdoc->LineEnd(line));
 		}
 		std::string text = RangeText(start.Position(), end.Position());
-		int lengthInserted = eolLen;
+		Sci::Position lengthInserted = eolLen;
 		if (forLine)
 			lengthInserted = pdoc->InsertString(end.Position(), eol, eolLen);
-		pdoc->InsertString(end.Position() + lengthInserted, text.c_str(), static_cast<int>(text.length()));
+		pdoc->InsertString(end.Position() + lengthInserted, text.c_str(), static_cast<Sci::Position>(text.length()));
 	}
 	if (sel.Count() && sel.IsRectangular()) {
 		SelectionPosition last = sel.Last();
 		if (forLine) {
-			int line = pdoc->LineFromPosition(last.Position());
+			Sci::Line line = pdoc->LineFromPosition(last.Position());
 			last = SelectionPosition(last.Position() + pdoc->LineStart(line+1) - pdoc->LineStart(line));
 		}
 		if (sel.Rectangular().anchor > sel.Rectangular().caret)
@@ -3028,8 +3028,8 @@
 	for (size_t r = 0; r < sel.Count(); r++) {
 		sel.Range(r).ClearVirtualSpace();
 		const char *eol = StringFromEOLMode(pdoc->eolMode);
-		const int positionInsert = sel.Range(r).caret.Position();
-		const int insertLength = pdoc->InsertString(positionInsert, eol, istrlen(eol));
+		const Sci::Position positionInsert = sel.Range(r).caret.Position();
+		const Sci::Position insertLength = pdoc->InsertString(positionInsert, eol, istrlen(eol));
 		if (insertLength > 0) {
 			sel.Range(r) = SelectionRange(positionInsert + insertLength);
 			countInsertions++;
@@ -3064,12 +3064,12 @@
 	int skipLines = 0;
 
 	if (vs.annotationVisible) {
-		const int lineDoc = pdoc->LineFromPosition(spStart.Position());
+		const Sci::Line lineDoc = pdoc->LineFromPosition(spStart.Position());
 		const Point ptStartLine = LocationFromPosition(pdoc->LineStart(lineDoc));
 		const int subLine = static_cast<int>(pt.y - ptStartLine.y) / vs.lineHeight;
 
 		if (direction < 0 && subLine == 0) {
-			const int lineDisplay = cs.DisplayFromDoc(lineDoc);
+			const Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
 			if (lineDisplay > 0) {
 				skipLines = pdoc->AnnotationLines(cs.DocFromDisplay(lineDisplay - 1));
 			}
@@ -3078,9 +3078,9 @@
 		}
 	}
 
-	const int newY = static_cast<int>(pt.y) + (1 + skipLines) * direction * vs.lineHeight;
+	const Sci::Line newY = static_cast<Sci::Line>(pt.y) + (1 + skipLines) * direction * vs.lineHeight;
 	if (lastX < 0) {
-		lastX = static_cast<int>(pt.x) + xOffset;
+		lastX = static_cast<Sci::Position>(pt.x) + xOffset;
 	}
 	SelectionPosition posNew = SPositionFromLocation(
 		Point::FromInts(lastX - xOffset, newY), false, false, UserVirtualSpace());
@@ -3151,7 +3151,8 @@
 }
 
 void Editor::ParaUpOrDown(int direction, Selection::selTypes selt) {
-	int lineDoc, savedPos = sel.MainCaret();
+	Sci::Line lineDoc;
+	Sci::Position savedPos = sel.MainCaret();
 	do {
 		MovePositionTo(SelectionPosition(direction > 0 ? pdoc->ParaDown(sel.MainCaret()) : pdoc->ParaUp(sel.MainCaret())), selt);
 		lineDoc = pdoc->LineFromPosition(sel.MainCaret());
@@ -3166,16 +3167,16 @@
 	} while (!cs.GetVisible(lineDoc));
 }
 
-Range Editor::RangeDisplayLine(int lineVisible) {
+Range Editor::RangeDisplayLine(Sci::Line lineVisible) {
 	RefreshStyleData();
 	AutoSurface surface(this);
 	return view.RangeDisplayLine(surface, *this, lineVisible, vs);
 }
 
-int Editor::StartEndDisplayLine(int pos, bool start) {
+Sci::Position Editor::StartEndDisplayLine(Sci::Position pos, bool start) {
 	RefreshStyleData();
 	AutoSurface surface(this);
-	int posRet = view.StartEndDisplayLine(surface, *this, pos, start, vs);
+	Sci::Position posRet = view.StartEndDisplayLine(surface, *this, pos, start, vs);
 	if (posRet == INVALID_POSITION) {
 		return pos;
 	} else {
@@ -3258,27 +3259,27 @@
 
 }
 
-int Editor::VCHomeDisplayPosition(int position) {
-	const int homePos = pdoc->VCHomePosition(position);
-	const int viewLineStart = StartEndDisplayLine(position, true);
+Sci::Position Editor::VCHomeDisplayPosition(Sci::Position position) {
+	const Sci::Position homePos = pdoc->VCHomePosition(position);
+	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
 	if (viewLineStart > homePos)
 		return viewLineStart;
 	else
 		return homePos;
 }
 
-int Editor::VCHomeWrapPosition(int position) {
-	const int homePos = pdoc->VCHomePosition(position);
-	const int viewLineStart = StartEndDisplayLine(position, true);
+Sci::Position Editor::VCHomeWrapPosition(Sci::Position position) {
+	const Sci::Position homePos = pdoc->VCHomePosition(position);
+	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
 	if ((viewLineStart < position) && (viewLineStart > homePos))
 		return viewLineStart;
 	else
 		return homePos;
 }
 
-int Editor::LineEndWrapPosition(int position) {
-	const int endPos = StartEndDisplayLine(position, false);
-	const int realEndPos = pdoc->LineEndPosition(position);
+Sci::Position Editor::LineEndWrapPosition(Sci::Position position) {
+	const Sci::Position endPos = StartEndDisplayLine(position, false);
+	const Sci::Position realEndPos = pdoc->LineEndPosition(position);
 	if (endPos > realEndPos      // if moved past visible EOLs
 		|| position >= endPos) // if at end of display line already
 		return realEndPos;
@@ -3781,26 +3782,26 @@
 		return DelWordOrLine(iMessage);
 
 	case SCI_LINECOPY: {
-			int lineStart = pdoc->LineFromPosition(SelectionStart().Position());
-			int lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
+			Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
+			Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
 			CopyRangeToClipboard(pdoc->LineStart(lineStart),
 			        pdoc->LineStart(lineEnd + 1));
 		}
 		break;
 	case SCI_LINECUT: {
-			int lineStart = pdoc->LineFromPosition(SelectionStart().Position());
-			int lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
-			int start = pdoc->LineStart(lineStart);
-			int end = pdoc->LineStart(lineEnd + 1);
+			Sci::Line lineStart = pdoc->LineFromPosition(SelectionStart().Position());
+			Sci::Line lineEnd = pdoc->LineFromPosition(SelectionEnd().Position());
+			Sci::Position start = pdoc->LineStart(lineStart);
+			Sci::Position end = pdoc->LineStart(lineEnd + 1);
 			SetSelection(start, end);
 			Cut();
 			SetLastXChosen();
 		}
 		break;
 	case SCI_LINEDELETE: {
-			int line = pdoc->LineFromPosition(sel.MainCaret());
-			int start = pdoc->LineStart(line);
-			int end = pdoc->LineStart(line + 1);
+			Sci::Line line = pdoc->LineFromPosition(sel.MainCaret());
+			Sci::Position start = pdoc->LineStart(line);
+			Sci::Position end = pdoc->LineStart(line + 1);
 			pdoc->DeleteChars(start, end - start);
 		}
 		break;
@@ -3854,9 +3855,9 @@
 void Editor::Indent(bool forwards) {
 	UndoGroup ug(pdoc);
 	for (size_t r=0; r<sel.Count(); r++) {
-		int lineOfAnchor = pdoc->LineFromPosition(sel.Range(r).anchor.Position());
-		int caretPosition = sel.Range(r).caret.Position();
-		int lineCurrentPos = pdoc->LineFromPosition(caretPosition);
+		Sci::Line lineOfAnchor = pdoc->LineFromPosition(sel.Range(r).anchor.Position());
+		Sci::Position caretPosition = sel.Range(r).caret.Position();
+		Sci::Line lineCurrentPos = pdoc->LineFromPosition(caretPosition);
 		if (lineOfAnchor == lineCurrentPos) {
 			if (forwards) {
 				pdoc->DeleteChars(sel.Range(r).Start().Position(), sel.Range(r).Length());
@@ -3865,12 +3866,12 @@
 						pdoc->tabIndents) {
 					int indentation = pdoc->GetLineIndentation(lineCurrentPos);
 					int indentationStep = pdoc->IndentSize();
-					const int posSelect = pdoc->SetLineIndentation(
+					const Sci::Position posSelect = pdoc->SetLineIndentation(
 						lineCurrentPos, indentation + indentationStep - indentation % indentationStep);
 					sel.Range(r) = SelectionRange(posSelect);
 				} else {
 					if (pdoc->useTabs) {
-						const int lengthInserted = pdoc->InsertString(caretPosition, "\t", 1);
+						const Sci::Position lengthInserted = pdoc->InsertString(caretPosition, "\t", 1);
 						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
 					} else {
 						int numSpaces = (pdoc->tabInChars) -
@@ -3878,8 +3879,8 @@
 						if (numSpaces < 1)
 							numSpaces = pdoc->tabInChars;
 						const std::string spaceText(numSpaces, ' ');
-						const int lengthInserted = pdoc->InsertString(caretPosition, spaceText.c_str(),
-							static_cast<int>(spaceText.length()));
+						const Sci::Position lengthInserted = pdoc->InsertString(caretPosition, spaceText.c_str(),
+							static_cast<Sci::Position>(spaceText.length()));
 						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
 					}
 				}
@@ -3888,25 +3889,25 @@
 						pdoc->tabIndents) {
 					int indentation = pdoc->GetLineIndentation(lineCurrentPos);
 					int indentationStep = pdoc->IndentSize();
-					const int posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationStep);
+					const Sci::Position posSelect = pdoc->SetLineIndentation(lineCurrentPos, indentation - indentationStep);
 					sel.Range(r) = SelectionRange(posSelect);
 				} else {
-					int newColumn = ((pdoc->GetColumn(caretPosition) - 1) / pdoc->tabInChars) *
+					Sci::Position newColumn = ((pdoc->GetColumn(caretPosition) - 1) / pdoc->tabInChars) *
 							pdoc->tabInChars;
 					if (newColumn < 0)
 						newColumn = 0;
-					int newPos = caretPosition;
+					Sci::Position newPos = caretPosition;
 					while (pdoc->GetColumn(newPos) > newColumn)
 						newPos--;
 					sel.Range(r) = SelectionRange(newPos);
 				}
 			}
 		} else {	// Multiline
-			int anchorPosOnLine = sel.Range(r).anchor.Position() - pdoc->LineStart(lineOfAnchor);
-			int currentPosPosOnLine = caretPosition - pdoc->LineStart(lineCurrentPos);
+			Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() - pdoc->LineStart(lineOfAnchor);
+			Sci::Position currentPosPosOnLine = caretPosition - pdoc->LineStart(lineCurrentPos);
 			// Multiple lines selected so indent / dedent
-			int lineTopSel = Platform::Minimum(lineOfAnchor, lineCurrentPos);
-			int lineBottomSel = Platform::Maximum(lineOfAnchor, lineCurrentPos);
+			Sci::Line lineTopSel = Platform::Minimum(lineOfAnchor, lineCurrentPos);
+			Sci::Line lineBottomSel = Platform::Maximum(lineOfAnchor, lineCurrentPos);
 			if (pdoc->LineStart(lineBottomSel) == sel.Range(r).anchor.Position() || pdoc->LineStart(lineBottomSel) == caretPosition)
 				lineBottomSel--;  	// If not selecting any characters on a line, do not indent
 			pdoc->Indent(forwards, lineBottomSel, lineTopSel);
@@ -3951,13 +3952,13 @@
     sptr_t lParam) {	///< @c Sci_TextToFind structure: The text to search for in the given range.
 
 	Sci_TextToFind *ft = reinterpret_cast<Sci_TextToFind *>(lParam);
-	int lengthFound = istrlen(ft->lpstrText);
+	Sci::Position lengthFound = istrlen(ft->lpstrText);
 	if (!pdoc->HasCaseFolder())
 		pdoc->SetCaseFolder(CaseFolderForEncoding());
 	try {
 		long pos = pdoc->FindText(
-			static_cast<int>(ft->chrg.cpMin),
-			static_cast<int>(ft->chrg.cpMax),
+			static_cast<Sci::Position>(ft->chrg.cpMin),
+			static_cast<Sci::Position>(ft->chrg.cpMax),
 			ft->lpstrText,
 			static_cast<int>(wParam),
 			&lengthFound);
@@ -4000,7 +4001,7 @@
 
 	const char *txt = reinterpret_cast<char *>(lParam);
 	long pos;
-	int lengthFound = istrlen(txt);
+	Sci::Position lengthFound = istrlen(txt);
 	if (!pdoc->HasCaseFolder())
 		pdoc->SetCaseFolder(CaseFolderForEncoding());
 	try {
@@ -4045,8 +4046,8 @@
  * Search for text in the target range of the document.
  * @return The position of the found text, -1 if not found.
  */
-long Editor::SearchInTarget(const char *text, int length) {
-	int lengthFound = length;
+long Editor::SearchInTarget(const char *text, Sci::Position length) {
+	Sci::Position lengthFound = length;
 
 	if (!pdoc->HasCaseFolder())
 		pdoc->SetCaseFolder(CaseFolderForEncoding());
@@ -4065,7 +4066,7 @@
 	}
 }
 
-void Editor::GoToLine(int lineNo) {
+void Editor::GoToLine(Sci::Line lineNo) {
 	if (lineNo > pdoc->LinesTotal())
 		lineNo = pdoc->LinesTotal();
 	if (lineNo < 0)
@@ -4083,9 +4084,9 @@
 	return true;
 }
 
-std::string Editor::RangeText(int start, int end) const {
+std::string Editor::RangeText(Sci::Position start, Sci::Position end) const {
 	if (start < end) {
-		int len = end - start;
+		Sci::Position len = end - start;
 		std::string ret(len, '\0');
 		for (int i = 0; i < len; i++) {
 			ret[i] = pdoc->CharAt(start + i);
@@ -4098,9 +4099,9 @@
 void Editor::CopySelectionRange(SelectionText *ss, bool allowLineCopy) {
 	if (sel.Empty()) {
 		if (allowLineCopy) {
-			int currentLine = pdoc->LineFromPosition(sel.MainCaret());
-			int start = pdoc->LineStart(currentLine);
-			int end = pdoc->LineEnd(currentLine);
+			Sci::Line currentLine = pdoc->LineFromPosition(sel.MainCaret());
+			Sci::Position start = pdoc->LineStart(currentLine);
+			Sci::Position end = pdoc->LineEnd(currentLine);
 
 			std::string text = RangeText(start, end);
 			if (pdoc->eolMode != SC_EOL_LF)
@@ -4130,7 +4131,7 @@
 	}
 }
 
-void Editor::CopyRangeToClipboard(int start, int end) {
+void Editor::CopyRangeToClipboard(Sci::Position start, Sci::Position end) {
 	start = pdoc->ClampPositionIntoDocument(start);
 	end = pdoc->ClampPositionIntoDocument(end);
 	SelectionText selectedText;
@@ -4230,13 +4231,13 @@
 		std::string convertedText = Document::TransformLineEnds(value, lengthValue, pdoc->eolMode);
 
 		if (rectangular) {
-			PasteRectangular(position, convertedText.c_str(), static_cast<int>(convertedText.length()));
+			PasteRectangular(position, convertedText.c_str(), static_cast<Sci::Position>(convertedText.length()));
 			// Should try to select new rectangle but it may not be a rectangle now so just select the drop position
 			SetEmptySelection(position);
 		} else {
 			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
 			position = RealizeVirtualSpace(position);
-			const int lengthInserted = pdoc->InsertString(
+			const Sci::Position lengthInserted = pdoc->InsertString(
 				position.Position(), convertedText.c_str(), static_cast<int>(convertedText.length()));
 			if (lengthInserted > 0) {
 				SelectionPosition posAfterInsertion = position;
@@ -4256,7 +4257,7 @@
 /**
  * @return true if given position is inside the selection,
  */
-bool Editor::PositionInSelection(int pos) {
+bool Editor::PositionInSelection(Sci::Position pos) {
 	pos = MovePositionOutsideChar(pos, sel.MainCaret() - pos);
 	for (size_t r=0; r<sel.Count(); r++) {
 		if (sel.Range(r).Contains(pos))
@@ -4313,16 +4314,16 @@
 	return Window::cursorReverseArrow;
 }
 
-void Editor::TrimAndSetSelection(int currentPos_, int anchor_) {
+void Editor::TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
 	sel.TrimSelection(SelectionRange(currentPos_, anchor_));
 	SetSelection(currentPos_, anchor_);
 }
 
-void Editor::LineSelection(int lineCurrentPos_, int lineAnchorPos_, bool wholeLine) {
-	int selCurrentPos, selAnchorPos;
+void Editor::LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine) {
+	Sci::Position selCurrentPos, selAnchorPos;
 	if (wholeLine) {
-		int lineCurrent_ = pdoc->LineFromPosition(lineCurrentPos_);
-		int lineAnchor_ = pdoc->LineFromPosition(lineAnchorPos_);
+		Sci::Line lineCurrent_ = pdoc->LineFromPosition(lineCurrentPos_);
+		Sci::Line lineAnchor_ = pdoc->LineFromPosition(lineAnchorPos_);
 		if (lineAnchorPos_ < lineCurrentPos_) {
 			selCurrentPos = pdoc->LineStart(lineCurrent_ + 1);
 			selAnchorPos = pdoc->LineStart(lineAnchor_);
@@ -4351,7 +4352,7 @@
 	TrimAndSetSelection(selCurrentPos, selAnchorPos);
 }
 
-void Editor::WordSelection(int pos) {
+void Editor::WordSelection(Sci::Position pos) {
 	if (pos < wordSelectAnchorStartPos) {
 		// Extend backward to the word containing pos.
 		// Skip ExtendWordSelect if the line is empty or if pos is after the last character.
@@ -4472,13 +4473,13 @@
 		}
 
 		if (selectionType == selWord) {
-			int charPos = originalAnchorPos;
+			Sci::Position charPos = originalAnchorPos;
 			if (sel.MainCaret() == originalAnchorPos) {
 				charPos = PositionFromLocation(pt, false, true);
 				charPos = MovePositionOutsideChar(charPos, -1);
 			}
 
-			int startWord, endWord;
+			Sci::Position startWord, endWord;
 			if ((sel.MainCaret() >= originalAnchorPos) && !pdoc->IsLineEndPosition(charPos)) {
 				startWord = pdoc->ExtendWordSelect(pdoc->MovePositionOutsideChar(charPos + 1, 1), -1);
 				endWord = pdoc->ExtendWordSelect(charPos, 1);
@@ -4539,7 +4540,7 @@
 				LineSelection(newPos.Position(), lineAnchorPos, selectionType == selWholeLine);
 			}
 
-			SetDragPosition(SelectionPosition(invalidPosition));
+			SetDragPosition(SelectionPosition(Sci::invalidPosition));
 			SetMouseCapture(true);
 			if (FineTickerAvailable()) {
 				FineTickerStart(tickScroll, 100, 10);
@@ -4560,7 +4561,7 @@
 				FineTickerStart(tickScroll, 100, 10);
 			}
 			if (inDragDrop != ddInitial) {
-				SetDragPosition(SelectionPosition(invalidPosition));
+				SetDragPosition(SelectionPosition(Sci::invalidPosition));
 				if (!shift) {
 					if (ctrl && multipleSelection) {
 						SelectionRange range(newPos);
@@ -4603,19 +4604,19 @@
 	return ButtonDownWithModifiers(pt, curTime, ModifierFlags(shift, ctrl, alt));
 }
 
-bool Editor::PositionIsHotspot(int position) const {
+bool Editor::PositionIsHotspot(Sci::Position position) const {
 	return vs.styles[pdoc->StyleIndexAt(position)].hotspot;
 }
 
 bool Editor::PointIsHotspot(Point pt) {
-	int pos = PositionFromLocation(pt, true, true);
+	Sci::Position pos = PositionFromLocation(pt, true, true);
 	if (pos == INVALID_POSITION)
 		return false;
 	return PositionIsHotspot(pos);
 }
 
-void Editor::SetHoverIndicatorPosition(int position) {
-	int hoverIndicatorPosPrev = hoverIndicatorPos;
+void Editor::SetHoverIndicatorPosition(Sci::Position position) {
+	Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
 	hoverIndicatorPos = INVALID_POSITION;
 	if (vs.indicatorsDynamic == 0)
 		return;
@@ -4643,7 +4644,7 @@
 
 void Editor::SetHotSpotRange(Point *pt) {
 	if (pt) {
-		int pos = PositionFromLocation(*pt, false, true);
+		Sci::Position pos = PositionFromLocation(*pt, false, true);
 
 		// If we don't limit this to word characters then the
 		// range can encompass more than the run range and then
@@ -4664,7 +4665,7 @@
 		if (hotspot.Valid()) {
 			InvalidateRange(hotspot.start, hotspot.end);
 		}
-		hotspot = Range(invalidPosition);
+		hotspot = Range(Sci::invalidPosition);
 	}
 }
 
@@ -4752,7 +4753,7 @@
 		}
 
 		// Autoscroll
-		int lineMove = DisplayFromPosition(movePos.Position());
+		Sci::Line lineMove = DisplayFromPosition(movePos.Position());
 		if (pt.y > rcClient.bottom) {
 			ScrollTo(lineMove - LinesOnScreen() + 1);
 			Redraw();
@@ -4789,7 +4790,7 @@
 				DisplayCursor(Window::cursorHand);
 				SetHotSpotRange(&pt);
 			} else {
-				if (hoverIndicatorPos != invalidPosition)
+				if (hoverIndicatorPos != Sci::invalidPosition)
 					DisplayCursor(Window::cursorHand);
 				else
 					DisplayCursor(Window::cursorText);
@@ -4842,14 +4843,14 @@
 				if (drag.Length()) {
 					const int length = static_cast<int>(drag.Length());
 					if (ctrl) {
-						const int lengthInserted = pdoc->InsertString(
+						const Sci::Position lengthInserted = pdoc->InsertString(
 							newPos.Position(), drag.Data(), length);
 						if (lengthInserted > 0) {
 							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
 						}
 					} else if (newPos < selStart) {
 						pdoc->DeleteChars(selStart.Position(), static_cast<int>(drag.Length()));
-						const int lengthInserted = pdoc->InsertString(
+						const Sci::Position lengthInserted = pdoc->InsertString(
 							newPos.Position(), drag.Data(), length);
 						if (lengthInserted > 0) {
 							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
@@ -4857,7 +4858,7 @@
 					} else if (newPos > selEnd) {
 						pdoc->DeleteChars(selStart.Position(), static_cast<int>(drag.Length()));
 						newPos.Add(-static_cast<int>(drag.Length()));
-						const int lengthInserted = pdoc->InsertString(
+						const Sci::Position lengthInserted = pdoc->InsertString(
 							newPos.Position(), drag.Data(), length);
 						if (lengthInserted > 0) {
 							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
@@ -5017,11 +5018,11 @@
 	ShowCaretAtCurrentPosition();
 }
 
-int Editor::PositionAfterArea(PRectangle rcArea) const {
+Sci::Position Editor::PositionAfterArea(PRectangle rcArea) const {
 	// The start of the document line after the display line after the area
 	// This often means that the line after a modification is restyled which helps
 	// detect multiline comment additions and heals single line comments
-	int lineAfter = TopLineOfMain() + static_cast<int>(rcArea.bottom - 1) / vs.lineHeight + 1;
+	Sci::Line lineAfter = TopLineOfMain() + static_cast<Sci::Line>(rcArea.bottom - 1) / vs.lineHeight + 1;
 	if (lineAfter < cs.LinesDisplayed())
 		return pdoc->LineStart(cs.DocFromDisplay(lineAfter) + 1);
 	else
@@ -5030,8 +5031,8 @@
 
 // Style to a position within the view. If this causes a change at end of last line then
 // affects later lines so style all the viewed text.
-void Editor::StyleToPositionInView(Position pos) {
-	int endWindow = PositionAfterArea(GetClientDrawingRectangle());
+void Editor::StyleToPositionInView(Sci::Position pos) {
+	Sci::Position endWindow = PositionAfterArea(GetClientDrawingRectangle());
 	if (pos > endWindow)
 		pos = endWindow;
 	const int styleAtEnd = pdoc->StyleIndexAt(pos-1);
@@ -5046,7 +5047,7 @@
 	}
 }
 
-int Editor::PositionAfterMaxStyling(int posMax, bool scrolling) const {
+Sci::Position Editor::PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const {
 	if ((idleStyling == SC_IDLESTYLING_NONE) || (idleStyling == SC_IDLESTYLING_AFTERVISIBLE)) {
 		// Both states do not limit styling
 		return posMax;
@@ -5056,12 +5057,12 @@
 	// When scrolling, allow less time to ensure responsive
 	const double secondsAllowed = scrolling ? 0.005 : 0.02;
 
-	const int linesToStyle = Platform::Clamp(static_cast<int>(secondsAllowed / pdoc->durationStyleOneLine),
+	const Sci::Line linesToStyle = Platform::Clamp(static_cast<int>(secondsAllowed / pdoc->durationStyleOneLine),
 		10, 0x10000);
-	const int stylingMaxLine = std::min(
-		static_cast<int>(pdoc->LineFromPosition(pdoc->GetEndStyled()) + linesToStyle),
+	const Sci::Line stylingMaxLine = std::min(
+		static_cast<Sci::Line>(pdoc->LineFromPosition(pdoc->GetEndStyled()) + linesToStyle),
 		pdoc->LinesTotal());
-	return std::min(static_cast<int>(pdoc->LineStart(stylingMaxLine)), posMax);
+	return std::min(static_cast<Sci::Position>(pdoc->LineStart(stylingMaxLine)), posMax);
 }
 
 void Editor::StartIdleStyling(bool truncatedLastStyling) {
@@ -5081,8 +5082,8 @@
 
 // Style for an area but bound the amount of styling to remain responsive
 void Editor::StyleAreaBounded(PRectangle rcArea, bool scrolling) {
-	const int posAfterArea = PositionAfterArea(rcArea);
-	const int posAfterMax = PositionAfterMaxStyling(posAfterArea, scrolling);
+	const Sci::Position posAfterArea = PositionAfterArea(rcArea);
+	const Sci::Position posAfterMax = PositionAfterMaxStyling(posAfterArea, scrolling);
 	if (posAfterMax < posAfterArea) {
 		// Idle styling may be performed before current visible area
 		// Style a bit now then style further in idle time
@@ -5095,10 +5096,10 @@
 }
 
 void Editor::IdleStyling() {
-	const int posAfterArea = PositionAfterArea(GetClientRectangle());
-	const int endGoal = (idleStyling >= SC_IDLESTYLING_AFTERVISIBLE) ?
+	const Sci::Position posAfterArea = PositionAfterArea(GetClientRectangle());
+	const Sci::Position endGoal = (idleStyling >= SC_IDLESTYLING_AFTERVISIBLE) ?
 		pdoc->Length() : posAfterArea;
-	const int posAfterMax = PositionAfterMaxStyling(endGoal, false);
+	const Sci::Position posAfterMax = PositionAfterMaxStyling(endGoal, false);
 	pdoc->StyleToAdjustingLineDuration(posAfterMax);
 	if (pdoc->GetEndStyled() >= endGoal) {
 		needIdleStyling = false;
@@ -5115,7 +5116,7 @@
 	workNeeded.Reset();
 }
 
-void Editor::QueueIdleWork(WorkNeeded::workItems items, int upTo) {
+void Editor::QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo) {
 	workNeeded.Need(items, upTo);
 }
 
@@ -5160,7 +5161,7 @@
 	}
 }
 
-void Editor::SetBraceHighlight(Position pos0, Position pos1, int matchStyle) {
+void Editor::SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle) {
 	if ((pos0 != braces[0]) || (pos1 != braces[1]) || (matchStyle != bracesMatchStyle)) {
 		if ((braces[0] != pos0) || (matchStyle != bracesMatchStyle)) {
 			CheckForChangeOutsidePaint(Range(braces[0]));
@@ -5179,11 +5180,11 @@
 	}
 }
 
-void Editor::SetAnnotationHeights(int start, int end) {
+void Editor::SetAnnotationHeights(Sci::Line start, Sci::Line end) {
 	if (vs.annotationVisible) {
 		RefreshStyleData();
 		bool changedHeight = false;
-		for (int line=start; line<end && line<pdoc->LinesTotal(); line++) {
+		for (Sci::Line line=start; line<end && line<pdoc->LinesTotal(); line++) {
 			int linesWrapped = 1;
 			if (Wrapping()) {
 				AutoSurface surface(this);
@@ -5218,8 +5219,8 @@
 	targetStart = 0;
 	targetEnd = 0;
 
-	braces[0] = invalidPosition;
-	braces[1] = invalidPosition;
+	braces[0] = Sci::invalidPosition;
+	braces[1] = Sci::invalidPosition;
 
 	vs.ReleaseAllExtendedStyles();
 
@@ -5232,8 +5233,8 @@
 	view.llc.Deallocate();
 	NeedWrapping();
 
-	hotspot = Range(invalidPosition);
-	hoverIndicatorPos = invalidPosition;
+	hotspot = Range(Sci::invalidPosition);
+	hoverIndicatorPos = Sci::invalidPosition;
 
 	view.ClearAllTabstops();
 
@@ -5248,7 +5249,7 @@
 		vs.annotationVisible = visible;
 		if (changedFromOrToHidden) {
 			int dir = vs.annotationVisible ? 1 : -1;
-			for (int line=0; line<pdoc->LinesTotal(); line++) {
+			for (Sci::Line line=0; line<pdoc->LinesTotal(); line++) {
 				int annotationLines = pdoc->AnnotationLines(line);
 				if (annotationLines > 0) {
 					cs.SetHeight(line, cs.GetHeight(line) + annotationLines * dir);
@@ -5262,8 +5263,8 @@
 /**
  * Recursively expand a fold, making lines visible except where they have an unexpanded parent.
  */
-int Editor::ExpandLine(int line) {
-	int lineMaxSubord = pdoc->GetLastChild(line);
+Sci::Line Editor::ExpandLine(Sci::Line line) {
+	Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
 	line++;
 	while (line <= lineMaxSubord) {
 		cs.SetVisible(line, line, true);
@@ -5280,13 +5281,13 @@
 	return lineMaxSubord;
 }
 
-void Editor::SetFoldExpanded(int lineDoc, bool expanded) {
+void Editor::SetFoldExpanded(Sci::Line lineDoc, bool expanded) {
 	if (cs.SetExpanded(lineDoc, expanded)) {
 		RedrawSelMargin();
 	}
 }
 
-void Editor::FoldLine(int line, int action) {
+void Editor::FoldLine(Sci::Line line, int action) {
 	if (line >= 0) {
 		if (action == SC_FOLDACTION_TOGGLE) {
 			if ((pdoc->GetLevel(line) & SC_FOLDLEVELHEADERFLAG) == 0) {
@@ -5298,12 +5299,12 @@
 		}
 
 		if (action == SC_FOLDACTION_CONTRACT) {
-			int lineMaxSubord = pdoc->GetLastChild(line);
+			Sci::Line lineMaxSubord = pdoc->GetLastChild(line);
 			if (lineMaxSubord > line) {
 				cs.SetExpanded(line, 0);
 				cs.SetVisible(line + 1, lineMaxSubord, false);
 
-				int lineCurrent = pdoc->LineFromPosition(sel.MainCaret());
+				Sci::Line lineCurrent = pdoc->LineFromPosition(sel.MainCaret());
 				if (lineCurrent > line && lineCurrent <= lineMaxSubord) {
 					// This does not re-expand the fold
 					EnsureCaretVisible();
@@ -5324,7 +5325,7 @@
 	}
 }
 
-void Editor::FoldExpand(int line, int action, int level) {
+void Editor::FoldExpand(Sci::Line line, int action, int level) {
 	bool expanding = action == SC_FOLDACTION_EXPAND;
 	if (action == SC_FOLDACTION_TOGGLE) {
 		expanding = !cs.GetExpanded(line);
@@ -5336,7 +5337,7 @@
 	if (expanding && (cs.HiddenLines() == 0))
 		// Nothing to do
 		return;
-	int lineMaxSubord = pdoc->GetLastChild(line, LevelNumber(level));
+	Sci::Line lineMaxSubord = pdoc->GetLastChild(line, LevelNumber(level));
 	line++;
 	cs.SetVisible(line, lineMaxSubord, expanding);
 	while (line <= lineMaxSubord) {
@@ -5350,8 +5351,8 @@
 	Redraw();
 }
 
-int Editor::ContractedFoldNext(int lineStart) const {
-	for (int line = lineStart; line<pdoc->LinesTotal();) {
+Sci::Line Editor::ContractedFoldNext(Sci::Line lineStart) const {
+	for (Sci::Line line = lineStart; line<pdoc->LinesTotal();) {
 		if (!cs.GetExpanded(line) && (pdoc->GetLevel(line) & SC_FOLDLEVELHEADERFLAG))
 			return line;
 		line = cs.ContractedNext(line+1);
@@ -5366,7 +5367,7 @@
  * Recurse up from this line to find any folds that prevent this line from being visible
  * and unfold them all.
  */
-void Editor::EnsureLineVisible(int lineDoc, bool enforcePolicy) {
+void Editor::EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy) {
 
 	// In case in need of wrapping to ensure DisplayFromDoc works.
 	if (lineDoc >= wrapPending.start)
@@ -5374,12 +5375,12 @@
 
 	if (!cs.GetVisible(lineDoc)) {
 		// Back up to find a non-blank line
-		int lookLine = lineDoc;
+		Sci::Line lookLine = lineDoc;
 		int lookLineLevel = pdoc->GetLevel(lookLine);
 		while ((lookLine > 0) && (lookLineLevel & SC_FOLDLEVELWHITEFLAG)) {
 			lookLineLevel = pdoc->GetLevel(--lookLine);
 		}
-		int lineParent = pdoc->GetFoldParent(lookLine);
+		Sci::Line lineParent = pdoc->GetFoldParent(lookLine);
 		if (lineParent < 0) {
 			// Backed up to a top level line, so try to find parent of initial line
 			lineParent = pdoc->GetFoldParent(lineDoc);
@@ -5396,7 +5397,7 @@
 		Redraw();
 	}
 	if (enforcePolicy) {
-		int lineDisplay = cs.DisplayFromDoc(lineDoc);
+		Sci::Line lineDisplay = cs.DisplayFromDoc(lineDoc);
 		if (visiblePolicy & VISIBLE_SLOP) {
 			if ((topLine > lineDisplay) || ((visiblePolicy & VISIBLE_STRICT) && (topLine + visibleSlop > lineDisplay))) {
 				SetTopLine(Platform::Clamp(lineDisplay - visibleSlop, 0, MaxScrollPos()));
@@ -5420,7 +5421,7 @@
 
 void Editor::FoldAll(int action) {
 	pdoc->EnsureStyledTo(pdoc->Length());
-	int maxLine = pdoc->LinesTotal();
+	Sci::Line maxLine = pdoc->LinesTotal();
 	bool expanding = action == SC_FOLDACTION_EXPAND;
 	if (action == SC_FOLDACTION_TOGGLE) {
 		// Discover current state
@@ -5445,7 +5446,7 @@
 			if ((level & SC_FOLDLEVELHEADERFLAG) &&
 					(SC_FOLDLEVELBASE == LevelNumber(level))) {
 				SetFoldExpanded(line, false);
-				int lineMaxSubord = pdoc->GetLastChild(line, -1);
+				Sci::Line lineMaxSubord = pdoc->GetLastChild(line, -1);
 				if (lineMaxSubord > line) {
 					cs.SetVisible(line + 1, lineMaxSubord, false);
 				}
@@ -5456,7 +5457,7 @@
 	Redraw();
 }
 
-void Editor::FoldChanged(int line, int levelNow, int levelPrev) {
+void Editor::FoldChanged(Sci::Line line, int levelNow, int levelPrev) {
 	if (levelNow & SC_FOLDLEVELHEADERFLAG) {
 		if (!(levelPrev & SC_FOLDLEVELHEADERFLAG)) {
 			// Adding a fold point.
@@ -5466,7 +5467,7 @@
 			FoldExpand(line, SC_FOLDACTION_EXPAND, levelPrev);
 		}
 	} else if (levelPrev & SC_FOLDLEVELHEADERFLAG) {
-		const int prevLine = line - 1;
+		const Sci::Line prevLine = line - 1;
 		const int prevLineLevel = pdoc->GetLevel(prevLine);
 
 		// Combining two blocks where the first block is collapsed (e.g. by deleting the line(s) which separate(s) the two blocks)
@@ -5487,7 +5488,7 @@
 	        (LevelNumber(levelPrev) > LevelNumber(levelNow))) {
 		if (cs.HiddenLines()) {
 			// See if should still be hidden
-			int parentLine = pdoc->GetFoldParent(line);
+			Sci::Line parentLine = pdoc->GetFoldParent(line);
 			if ((parentLine < 0) || (cs.GetExpanded(parentLine) && cs.GetVisible(parentLine))) {
 				cs.SetVisible(line, line, true);
 				SetScrollBars();
@@ -5499,18 +5500,18 @@
 	// Combining two blocks where the first one is collapsed (e.g. by adding characters in the line which separates the two blocks)
 	if (!(levelNow & SC_FOLDLEVELWHITEFLAG) && (LevelNumber(levelPrev) < LevelNumber(levelNow))) {
 		if (cs.HiddenLines()) {
-			const int parentLine = pdoc->GetFoldParent(line);
+			const Sci::Line parentLine = pdoc->GetFoldParent(line);
 			if (!cs.GetExpanded(parentLine) && cs.GetVisible(line))
 				FoldLine(parentLine, SC_FOLDACTION_EXPAND);
 		}
 	}
 }
 
-void Editor::NeedShown(int pos, int len) {
+void Editor::NeedShown(Sci::Position pos, Sci::Position len) {
 	if (foldAutomatic & SC_AUTOMATICFOLD_SHOW) {
-		int lineStart = pdoc->LineFromPosition(pos);
-		int lineEnd = pdoc->LineFromPosition(pos+len);
-		for (int line = lineStart; line <= lineEnd; line++) {
+		Sci::Line lineStart = pdoc->LineFromPosition(pos);
+		Sci::Line lineEnd = pdoc->LineFromPosition(pos+len);
+		for (Sci::Line line = lineStart; line <= lineEnd; line++) {
 			EnsureLineVisible(line, false);
 		}
 	} else {
@@ -5518,9 +5519,9 @@
 	}
 }
 
-int Editor::GetTag(char *tagValue, int tagNumber) {
+Sci::Position Editor::GetTag(char *tagValue, int tagNumber) {
 	const char *text = 0;
-	int length = 0;
+	Sci::Position length = 0;
 	if ((tagNumber >= 1) && (tagNumber <= 9)) {
 		char name[3] = "\\?";
 		name[1] = static_cast<char>(tagNumber + '0');
@@ -5536,7 +5537,7 @@
 	return length;
 }
 
-int Editor::ReplaceTarget(bool replacePatterns, const char *text, int length) {
+Sci::Position Editor::ReplaceTarget(bool replacePatterns, const char *text, Sci::Position length) {
 	UndoGroup ug(pdoc);
 	if (length == -1)
 		length = istrlen(text);
@@ -5549,7 +5550,7 @@
 	if (targetStart != targetEnd)
 		pdoc->DeleteChars(targetStart, targetEnd - targetStart);
 	targetEnd = targetStart;
-	const int lengthInserted = pdoc->InsertString(targetStart, text, length);
+	const Sci::Position lengthInserted = pdoc->InsertString(targetStart, text, length);
 	targetEnd = targetStart + lengthInserted;
 	return length;
 }
@@ -5577,15 +5578,15 @@
 	}
 }
 
-void Editor::AddStyledText(char *buffer, int appendLength) {
+void Editor::AddStyledText(char *buffer, Sci::Position appendLength) {
 	// The buffer consists of alternating character bytes and style bytes
-	int textLength = appendLength / 2;
+	Sci::Position textLength = appendLength / 2;
 	std::string text(textLength, '\0');
-	int i;
+	Sci::Position i;
 	for (i = 0; i < textLength; i++) {
 		text[i] = buffer[i*2];
 	}
-	const int lengthInserted = pdoc->InsertString(CurrentPosition(), text.c_str(), textLength);
+	const Sci::Position lengthInserted = pdoc->InsertString(CurrentPosition(), text.c_str(), textLength);
 	for (i = 0; i < textLength; i++) {
 		text[i] = buffer[i*2+1];
 	}
@@ -5854,14 +5855,14 @@
 		break;
 
 	case SCI_GETLINE: {	// Risk of overwriting the end of the buffer
-			int lineStart = pdoc->LineStart(static_cast<int>(wParam));
-			int lineEnd = pdoc->LineStart(static_cast<int>(wParam + 1));
+			Sci::Position lineStart = pdoc->LineStart(static_cast<Sci::Line>(wParam));
+			Sci::Position lineEnd = pdoc->LineStart(static_cast<Sci::Line>(wParam + 1));
 			if (lParam == 0) {
 				return lineEnd - lineStart;
 			}
 			char *ptr = CharPtrFromSPtr(lParam);
-			int iPlace = 0;
-			for (int iChar = lineStart; iChar < lineEnd; iChar++) {
+			Sci::Position iPlace = 0;
+			for (Sci::Position iChar = lineStart; iChar < lineEnd; iChar++) {
 				ptr[iPlace++] = pdoc->CharAt(iChar);
 			}
 			return iPlace;
@@ -5877,8 +5878,8 @@
 		return !pdoc->IsSavePoint();
 
 	case SCI_SETSEL: {
-			int nStart = static_cast<int>(wParam);
-			int nEnd = static_cast<int>(lParam);
+			Sci::Position nStart = static_cast<Sci::Position>(wParam);
+			Sci::Position nEnd = static_cast<Sci::Position>(lParam);
 			if (nEnd < 0)
 				nEnd = pdoc->Length();
 			if (nStart < 0)
@@ -5919,7 +5920,7 @@
 			wParam = pdoc->LineFromPosition(SelectionStart().Position());
 		if (wParam == 0)
 			return 0; 	// Even if there is no text, there is a first line that starts at 0
-		if (static_cast<int>(wParam) > pdoc->LinesTotal())
+		if (static_cast<Sci::Line>(wParam) > pdoc->LinesTotal())
 			return -1;
 		//if (wParam > pdoc->LineFromPosition(pdoc->Length()))	// Useful test, anyway...
 		//	return -1;
@@ -5938,7 +5939,7 @@
 			UndoGroup ug(pdoc);
 			ClearSelection();
 			char *replacement = CharPtrFromSPtr(lParam);
-			const int lengthInserted = pdoc->InsertString(
+			const Sci::Position lengthInserted = pdoc->InsertString(
 				sel.MainCaret(), replacement, istrlen(replacement));
 			SetEmptySelection(sel.MainCaret() + lengthInserted);
 			EnsureCaretVisible();
@@ -5986,15 +5987,15 @@
 
 	case SCI_REPLACETARGET:
 		PLATFORM_ASSERT(lParam);
-		return ReplaceTarget(false, CharPtrFromSPtr(lParam), static_cast<int>(wParam));
+		return ReplaceTarget(false, CharPtrFromSPtr(lParam), static_cast<Sci::Position>(wParam));
 
 	case SCI_REPLACETARGETRE:
 		PLATFORM_ASSERT(lParam);
-		return ReplaceTarget(true, CharPtrFromSPtr(lParam), static_cast<int>(wParam));
+		return ReplaceTarget(true, CharPtrFromSPtr(lParam), static_cast<Sci::Position>(wParam));
 
 	case SCI_SEARCHINTARGET:
 		PLATFORM_ASSERT(lParam);
-		return SearchInTarget(CharPtrFromSPtr(lParam), static_cast<int>(wParam));
+		return SearchInTarget(CharPtrFromSPtr(lParam), static_cast<Sci::Position>(wParam));
 
 	case SCI_SETSEARCHFLAGS:
 		searchFlags = static_cast<int>(wParam);
@@ -6016,8 +6017,8 @@
 		return Platform::Clamp(pdoc->GetRelativePosition(static_cast<int>(wParam), static_cast<int>(lParam)), 0, pdoc->Length());
 
 	case SCI_LINESCROLL:
-		ScrollTo(topLine + static_cast<int>(lParam));
-		HorizontalScrollTo(xOffset + static_cast<int>(wParam)* static_cast<int>(vs.spaceWidth));
+		ScrollTo(topLine + static_cast<Sci::Line>(lParam));
+		HorizontalScrollTo(xOffset + static_cast<int>(wParam) * static_cast<int>(vs.spaceWidth));
 		return 1;
 
 	case SCI_SETXOFFSET:
@@ -6072,7 +6073,7 @@
 			if (lParam == 0)
 				return 0;
 			Sci_TextRange *tr = reinterpret_cast<Sci_TextRange *>(lParam);
-			int cpMax = static_cast<int>(tr->chrg.cpMax);
+			Sci::Position cpMax = static_cast<Sci::Position>(tr->chrg.cpMax);
 			if (cpMax == -1)
 				cpMax = pdoc->Length();
 			PLATFORM_ASSERT(cpMax <= pdoc->Length());
@@ -6113,26 +6114,26 @@
 	case SCI_ADDTEXT: {
 			if (lParam == 0)
 				return 0;
-			const int lengthInserted = pdoc->InsertString(
-				CurrentPosition(), CharPtrFromSPtr(lParam), static_cast<int>(wParam));
+			const Sci::Position lengthInserted = pdoc->InsertString(
+				CurrentPosition(), CharPtrFromSPtr(lParam), static_cast<Sci::Position>(wParam));
 			SetEmptySelection(sel.MainCaret() + lengthInserted);
 			return 0;
 		}
 
 	case SCI_ADDSTYLEDTEXT:
 		if (lParam)
-			AddStyledText(CharPtrFromSPtr(lParam), static_cast<int>(wParam));
+			AddStyledText(CharPtrFromSPtr(lParam), static_cast<Sci::Position>(wParam));
 		return 0;
 
 	case SCI_INSERTTEXT: {
 			if (lParam == 0)
 				return 0;
-			int insertPos = static_cast<int>(wParam);
+			Sci::Position insertPos = static_cast<Sci::Position>(wParam);
 			if (static_cast<int>(wParam) == -1)
 				insertPos = CurrentPosition();
-			int newCurrent = CurrentPosition();
+			Sci::Position newCurrent = CurrentPosition();
 			char *sz = CharPtrFromSPtr(lParam);
-			const int lengthInserted = pdoc->InsertString(insertPos, sz, istrlen(sz));
+			const Sci::Position lengthInserted = pdoc->InsertString(insertPos, sz, istrlen(sz));
 			if (newCurrent > insertPos)
 				newCurrent += lengthInserted;
 			SetEmptySelection(newCurrent);
@@ -6221,11 +6222,11 @@
 		return pdoc->Length();
 
 	case SCI_ALLOCATE:
-		pdoc->Allocate(static_cast<int>(wParam));
+		pdoc->Allocate(static_cast<Sci::Position>(wParam));
 		break;
 
 	case SCI_GETCHARAT:
-		return pdoc->CharAt(static_cast<int>(wParam));
+		return pdoc->CharAt(static_cast<Sci::Position>(wParam));
 
 	case SCI_SETCURRENTPOS:
 		if (sel.IsRectangular()) {
@@ -6233,7 +6234,7 @@
 			SetRectangularRange();
 			Redraw();
 		} else {
-			SetSelection(static_cast<int>(wParam), sel.MainAnchor());
+			SetSelection(static_cast<Sci::Position>(wParam), sel.MainAnchor());
 		}
 		break;
 
@@ -6242,11 +6243,11 @@
 
 	case SCI_SETANCHOR:
 		if (sel.IsRectangular()) {
-			sel.Rectangular().anchor.SetPosition(static_cast<int>(wParam));
+			sel.Rectangular().anchor.SetPosition(static_cast<Sci::Position>(wParam));
 			SetRectangularRange();
 			Redraw();
 		} else {
-			SetSelection(sel.MainCaret(), static_cast<int>(wParam));
+			SetSelection(sel.MainCaret(), static_cast<Sci::Position>(wParam));
 		}
 		break;
 
@@ -6254,14 +6255,14 @@
 		return sel.IsRectangular() ? sel.Rectangular().anchor.Position() : sel.MainAnchor();
 
 	case SCI_SETSELECTIONSTART:
-		SetSelection(Platform::Maximum(sel.MainCaret(), static_cast<int>(wParam)), static_cast<int>(wParam));
+		SetSelection(std::max(sel.MainCaret(), static_cast<Sci::Position>(wParam)), static_cast<Sci::Position>(wParam));
 		break;
 
 	case SCI_GETSELECTIONSTART:
 		return sel.LimitsForRectangularElseMain().start.Position();
 
 	case SCI_SETSELECTIONEND:
-		SetSelection(static_cast<int>(wParam), Platform::Minimum(sel.MainAnchor(), static_cast<int>(wParam)));
+		SetSelection(static_cast<Sci::Position>(wParam), Platform::Minimum(sel.MainAnchor(), static_cast<Sci::Position>(wParam)));
 		break;
 
 	case SCI_GETSELECTIONEND:
@@ -6384,16 +6385,16 @@
 		break;
 
 	case SCI_GETCURLINE: {
-			int lineCurrentPos = pdoc->LineFromPosition(sel.MainCaret());
-			int lineStart = pdoc->LineStart(lineCurrentPos);
-			unsigned int lineEnd = pdoc->LineStart(lineCurrentPos + 1);
+			const Sci::Line lineCurrentPos = pdoc->LineFromPosition(sel.MainCaret());
+			const Sci::Position lineStart = pdoc->LineStart(lineCurrentPos);
+			const Sci::Position lineEnd = pdoc->LineStart(lineCurrentPos + 1);
 			if (lParam == 0) {
 				return 1 + lineEnd - lineStart;
 			}
 			PLATFORM_ASSERT(wParam > 0);
 			char *ptr = CharPtrFromSPtr(lParam);
 			unsigned int iPlace = 0;
-			for (unsigned int iChar = lineStart; iChar < lineEnd && iPlace < wParam - 1; iChar++) {
+			for (Sci::Position iChar = lineStart; iChar < lineEnd && iPlace < wParam - 1; iChar++) {
 				ptr[iPlace++] = pdoc->CharAt(iChar);
 			}
 			ptr[iPlace] = '\0';
diff -r 1788f6795302 -r a0f26eaf474d src/Editor.h
--- a/src/Editor.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Editor.h	Fri Mar 31 18:19:38 2017 +1100
@@ -47,14 +47,14 @@
 		workUpdateUI=2
 	};
 	enum workItems items;
-	Position upTo;
+	Sci::Position upTo;
 
 	WorkNeeded() : items(workNone), upTo(0) {}
 	void Reset() {
 		items = workNone;
 		upTo = 0;
 	}
-	void Need(workItems items_, Position pos) {
+	void Need(workItems items_, Sci::Position pos) {
 		if ((items_ & workStyle) && (upTo < pos))
 			upTo = pos;
 		items = static_cast<workItems>(items | items_);
@@ -115,8 +115,8 @@
 struct WrapPending {
 	// The range of lines that need to be wrapped
 	enum { lineLarge = 0x7ffffff };
-	int start;	// When there are wraps pending, will be in document range
-	int end;	// May be lineLarge to indicate all of document after start
+	Sci::Line start;	// When there are wraps pending, will be in document range
+	Sci::Line end;	// May be lineLarge to indicate all of document after start
 	WrapPending() {
 		start = lineLarge;
 		end = lineLarge;
@@ -125,14 +125,14 @@
 		start = lineLarge;
 		end = lineLarge;
 	}
-	void Wrapped(int line) {
+	void Wrapped(Sci::Line line) {
 		if (start == line)
 			start++;
 	}
 	bool NeedsWrap() const {
 		return start < end;
 	}
-	bool AddRange(int lineStart, int lineEnd) {
+	bool AddRange(Sci::Line lineStart, Sci::Line lineEnd) {
 		const bool neededWrap = NeedsWrap();
 		bool changed = false;
 		if (start > lineStart) {
@@ -211,19 +211,19 @@
 	enum { ddNone, ddInitial, ddDragging } inDragDrop;
 	bool dropWentOutside;
 	SelectionPosition posDrop;
-	int hotSpotClickPos;
+	Sci::Position hotSpotClickPos;
 	int lastXChosen;
-	int lineAnchorPos;
-	int originalAnchorPos;
-	int wordSelectAnchorStartPos;
-	int wordSelectAnchorEndPos;
-	int wordSelectInitialCaretPos;
-	int targetStart;
-	int targetEnd;
+	Sci::Position lineAnchorPos;
+	Sci::Position originalAnchorPos;
+	Sci::Position wordSelectAnchorStartPos;
+	Sci::Position wordSelectAnchorEndPos;
+	Sci::Position wordSelectInitialCaretPos;
+	Sci::Position targetStart;
+	Sci::Position targetEnd;
 	int searchFlags;
-	int topLine;
-	int posTopLine;
-	int lengthForEncode;
+	Sci::Line topLine;
+	Sci::Position posTopLine;
+	Sci::Position lengthForEncode;
 
 	int needUpdateUI;
 
@@ -249,7 +249,7 @@
 	int visiblePolicy;
 	int visibleSlop;
 
-	int searchAnchor;
+	Sci::Position searchAnchor;
 
 	bool recordingMacro;
 
@@ -276,38 +276,38 @@
 	// scroll views where it will be equivalent to the current scroll position.
 	virtual Point GetVisibleOriginInMain() const;
 	PointDocument DocumentPointFromView(Point ptView) const;  // Convert a point from view space to document
-	int TopLineOfMain() const;   // Return the line at Main's y coordinate 0
+	Sci::Line TopLineOfMain() const;   // Return the line at Main's y coordinate 0
 	virtual PRectangle GetClientRectangle() const;
 	virtual PRectangle GetClientDrawingRectangle();
 	PRectangle GetTextRectangle() const;
 
-	virtual int LinesOnScreen() const;
-	int LinesToScroll() const;
-	int MaxScrollPos() const;
+	virtual Sci::Line LinesOnScreen() const;
+	Sci::Line LinesToScroll() const;
+	Sci::Line MaxScrollPos() const;
 	SelectionPosition ClampPositionIntoDocument(SelectionPosition sp) const;
 	Point LocationFromPosition(SelectionPosition pos, PointEnd pe=peDefault);
-	Point LocationFromPosition(int pos, PointEnd pe=peDefault);
-	int XFromPosition(int pos);
+	Point LocationFromPosition(Sci::Position pos, PointEnd pe=peDefault);
+	int XFromPosition(Sci::Position pos);
 	int XFromPosition(SelectionPosition sp);
 	SelectionPosition SPositionFromLocation(Point pt, bool canReturnInvalid=false, bool charPosition=false, bool virtualSpace=true);
-	int PositionFromLocation(Point pt, bool canReturnInvalid = false, bool charPosition = false);
-	SelectionPosition SPositionFromLineX(int lineDoc, int x);
-	int PositionFromLineX(int line, int x);
-	int LineFromLocation(Point pt) const;
-	void SetTopLine(int topLineNew);
+	Sci::Position PositionFromLocation(Point pt, bool canReturnInvalid = false, bool charPosition = false);
+	SelectionPosition SPositionFromLineX(Sci::Line lineDoc, int x);
+	Sci::Position PositionFromLineX(Sci::Line line, int x);
+	Sci::Line LineFromLocation(Point pt) const;
+	void SetTopLine(Sci::Line topLineNew);
 
 	virtual bool AbandonPaint();
 	virtual void RedrawRect(PRectangle rc);
 	virtual void DiscardOverdraw();
 	virtual void Redraw();
-	void RedrawSelMargin(int line=-1, bool allAfter=false);
+	void RedrawSelMargin(Sci::Line line=-1, bool allAfter=false);
 	PRectangle RectangleFromRange(Range r, int overlap);
-	void InvalidateRange(int start, int end);
+	void InvalidateRange(Sci::Position start, Sci::Position end);
 
 	bool UserVirtualSpace() const {
 		return ((virtualSpaceOptions & SCVS_USERACCESSIBLE) != 0);
 	}
-	int CurrentPosition() const;
+	Sci::Position CurrentPosition() const;
 	bool SelectionEmpty() const;
 	SelectionPosition SelectionStart();
 	SelectionPosition SelectionEnd();
@@ -316,39 +316,39 @@
 	void InvalidateSelection(SelectionRange newMain, bool invalidateWholeSelection=false);
 	void InvalidateWholeSelection();
 	void SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_);
-	void SetSelection(int currentPos_, int anchor_);
+	void SetSelection(Sci::Position currentPos_, Sci::Position anchor_);
 	void SetSelection(SelectionPosition currentPos_);
 	void SetSelection(int currentPos_);
 	void SetEmptySelection(SelectionPosition currentPos_);
-	void SetEmptySelection(int currentPos_);
+	void SetEmptySelection(Sci::Position currentPos_);
 	enum AddNumber { addOne, addEach };
 	void MultipleSelectAdd(AddNumber addNumber);
-	bool RangeContainsProtected(int start, int end) const;
+	bool RangeContainsProtected(Sci::Position start, Sci::Position end) const;
 	bool SelectionContainsProtected();
-	int MovePositionOutsideChar(int pos, int moveDir, bool checkLineEnd=true) const;
-	SelectionPosition MovePositionOutsideChar(SelectionPosition pos, int moveDir, bool checkLineEnd=true) const;
+	Sci::Position MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd=true) const;
+	SelectionPosition MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd=true) const;
 	void MovedCaret(SelectionPosition newPos, SelectionPosition previousPos, bool ensureVisible);
 	void MovePositionTo(SelectionPosition newPos, Selection::selTypes selt=Selection::noSel, bool ensureVisible=true);
-	void MovePositionTo(int newPos, Selection::selTypes selt=Selection::noSel, bool ensureVisible=true);
+	void MovePositionTo(Sci::Position newPos, Selection::selTypes selt=Selection::noSel, bool ensureVisible=true);
 	SelectionPosition MovePositionSoVisible(SelectionPosition pos, int moveDir);
-	SelectionPosition MovePositionSoVisible(int pos, int moveDir);
+	SelectionPosition MovePositionSoVisible(Sci::Position pos, int moveDir);
 	Point PointMainCaret();
 	void SetLastXChosen();
 
-	void ScrollTo(int line, bool moveThumb=true);
-	virtual void ScrollText(int linesToMove);
+	void ScrollTo(Sci::Line line, bool moveThumb=true);
+	virtual void ScrollText(Sci::Line linesToMove);
 	void HorizontalScrollTo(int xPos);
 	void VerticalCentreCaret();
 	void MoveSelectedLines(int lineDelta);
 	void MoveSelectedLinesUp();
 	void MoveSelectedLinesDown();
 	void MoveCaretInsideView(bool ensureVisible=true);
-	int DisplayFromPosition(int pos);
+	Sci::Line DisplayFromPosition(Sci::Position pos);
 
 	struct XYScrollPosition {
 		int xOffset;
-		int topLine;
-		XYScrollPosition(int xOffset_, int topLine_) : xOffset(xOffset_), topLine(topLine_) {}
+		Sci::Line topLine;
+		XYScrollPosition(int xOffset_, Sci::Line topLine_) : xOffset(xOffset_), topLine(topLine_) {}
 		bool operator==(const XYScrollPosition &other) const {
 			return (xOffset == other.xOffset) && (topLine == other.topLine);
 		}
@@ -370,8 +370,8 @@
 	virtual void UpdateSystemCaret();
 
 	bool Wrapping() const;
-	void NeedWrapping(int docLineStart=0, int docLineEnd=WrapPending::lineLarge);
-	bool WrapOneLine(Surface *surface, int lineToWrap);
+	void NeedWrapping(Sci::Line docLineStart=0, Sci::Line docLineEnd=WrapPending::lineLarge);
+	bool WrapOneLine(Surface *surface, Sci::Line lineToWrap);
 	enum wrapScope {wsAll, wsVisible, wsIdle};
 	bool WrapLines(enum wrapScope ws);
 	void LinesJoin();
@@ -385,13 +385,13 @@
 
 	virtual void SetVerticalScrollPos() = 0;
 	virtual void SetHorizontalScrollPos() = 0;
-	virtual bool ModifyScrollBars(int nMax, int nPage) = 0;
+	virtual bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) = 0;
 	virtual void ReconfigureScrollBars();
 	void SetScrollBars();
 	void ChangeSize();
 
 	void FilterSelections();
-	int RealizeVirtualSpace(int position, unsigned int virtualSpace);
+	Sci::Position RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace);
 	SelectionPosition RealizeVirtualSpace(const SelectionPosition &position);
 	void AddChar(char ch);
 	virtual void AddCharUTF(const char *s, unsigned int len, bool treatAsDBCS=false);
@@ -403,7 +403,7 @@
 	void ClearAll();
 	void ClearDocumentStyle();
 	void Cut();
-	void PasteRectangular(SelectionPosition pos, const char *ptr, int len);
+	void PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len);
 	virtual void Copy() = 0;
 	virtual void CopyAllowLine();
 	virtual bool CanPaste();
@@ -421,26 +421,26 @@
 	virtual void SetCtrlID(int identifier);
 	virtual int GetCtrlID() { return ctrlID; }
 	virtual void NotifyParent(SCNotification scn) = 0;
-	virtual void NotifyStyleToNeeded(int endStyleNeeded);
+	virtual void NotifyStyleToNeeded(Sci::Position endStyleNeeded);
 	void NotifyChar(int ch);
 	void NotifySavePoint(bool isSavePoint);
 	void NotifyModifyAttempt();
 	virtual void NotifyDoubleClick(Point pt, int modifiers);
 	virtual void NotifyDoubleClick(Point pt, bool shift, bool ctrl, bool alt);
-	void NotifyHotSpotClicked(int position, int modifiers);
-	void NotifyHotSpotClicked(int position, bool shift, bool ctrl, bool alt);
-	void NotifyHotSpotDoubleClicked(int position, int modifiers);
-	void NotifyHotSpotDoubleClicked(int position, bool shift, bool ctrl, bool alt);
-	void NotifyHotSpotReleaseClick(int position, int modifiers);
-	void NotifyHotSpotReleaseClick(int position, bool shift, bool ctrl, bool alt);
+	void NotifyHotSpotClicked(Sci::Position position, int modifiers);
+	void NotifyHotSpotClicked(Sci::Position position, bool shift, bool ctrl, bool alt);
+	void NotifyHotSpotDoubleClicked(Sci::Position position, int modifiers);
+	void NotifyHotSpotDoubleClicked(Sci::Position position, bool shift, bool ctrl, bool alt);
+	void NotifyHotSpotReleaseClick(Sci::Position position, int modifiers);
+	void NotifyHotSpotReleaseClick(Sci::Position position, bool shift, bool ctrl, bool alt);
 	bool NotifyUpdateUI();
 	void NotifyPainted();
-	void NotifyIndicatorClick(bool click, int position, int modifiers);
-	void NotifyIndicatorClick(bool click, int position, bool shift, bool ctrl, bool alt);
+	void NotifyIndicatorClick(bool click, Sci::Position position, int modifiers);
+	void NotifyIndicatorClick(bool click, Sci::Position position, bool shift, bool ctrl, bool alt);
 	bool NotifyMarginClick(Point pt, int modifiers);
 	bool NotifyMarginClick(Point pt, bool shift, bool ctrl, bool alt);
 	bool NotifyMarginRightClick(Point pt, int modifiers);
-	void NotifyNeedShown(int pos, int len);
+	void NotifyNeedShown(Sci::Position pos, Sci::Position len);
 	void NotifyDwelling(Point pt, bool state);
 	void NotifyZoom();
 
@@ -449,7 +449,7 @@
 	void CheckModificationForWrap(DocModification mh);
 	void NotifyModified(Document *document, DocModification mh, void *userData);
 	void NotifyDeleted(Document *document, void *userData);
-	void NotifyStyleNeeded(Document *doc, void *userData, int endPos);
+	void NotifyStyleNeeded(Document *doc, void *userData, Sci::Position endPos);
 	void NotifyLexerChanged(Document *doc, void *userData);
 	void NotifyErrorOccurred(Document *doc, void *userData, int status);
 	void NotifyMacroRecord(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
@@ -466,11 +466,11 @@
 	SelectionPosition PositionUpOrDown(SelectionPosition spStart, int direction, int lastX);
 	void CursorUpOrDown(int direction, Selection::selTypes selt);
 	void ParaUpOrDown(int direction, Selection::selTypes selt);
-	Range RangeDisplayLine(int lineVisible);
-	int StartEndDisplayLine(int pos, bool start);
-	int VCHomeDisplayPosition(int position);
-	int VCHomeWrapPosition(int position);
-	int LineEndWrapPosition(int position);
+	Range RangeDisplayLine(Sci::Line lineVisible);
+	Sci::Position StartEndDisplayLine(Sci::Position pos, bool start);
+	Sci::Position VCHomeDisplayPosition(Sci::Position position);
+	Sci::Position VCHomeWrapPosition(Sci::Position position);
+	Sci::Position LineEndWrapPosition(Sci::Position position);
 	int HorizontalMove(unsigned int iMessage);
 	int DelWordOrLine(unsigned int iMessage);
 	virtual int KeyCommand(unsigned int iMessage);
@@ -484,13 +484,13 @@
 	long FindText(uptr_t wParam, sptr_t lParam);
 	void SearchAnchor();
 	long SearchText(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
-	long SearchInTarget(const char *text, int length);
-	void GoToLine(int lineNo);
+	long SearchInTarget(const char *text, Sci::Position length);
+	void GoToLine(Sci::Line lineNo);
 
 	virtual void CopyToClipboard(const SelectionText &selectedText) = 0;
-	std::string RangeText(int start, int end) const;
+	std::string RangeText(Sci::Position start, Sci::Position end) const;
 	void CopySelectionRange(SelectionText *ss, bool allowLineCopy=false);
-	void CopyRangeToClipboard(int start, int end);
+	void CopyRangeToClipboard(Sci::Position start, Sci::Position end);
 	void CopyText(int length, const char *text);
 	void SetDragPosition(SelectionPosition newPos);
 	virtual void DisplayCursor(Window::Cursor c);
@@ -499,13 +499,13 @@
 	void DropAt(SelectionPosition position, const char *value, size_t lengthValue, bool moving, bool rectangular);
 	void DropAt(SelectionPosition position, const char *value, bool moving, bool rectangular);
 	/** PositionInSelection returns true if position in selection. */
-	bool PositionInSelection(int pos);
+	bool PositionInSelection(Sci::Position pos);
 	bool PointInSelection(Point pt);
 	bool PointInSelMargin(Point pt) const;
 	Window::Cursor GetMarginCursor(Point pt) const;
-	void TrimAndSetSelection(int currentPos_, int anchor_);
-	void LineSelection(int lineCurrentPos_, int lineAnchorPos_, bool wholeLine);
-	void WordSelection(int pos);
+	void TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_);
+	void LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine);
+	void WordSelection(Sci::Position pos);
 	void DwellEnd(bool mouseMoved);
 	void MouseLeave();
 	virtual void ButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
@@ -529,49 +529,49 @@
 	virtual bool HaveMouseCapture() = 0;
 	void SetFocusState(bool focusState);
 
-	int PositionAfterArea(PRectangle rcArea) const;
-	void StyleToPositionInView(Position pos);
-	int PositionAfterMaxStyling(int posMax, bool scrolling) const;
+	Sci::Position PositionAfterArea(PRectangle rcArea) const;
+	void StyleToPositionInView(Sci::Position pos);
+	Sci::Position PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const;
 	void StartIdleStyling(bool truncatedLastStyling);
 	void StyleAreaBounded(PRectangle rcArea, bool scrolling);
 	void IdleStyling();
 	virtual void IdleWork();
-	virtual void QueueIdleWork(WorkNeeded::workItems items, int upTo=0);
+	virtual void QueueIdleWork(WorkNeeded::workItems items, Sci::Position upTo=0);
 
 	virtual bool PaintContains(PRectangle rc);
 	bool PaintContainsMargin();
 	void CheckForChangeOutsidePaint(Range r);
-	void SetBraceHighlight(Position pos0, Position pos1, int matchStyle);
+	void SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle);
 
-	void SetAnnotationHeights(int start, int end);
+	void SetAnnotationHeights(Sci::Line start, Sci::Line end);
 	virtual void SetDocPointer(Document *document);
 
 	void SetAnnotationVisible(int visible);
 
-	int ExpandLine(int line);
-	void SetFoldExpanded(int lineDoc, bool expanded);
-	void FoldLine(int line, int action);
-	void FoldExpand(int line, int action, int level);
-	int ContractedFoldNext(int lineStart) const;
-	void EnsureLineVisible(int lineDoc, bool enforcePolicy);
-	void FoldChanged(int line, int levelNow, int levelPrev);
-	void NeedShown(int pos, int len);
+	Sci::Line ExpandLine(Sci::Line line);
+	void SetFoldExpanded(Sci::Line lineDoc, bool expanded);
+	void FoldLine(Sci::Line line, int action);
+	void FoldExpand(Sci::Line line, int action, int level);
+	Sci::Line ContractedFoldNext(Sci::Line lineStart) const;
+	void EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy);
+	void FoldChanged(Sci::Line line, int levelNow, int levelPrev);
+	void NeedShown(Sci::Position pos, Sci::Position len);
 	void FoldAll(int action);
 
-	int GetTag(char *tagValue, int tagNumber);
-	int ReplaceTarget(bool replacePatterns, const char *text, int length=-1);
+	Sci::Position GetTag(char *tagValue, int tagNumber);
+	Sci::Position ReplaceTarget(bool replacePatterns, const char *text, Sci::Position length=-1);
 
-	bool PositionIsHotspot(int position) const;
+	bool PositionIsHotspot(Sci::Position position) const;
 	bool PointIsHotspot(Point pt);
 	void SetHotSpotRange(Point *pt);
 	Range GetHotSpotRange() const;
-	void SetHoverIndicatorPosition(int position);
+	void SetHoverIndicatorPosition(Sci::Position position);
 	void SetHoverIndicatorPoint(Point pt);
 
 	int CodePage() const;
 	virtual bool ValidCodePage(int /* codePage */) const { return true; }
 	int WrapCount(int line);
-	void AddStyledText(char *buffer, int appendLength);
+	void AddStyledText(char *buffer, Sci::Position appendLength);
 
 	virtual sptr_t DefWndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) = 0;
 	bool ValidMargin(uptr_t wParam) const;
diff -r 1788f6795302 -r a0f26eaf474d src/MarginView.cxx
--- a/src/MarginView.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/MarginView.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -183,7 +183,7 @@
 	return markerCheck;
 }
 
-void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRectangle rcMargin,
+void MarginView::PaintMargin(Surface *surface, Sci::Line topLine, PRectangle rc, PRectangle rcMargin,
 	const EditModel &model, const ViewStyle &vs) {
 
 	PRectangle rcSelMargin = rcMargin;
@@ -230,8 +230,8 @@
 			}
 
 			const int lineStartPaint = static_cast<int>(rcMargin.top + ptOrigin.y) / vs.lineHeight;
-			int visibleLine = model.TopLineOfMain() + lineStartPaint;
-			int yposScreen = lineStartPaint * vs.lineHeight - static_cast<int>(ptOrigin.y);
+			Sci::Line visibleLine = model.TopLineOfMain() + lineStartPaint;
+			Sci::Position yposScreen = lineStartPaint * vs.lineHeight - static_cast<Sci::Position>(ptOrigin.y);
 			// Work out whether the top line is whitespace located after a
 			// lessening of fold level which implies a 'fold tail' but which should not
 			// be displayed until the last of a sequence of whitespace.
@@ -239,7 +239,7 @@
 			if (vs.ms[margin].mask & SC_MASK_FOLDERS) {
 				int level = model.pdoc->GetLevel(model.cs.DocFromDisplay(visibleLine));
 				if (level & SC_FOLDLEVELWHITEFLAG) {
-					int lineBack = model.cs.DocFromDisplay(visibleLine);
+					Sci::Line lineBack = model.cs.DocFromDisplay(visibleLine);
 					int levelPrev = level;
 					while ((lineBack > 0) && (levelPrev & SC_FOLDLEVELWHITEFLAG)) {
 						lineBack--;
@@ -251,7 +251,7 @@
 					}
 				}
 				if (highlightDelimiter.isEnabled) {
-					int lastLine = model.cs.DocFromDisplay(topLine + model.LinesOnScreen()) + 1;
+					Sci::Line lastLine = model.cs.DocFromDisplay(topLine + model.LinesOnScreen()) + 1;
 					model.pdoc->GetHighlightDelimiters(highlightDelimiter, model.pdoc->LineFromPosition(model.sel.MainCaret()), lastLine);
 				}
 			}
@@ -265,10 +265,10 @@
 			while ((visibleLine < model.cs.LinesDisplayed()) && yposScreen < rc.bottom) {
 
 				PLATFORM_ASSERT(visibleLine < model.cs.LinesDisplayed());
-				const int lineDoc = model.cs.DocFromDisplay(visibleLine);
+				const Sci::Line lineDoc = model.cs.DocFromDisplay(visibleLine);
 				PLATFORM_ASSERT(model.cs.GetVisible(lineDoc));
-				const int firstVisibleLine = model.cs.DisplayFromDoc(lineDoc);
-				const int lastVisibleLine = model.cs.DisplayLastFromDoc(lineDoc);
+				const Sci::Line firstVisibleLine = model.cs.DisplayFromDoc(lineDoc);
+				const Sci::Line lastVisibleLine = model.cs.DisplayLastFromDoc(lineDoc);
 				const bool firstSubLine = visibleLine == firstVisibleLine;
 				const bool lastSubLine = visibleLine == lastVisibleLine;
 
@@ -313,7 +313,7 @@
 							}
 						}
 						needWhiteClosure = false;
-						const int firstFollowupLine = model.cs.DocFromDisplay(model.cs.DisplayFromDoc(lineDoc + 1));
+						const Sci::Line firstFollowupLine = model.cs.DocFromDisplay(model.cs.DisplayFromDoc(lineDoc + 1));
 						const int firstFollowupLineLevel = model.pdoc->GetLevel(firstFollowupLine);
 						const int secondFollowupLineLevelNum = LevelNumber(model.pdoc->GetLevel(firstFollowupLine + 1));
 						if (!model.cs.GetExpanded(lineDoc)) {
diff -r 1788f6795302 -r a0f26eaf474d src/MarginView.h
--- a/src/MarginView.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/MarginView.h	Fri Mar 31 18:19:38 2017 +1100
@@ -39,7 +39,7 @@
 	void DropGraphics(bool freeObjects);
 	void AllocateGraphics(const ViewStyle &vsDraw);
 	void RefreshPixMaps(Surface *surfaceWindow, WindowID wid, const ViewStyle &vsDraw);
-	void PaintMargin(Surface *surface, int topLine, PRectangle rc, PRectangle rcMargin,
+	void PaintMargin(Surface *surface, Sci::Line topLine, PRectangle rc, PRectangle rcMargin,
 		const EditModel &model, const ViewStyle &vs);
 };
 
diff -r 1788f6795302 -r a0f26eaf474d src/PerLine.cxx
--- a/src/PerLine.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/PerLine.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -131,13 +131,13 @@
 	markers.DeleteAll();
 }
 
-void LineMarkers::InsertLine(int line) {
+void LineMarkers::InsertLine(Sci::Line line) {
 	if (markers.Length()) {
 		markers.Insert(line, 0);
 	}
 }
 
-void LineMarkers::RemoveLine(int line) {
+void LineMarkers::RemoveLine(Sci::Line line) {
 	// Retain the markers from the deleted line by oring them into the previous line
 	if (markers.Length()) {
 		if (line > 0) {
@@ -147,9 +147,9 @@
 	}
 }
 
-int LineMarkers::LineFromHandle(int markerHandle) {
+Sci::Line LineMarkers::LineFromHandle(int markerHandle) {
 	if (markers.Length()) {
-		for (int line = 0; line < markers.Length(); line++) {
+		for (Sci::Line line = 0; line < markers.Length(); line++) {
 			if (markers[line]) {
 				if (markers[line]->Contains(markerHandle)) {
 					return line;
@@ -160,28 +160,28 @@
 	return -1;
 }
 
-void LineMarkers::MergeMarkers(int pos) {
-	if (markers[pos + 1] != NULL) {
-		if (markers[pos] == NULL)
-			markers[pos] = new MarkerHandleSet;
-		markers[pos]->CombineWith(markers[pos + 1]);
-		delete markers[pos + 1];
-		markers[pos + 1] = NULL;
+void LineMarkers::MergeMarkers(Sci::Line line) {
+	if (markers[line + 1] != NULL) {
+		if (markers[line] == NULL)
+			markers[line] = new MarkerHandleSet;
+		markers[line]->CombineWith(markers[line + 1]);
+		delete markers[line + 1];
+		markers[line + 1] = NULL;
 	}
 }
 
-int LineMarkers::MarkValue(int line) {
+int LineMarkers::MarkValue(Sci::Line line) {
 	if (markers.Length() && (line >= 0) && (line < markers.Length()) && markers[line])
 		return markers[line]->MarkValue();
 	else
 		return 0;
 }
 
-int LineMarkers::MarkerNext(int lineStart, int mask) const {
+Sci::Line LineMarkers::MarkerNext(Sci::Line lineStart, int mask) const {
 	if (lineStart < 0)
 		lineStart = 0;
-	int length = markers.Length();
-	for (int iLine = lineStart; iLine < length; iLine++) {
+	Sci::Line length = markers.Length();
+	for (Sci::Line iLine = lineStart; iLine < length; iLine++) {
 		MarkerHandleSet *onLine = markers[iLine];
 		if (onLine && ((onLine->MarkValue() & mask) != 0))
 		//if ((pdoc->GetMark(iLine) & lParam) != 0)
@@ -190,7 +190,7 @@
 	return -1;
 }
 
-int LineMarkers::AddMark(int line, int markerNum, int lines) {
+int LineMarkers::AddMark(Sci::Line line, int markerNum, Sci::Line lines) {
 	handleCurrent++;
 	if (!markers.Length()) {
 		// No existing markers so allocate one element per line
@@ -208,7 +208,7 @@
 	return handleCurrent;
 }
 
-bool LineMarkers::DeleteMark(int line, int markerNum, bool all) {
+bool LineMarkers::DeleteMark(Sci::Line line, int markerNum, bool all) {
 	bool someChanges = false;
 	if (markers.Length() && (line >= 0) && (line < markers.Length()) && markers[line]) {
 		if (markerNum == -1) {
@@ -227,7 +227,7 @@
 }
 
 void LineMarkers::DeleteMarkFromHandle(int markerHandle) {
-	int line = LineFromHandle(markerHandle);
+	Sci::Line line = LineFromHandle(markerHandle);
 	if (line >= 0) {
 		markers[line]->RemoveHandle(markerHandle);
 		if (markers[line]->Length() == 0) {
@@ -244,14 +244,14 @@
 	levels.DeleteAll();
 }
 
-void LineLevels::InsertLine(int line) {
+void LineLevels::InsertLine(Sci::Line line) {
 	if (levels.Length()) {
 		int level = (line < levels.Length()) ? levels[line] : SC_FOLDLEVELBASE;
 		levels.InsertValue(line, 1, level);
 	}
 }
 
-void LineLevels::RemoveLine(int line) {
+void LineLevels::RemoveLine(Sci::Line line) {
 	if (levels.Length()) {
 		// Move up following lines but merge header flag from this line
 		// to line before to avoid a temporary disappearence causing expansion.
@@ -264,7 +264,7 @@
 	}
 }
 
-void LineLevels::ExpandLevels(int sizeNew) {
+void LineLevels::ExpandLevels(Sci::Line sizeNew) {
 	levels.InsertValue(levels.Length(), sizeNew - levels.Length(), SC_FOLDLEVELBASE);
 }
 
@@ -272,7 +272,7 @@
 	levels.DeleteAll();
 }
 
-int LineLevels::SetLevel(int line, int level, int lines) {
+int LineLevels::SetLevel(Sci::Line line, int level, Sci::Line lines) {
 	int prev = 0;
 	if ((line >= 0) && (line < lines)) {
 		if (!levels.Length()) {
@@ -286,7 +286,7 @@
 	return prev;
 }
 
-int LineLevels::GetLevel(int line) const {
+int LineLevels::GetLevel(Sci::Line line) const {
 	if (levels.Length() && (line >= 0) && (line < levels.Length())) {
 		return levels[line];
 	} else {
@@ -301,7 +301,7 @@
 	lineStates.DeleteAll();
 }
 
-void LineState::InsertLine(int line) {
+void LineState::InsertLine(Sci::Line line) {
 	if (lineStates.Length()) {
 		lineStates.EnsureLength(line);
 		int val = (line < lineStates.Length()) ? lineStates[line] : 0;
@@ -309,27 +309,27 @@
 	}
 }
 
-void LineState::RemoveLine(int line) {
+void LineState::RemoveLine(Sci::Line line) {
 	if (lineStates.Length() > line) {
 		lineStates.Delete(line);
 	}
 }
 
-int LineState::SetLineState(int line, int state) {
+int LineState::SetLineState(Sci::Line line, int state) {
 	lineStates.EnsureLength(line + 1);
 	int stateOld = lineStates[line];
 	lineStates[line] = state;
 	return stateOld;
 }
 
-int LineState::GetLineState(int line) {
+int LineState::GetLineState(Sci::Line line) {
 	if (line < 0)
 		return 0;
 	lineStates.EnsureLength(line + 1);
 	return lineStates[line];
 }
 
-int LineState::GetMaxLineState() const {
+Sci::Line LineState::GetMaxLineState() const {
 	return lineStates.Length();
 }
 
@@ -366,42 +366,42 @@
 	ClearAll();
 }
 
-void LineAnnotation::InsertLine(int line) {
+void LineAnnotation::InsertLine(Sci::Line line) {
 	if (annotations.Length()) {
 		annotations.EnsureLength(line);
 		annotations.Insert(line, 0);
 	}
 }
 
-void LineAnnotation::RemoveLine(int line) {
+void LineAnnotation::RemoveLine(Sci::Line line) {
 	if (annotations.Length() && (line > 0) && (line <= annotations.Length())) {
 		delete []annotations[line-1];
 		annotations.Delete(line-1);
 	}
 }
 
-bool LineAnnotation::MultipleStyles(int line) const {
+bool LineAnnotation::MultipleStyles(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line])
 		return reinterpret_cast<AnnotationHeader *>(annotations[line])->style == IndividualStyles;
 	else
 		return 0;
 }
 
-int LineAnnotation::Style(int line) const {
+int LineAnnotation::Style(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line])
 		return reinterpret_cast<AnnotationHeader *>(annotations[line])->style;
 	else
 		return 0;
 }
 
-const char *LineAnnotation::Text(int line) const {
+const char *LineAnnotation::Text(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line])
 		return annotations[line]+sizeof(AnnotationHeader);
 	else
 		return 0;
 }
 
-const unsigned char *LineAnnotation::Styles(int line) const {
+const unsigned char *LineAnnotation::Styles(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line] && MultipleStyles(line))
 		return reinterpret_cast<unsigned char *>(annotations[line] + sizeof(AnnotationHeader) + Length(line));
 	else
@@ -414,7 +414,7 @@
 	return ret;
 }
 
-void LineAnnotation::SetText(int line, const char *text) {
+void LineAnnotation::SetText(Sci::Line line, const char *text) {
 	if (text && (line >= 0)) {
 		annotations.EnsureLength(line+1);
 		int style = Style(line);
@@ -443,7 +443,7 @@
 	annotations.DeleteAll();
 }
 
-void LineAnnotation::SetStyle(int line, int style) {
+void LineAnnotation::SetStyle(Sci::Line line, int style) {
 	annotations.EnsureLength(line+1);
 	if (!annotations[line]) {
 		annotations[line] = AllocateAnnotation(0, style);
@@ -451,7 +451,7 @@
 	reinterpret_cast<AnnotationHeader *>(annotations[line])->style = static_cast<short>(style);
 }
 
-void LineAnnotation::SetStyles(int line, const unsigned char *styles) {
+void LineAnnotation::SetStyles(Sci::Line line, const unsigned char *styles) {
 	if (line >= 0) {
 		annotations.EnsureLength(line+1);
 		if (!annotations[line]) {
@@ -474,14 +474,14 @@
 	}
 }
 
-int LineAnnotation::Length(int line) const {
+int LineAnnotation::Length(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line])
 		return reinterpret_cast<AnnotationHeader *>(annotations[line])->length;
 	else
 		return 0;
 }
 
-int LineAnnotation::Lines(int line) const {
+int LineAnnotation::Lines(Sci::Line line) const {
 	if (annotations.Length() && (line >= 0) && (line < annotations.Length()) && annotations[line])
 		return reinterpret_cast<AnnotationHeader *>(annotations[line])->lines;
 	else
@@ -499,21 +499,21 @@
 	tabstops.DeleteAll();
 }
 
-void LineTabstops::InsertLine(int line) {
+void LineTabstops::InsertLine(Sci::Line line) {
 	if (tabstops.Length()) {
 		tabstops.EnsureLength(line);
 		tabstops.Insert(line, 0);
 	}
 }
 
-void LineTabstops::RemoveLine(int line) {
+void LineTabstops::RemoveLine(Sci::Line line) {
 	if (tabstops.Length() > line) {
 		delete tabstops[line];
 		tabstops.Delete(line);
 	}
 }
 
-bool LineTabstops::ClearTabstops(int line) {
+bool LineTabstops::ClearTabstops(Sci::Line line) {
 	if (line < tabstops.Length()) {
 		TabstopList *tl = tabstops[line];
 		if (tl) {
@@ -524,7 +524,7 @@
 	return false;
 }
 
-bool LineTabstops::AddTabstop(int line, int x) {
+bool LineTabstops::AddTabstop(Sci::Line line, int x) {
 	tabstops.EnsureLength(line + 1);
 	if (!tabstops[line]) {
 		tabstops[line] = new TabstopList();
@@ -543,7 +543,7 @@
 	return false;
 }
 
-int LineTabstops::GetNextTabstop(int line, int x) const {
+int LineTabstops::GetNextTabstop(Sci::Line line, int x) const {
 	if (line < tabstops.Length()) {
 		TabstopList *tl = tabstops[line];
 		if (tl) {
diff -r 1788f6795302 -r a0f26eaf474d src/PerLine.h
--- a/src/PerLine.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/PerLine.h	Fri Mar 31 18:19:38 2017 +1100
@@ -49,16 +49,16 @@
 	}
 	virtual ~LineMarkers();
 	virtual void Init();
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
-	int MarkValue(int line);
-	int MarkerNext(int lineStart, int mask) const;
-	int AddMark(int line, int marker, int lines);
-	void MergeMarkers(int pos);
-	bool DeleteMark(int line, int markerNum, bool all);
+	int MarkValue(Sci::Line line);
+	Sci::Line MarkerNext(Sci::Line lineStart, int mask) const;
+	int AddMark(Sci::Line line, int marker, Sci::Line lines);
+	void MergeMarkers(Sci::Line line);
+	bool DeleteMark(Sci::Line line, int markerNum, bool all);
 	void DeleteMarkFromHandle(int markerHandle);
-	int LineFromHandle(int markerHandle);
+	Sci::Line LineFromHandle(int markerHandle);
 };
 
 class LineLevels : public PerLine {
@@ -66,13 +66,13 @@
 public:
 	virtual ~LineLevels();
 	virtual void Init();
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
-	void ExpandLevels(int sizeNew=-1);
+	void ExpandLevels(Sci::Line sizeNew=-1);
 	void ClearLevels();
-	int SetLevel(int line, int level, int lines);
-	int GetLevel(int line) const;
+	int SetLevel(Sci::Line line, int level, Sci::Line lines);
+	int GetLevel(Sci::Line line) const;
 };
 
 class LineState : public PerLine {
@@ -82,12 +82,12 @@
 	}
 	virtual ~LineState();
 	virtual void Init();
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
-	int SetLineState(int line, int state);
-	int GetLineState(int line);
-	int GetMaxLineState() const;
+	int SetLineState(Sci::Line line, int state);
+	int GetLineState(Sci::Line line);
+	Sci::Line GetMaxLineState() const;
 };
 
 class LineAnnotation : public PerLine {
@@ -97,19 +97,19 @@
 	}
 	virtual ~LineAnnotation();
 	virtual void Init();
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
-	bool MultipleStyles(int line) const;
-	int Style(int line) const;
-	const char *Text(int line) const;
-	const unsigned char *Styles(int line) const;
-	void SetText(int line, const char *text);
+	bool MultipleStyles(Sci::Line line) const;
+	int Style(Sci::Line line) const;
+	const char *Text(Sci::Line line) const;
+	const unsigned char *Styles(Sci::Line line) const;
+	void SetText(Sci::Line line, const char *text);
 	void ClearAll();
-	void SetStyle(int line, int style);
-	void SetStyles(int line, const unsigned char *styles);
-	int Length(int line) const;
-	int Lines(int line) const;
+	void SetStyle(Sci::Line line, int style);
+	void SetStyles(Sci::Line line, const unsigned char *styles);
+	int Length(Sci::Line line) const;
+	int Lines(Sci::Line line) const;
 };
 
 typedef std::vector<int> TabstopList;
@@ -121,12 +121,12 @@
 	}
 	virtual ~LineTabstops();
 	virtual void Init();
-	virtual void InsertLine(int line);
-	virtual void RemoveLine(int line);
+	virtual void InsertLine(Sci::Line line);
+	virtual void RemoveLine(Sci::Line line);
 
-	bool ClearTabstops(int line);
-	bool AddTabstop(int line, int x);
-	int GetNextTabstop(int line, int x) const;
+	bool ClearTabstops(Sci::Line line);
+	bool AddTabstop(Sci::Line line, int x);
+	int GetNextTabstop(Sci::Line line, int x) const;
 };
 
 #ifdef SCI_NAMESPACE
diff -r 1788f6795302 -r a0f26eaf474d src/Position.h
--- a/src/Position.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Position.h	Fri Mar 31 18:19:38 2017 +1100
@@ -16,6 +16,7 @@
 namespace Sci {
 
 typedef int Position;
+typedef int Line;
 
 // A later version (4.x) of this file may:
 //#if defined(SCI_LARGE_FILE_SUPPORT)
diff -r 1788f6795302 -r a0f26eaf474d src/PositionCache.cxx
--- a/src/PositionCache.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/PositionCache.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -149,7 +149,7 @@
 	lineStarts[line] = start;
 }
 
-void LineLayout::SetBracesHighlight(Range rangeLine, const Position braces[],
+void LineLayout::SetBracesHighlight(Range rangeLine, const Sci::Position braces[],
                                     char bracesMatchStyle, int xHighlight, bool ignoreStyle) {
 	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
 		int braceOffset = braces[0] - rangeLine.start;
@@ -171,7 +171,7 @@
 	}
 }
 
-void LineLayout::RestoreBracesHighlight(Range rangeLine, const Position braces[], bool ignoreStyle) {
+void LineLayout::RestoreBracesHighlight(Range rangeLine, const Sci::Position braces[], bool ignoreStyle) {
 	if (!ignoreStyle && rangeLine.ContainsCharacter(braces[0])) {
 		int braceOffset = braces[0] - rangeLine.start;
 		if (braceOffset < numCharsInLine) {
@@ -267,7 +267,7 @@
 	cache.resize(length_);
 }
 
-void LineLayoutCache::AllocateForLevel(int linesOnScreen, int linesInDoc) {
+void LineLayoutCache::AllocateForLevel(Sci::Line linesOnScreen, Sci::Line linesInDoc) {
 	PLATFORM_ASSERT(useCount == 0);
 	size_t lengthForLevel = 0;
 	if (level == llcCaret) {
@@ -320,15 +320,15 @@
 	}
 }
 
-LineLayout *LineLayoutCache::Retrieve(int lineNumber, int lineCaret, int maxChars, int styleClock_,
-                                      int linesOnScreen, int linesInDoc) {
+LineLayout *LineLayoutCache::Retrieve(Sci::Line lineNumber, Sci::Line lineCaret, int maxChars, int styleClock_,
+                                      Sci::Line linesOnScreen, Sci::Line linesInDoc) {
 	AllocateForLevel(linesOnScreen, linesInDoc);
 	if (styleClock != styleClock_) {
 		Invalidate(LineLayout::llCheckTextAndStyle);
 		styleClock = styleClock_;
 	}
 	allInvalidated = false;
-	int pos = -1;
+	Sci::Position pos = -1;
 	LineLayout *ret = 0;
 	if (level == llcCaret) {
 		pos = 0;
@@ -447,7 +447,7 @@
 	}
 }
 
-BreakFinder::BreakFinder(const LineLayout *ll_, const Selection *psel, Range lineRange_, int posLineStart_,
+BreakFinder::BreakFinder(const LineLayout *ll_, const Selection *psel, Range lineRange_, Sci::Position posLineStart_,
 	int xStart, bool breakForSelection, const Document *pdoc_, const SpecialRepresentations *preprs_, const ViewStyle *pvsDraw) :
 	ll(ll_),
 	lineRange(lineRange_),
@@ -486,7 +486,7 @@
 	if (pvsDraw && pvsDraw->indicatorsSetFore > 0) {
 		for (Decoration *deco = pdoc->decorations.root; deco; deco = deco->next) {
 			if (pvsDraw->indicators[deco->indicator].OverridesTextFore()) {
-				int startPos = deco->rs.EndRun(posLineStart);
+				Sci::Position startPos = deco->rs.EndRun(posLineStart);
 				while (startPos < (posLineStart + lineRange.end)) {
 					Insert(startPos - posLineStart);
 					startPos = deco->rs.EndRun(startPos);
diff -r 1788f6795302 -r a0f26eaf474d src/PositionCache.h
--- a/src/PositionCache.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/PositionCache.h	Fri Mar 31 18:19:38 2017 +1100
@@ -50,7 +50,7 @@
 	int *lineStarts;
 	int lenLineStarts;
 	/// Drawing is only performed for @a maxLineLength characters on each line.
-	int lineNumber;
+	Sci::Line lineNumber;
 	bool inCache;
 public:
 	enum { wrapWidthInfinite = 0x7ffffff };
@@ -86,9 +86,9 @@
 	Range SubLineRange(int line) const;
 	bool InLine(int offset, int line) const;
 	void SetLineStart(int line, int start);
-	void SetBracesHighlight(Range rangeLine, const Position braces[],
+	void SetBracesHighlight(Range rangeLine, const Sci::Position braces[],
 		char bracesMatchStyle, int xHighlight, bool ignoreStyle);
-	void RestoreBracesHighlight(Range rangeLine, const Position braces[], bool ignoreStyle);
+	void RestoreBracesHighlight(Range rangeLine, const Sci::Position braces[], bool ignoreStyle);
 	int FindBefore(XYPOSITION x, int lower, int upper) const;
 	int FindPositionFromX(XYPOSITION x, Range range, bool charPosition) const;
 	Point PointFromPosition(int posInLine, int lineHeight, PointEnd pe) const;
@@ -104,7 +104,7 @@
 	int styleClock;
 	int useCount;
 	void Allocate(size_t length_);
-	void AllocateForLevel(int linesOnScreen, int linesInDoc);
+	void AllocateForLevel(Sci::Line linesOnScreen, Sci::Line linesInDoc);
 public:
 	LineLayoutCache();
 	virtual ~LineLayoutCache();
@@ -118,8 +118,8 @@
 	void Invalidate(LineLayout::validLevel validity_);
 	void SetLevel(int level_);
 	int GetLevel() const { return level; }
-	LineLayout *Retrieve(int lineNumber, int lineCaret, int maxChars, int styleClock_,
-		int linesOnScreen, int linesInDoc);
+	LineLayout *Retrieve(Sci::Line lineNumber, Sci::Line lineCaret, int maxChars, int styleClock_,
+		Sci::Line linesOnScreen, Sci::Line linesInDoc);
 	void Dispose(LineLayout *ll);
 };
 
@@ -176,7 +176,7 @@
 class BreakFinder {
 	const LineLayout *ll;
 	Range lineRange;
-	int posLineStart;
+	Sci::Position posLineStart;
 	int nextBreak;
 	std::vector<int> selAndEdge;
 	unsigned int saeCurrentPos;
@@ -194,7 +194,7 @@
 	enum { lengthStartSubdivision = 300 };
 	// Try to make each subdivided run lengthEachSubdivision or shorter.
 	enum { lengthEachSubdivision = 100 };
-	BreakFinder(const LineLayout *ll_, const Selection *psel, Range rangeLine_, int posLineStart_,
+	BreakFinder(const LineLayout *ll_, const Selection *psel, Range rangeLine_, Sci::Position posLineStart_,
 		int xStart, bool breakForSelection, const Document *pdoc_, const SpecialRepresentations *preprs_, const ViewStyle *pvsDraw);
 	~BreakFinder();
 	TextSegment Next();
diff -r 1788f6795302 -r a0f26eaf474d src/RESearch.cxx
--- a/src/RESearch.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/RESearch.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -277,9 +277,9 @@
 void RESearch::GrabMatches(CharacterIndexer &ci) {
 	for (unsigned int i = 0; i < MAXTAG; i++) {
 		if ((bopat[i] != NOTFOUND) && (eopat[i] != NOTFOUND)) {
-			unsigned int len = eopat[i] - bopat[i];
+			Sci::Position len = eopat[i] - bopat[i];
 			pat[i].resize(len);
-			for (unsigned int j = 0; j < len; j++)
+			for (Sci::Position j = 0; j < len; j++)
 				pat[i][j] = ci.CharAt(bopat[i] + j);
 		}
 	}
@@ -434,7 +434,7 @@
 	return result;
 }
 
-const char *RESearch::Compile(const char *pattern, int length, bool caseSensitive, bool posix) {
+const char *RESearch::Compile(const char *pattern, Sci::Position length, bool caseSensitive, bool posix) {
 	char *mp=nfa;          /* nfa pointer       */
 	char *lp;              /* saved pointer     */
 	char *sp=nfa;          /* another one       */
@@ -755,9 +755,9 @@
  *  respectively.
  *
  */
-int RESearch::Execute(CharacterIndexer &ci, int lp, int endp) {
+int RESearch::Execute(CharacterIndexer &ci, Sci::Position lp, Sci::Position endp) {
 	unsigned char c;
-	int ep = NOTFOUND;
+	Sci::Position ep = NOTFOUND;
 	char *ap = nfa;
 
 	bol = lp;
@@ -844,13 +844,13 @@
 #define CHRSKIP 3	/* [CLO] CHR chr END      */
 #define CCLSKIP 34	/* [CLO] CCL 32 bytes END */
 
-int RESearch::PMatch(CharacterIndexer &ci, int lp, int endp, char *ap) {
+Sci::Position RESearch::PMatch(CharacterIndexer &ci, Sci::Position lp, Sci::Position endp, char *ap) {
 	int op, c, n;
-	int e;		/* extra pointer for CLO  */
-	int bp;		/* beginning of subpat... */
-	int ep;		/* ending of subpat...    */
-	int are;	/* to save the line ptr.  */
-	int llp;	/* lazy lp for LCLO       */
+	Sci::Position e;		/* extra pointer for CLO  */
+	Sci::Position bp;		/* beginning of subpat... */
+	Sci::Position ep;		/* ending of subpat...    */
+	Sci::Position are;	/* to save the line ptr.  */
+	Sci::Position llp;	/* lazy lp for LCLO       */
 
 	while ((op = *ap++) != END)
 		switch (op) {
@@ -940,7 +940,7 @@
 			llp = lp;
 			e = NOTFOUND;
 			while (llp >= are) {
-				int q;
+				Sci::Position q;
 				if ((q = PMatch(ci, llp, endp, ap)) != NOTFOUND) {
 					e = q;
 					lp = llp;
diff -r 1788f6795302 -r a0f26eaf474d src/RESearch.h
--- a/src/RESearch.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/RESearch.h	Fri Mar 31 18:19:38 2017 +1100
@@ -23,7 +23,7 @@
 
 class CharacterIndexer {
 public:
-	virtual char CharAt(int index)=0;
+	virtual char CharAt(Sci::Position index)=0;
 	virtual ~CharacterIndexer() {
 	}
 };
@@ -35,15 +35,15 @@
 	~RESearch();
 	void Clear();
 	void GrabMatches(CharacterIndexer &ci);
-	const char *Compile(const char *pattern, int length, bool caseSensitive, bool posix);
-	int Execute(CharacterIndexer &ci, int lp, int endp);
+	const char *Compile(const char *pattern, Sci::Position length, bool caseSensitive, bool posix);
+	int Execute(CharacterIndexer &ci, Sci::Position lp, Sci::Position endp);
 
 	enum { MAXTAG=10 };
 	enum { MAXNFA=4096 };
 	enum { NOTFOUND=-1 };
 
-	int bopat[MAXTAG];
-	int eopat[MAXTAG];
+	Sci::Position bopat[MAXTAG];
+	Sci::Position eopat[MAXTAG];
 	std::string pat[MAXTAG];
 
 private:
@@ -51,10 +51,10 @@
 	void ChSetWithCase(unsigned char c, bool caseSensitive);
 	int GetBackslashExpression(const char *pattern, int &incr);
 
-	int PMatch(CharacterIndexer &ci, int lp, int endp, char *ap);
+	Sci::Position PMatch(CharacterIndexer &ci, Sci::Position lp, Sci::Position endp, char *ap);
 
-	int bol;
-	int tagstk[MAXTAG];  /* subpat tag stack */
+	Sci::Position bol;
+	Sci::Position tagstk[MAXTAG];  /* subpat tag stack */
 	char nfa[MAXNFA];    /* automaton */
 	int sta;
 	unsigned char bittab[BITBLK]; /* bit table for CCL pre-set bits */
diff -r 1788f6795302 -r a0f26eaf474d src/ScintillaBase.cxx
--- a/src/ScintillaBase.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/ScintillaBase.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -207,24 +207,24 @@
 	sci->AutoCompleteCompleted(0, SC_AC_DOUBLECLICK);
 }
 
-void ScintillaBase::AutoCompleteInsert(Position startPos, int removeLen, const char *text, int textLen) {
+void ScintillaBase::AutoCompleteInsert(Sci::Position startPos, int removeLen, const char *text, int textLen) {
 	UndoGroup ug(pdoc);
 	if (multiAutoCMode == SC_MULTIAUTOC_ONCE) {
 		pdoc->DeleteChars(startPos, removeLen);
-		const int lengthInserted = pdoc->InsertString(startPos, text, textLen);
+		const Sci::Position lengthInserted = pdoc->InsertString(startPos, text, textLen);
 		SetEmptySelection(startPos + lengthInserted);
 	} else {
 		// SC_MULTIAUTOC_EACH
 		for (size_t r=0; r<sel.Count(); r++) {
 			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
 				sel.Range(r).End().Position())) {
-				int positionInsert = sel.Range(r).Start().Position();
+				Sci::Position positionInsert = sel.Range(r).Start().Position();
 				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
 				if (positionInsert - removeLen >= 0) {
 					positionInsert -= removeLen;
 					pdoc->DeleteChars(positionInsert, removeLen);
 				}
-				const int lengthInserted = pdoc->InsertString(positionInsert, text, textLen);
+				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, text, textLen);
 				if (lengthInserted > 0) {
 					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
 					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
@@ -382,7 +382,7 @@
 	scn.listCompletionMethod = completionMethod;
 	scn.wParam = listType;
 	scn.listType = listType;
-	Position firstPos = ac.posStart - ac.startLen;
+	Sci::Position firstPos = ac.posStart - ac.startLen;
 	scn.position = firstPos;
 	scn.lParam = firstPos;
 	scn.text = selected.c_str();
@@ -395,7 +395,7 @@
 	if (listType > 0)
 		return;
 
-	Position endPos = sel.MainCaret();
+	Sci::Position endPos = sel.MainCaret();
 	if (ac.dropRestOfWord)
 		endPos = pdoc->ExtendWordSelect(endPos, 1, true);
 	if (endPos < firstPos)
@@ -771,11 +771,11 @@
 
 #endif
 
-void ScintillaBase::NotifyStyleToNeeded(int endStyleNeeded) {
+void ScintillaBase::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
 #ifdef SCI_LEXER
 	if (DocumentLexState()->lexLanguage != SCLEX_CONTAINER) {
-		int lineEndStyled = pdoc->LineFromPosition(pdoc->GetEndStyled());
-		int endStyled = pdoc->LineStart(lineEndStyled);
+		Sci::Line lineEndStyled = pdoc->LineFromPosition(pdoc->GetEndStyled());
+		Sci::Position endStyled = pdoc->LineStart(lineEndStyled);
 		DocumentLexState()->Colourise(endStyled, endStyleNeeded);
 		return;
 	}
@@ -994,10 +994,10 @@
 
 	case SCI_COLOURISE:
 		if (DocumentLexState()->lexLanguage == SCLEX_CONTAINER) {
-			pdoc->ModifiedAt(static_cast<int>(wParam));
-			NotifyStyleToNeeded((lParam == -1) ? pdoc->Length() : static_cast<int>(lParam));
+			pdoc->ModifiedAt(static_cast<Sci::Position>(wParam));
+			NotifyStyleToNeeded((lParam == -1) ? pdoc->Length() : static_cast<Sci::Position>(lParam));
 		} else {
-			DocumentLexState()->Colourise(static_cast<int>(wParam), static_cast<int>(lParam));
+			DocumentLexState()->Colourise(static_cast<Sci::Position>(wParam), static_cast<Sci::Position>(lParam));
 		}
 		Redraw();
 		break;
diff -r 1788f6795302 -r a0f26eaf474d src/ScintillaBase.h
--- a/src/ScintillaBase.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/ScintillaBase.h	Fri Mar 31 18:19:38 2017 +1100
@@ -67,7 +67,7 @@
 	virtual void CancelModes();
 	virtual int KeyCommand(unsigned int iMessage);
 
-	void AutoCompleteInsert(Position startPos, int removeLen, const char *text, int textLen);
+	void AutoCompleteInsert(Sci::Position startPos, int removeLen, const char *text, int textLen);
 	void AutoCompleteStart(int lenEntered, const char *list);
 	void AutoCompleteCancel();
 	void AutoCompleteMove(int delta);
@@ -91,7 +91,7 @@
 	virtual void ButtonDown(Point pt, unsigned int curTime, bool shift, bool ctrl, bool alt);
 	virtual void RightButtonDownWithModifiers(Point pt, unsigned int curTime, int modifiers);
 
-	void NotifyStyleToNeeded(int endStyleNeeded);
+	void NotifyStyleToNeeded(Sci::Position endStyleNeeded);
 	void NotifyLexerChanged(Document *doc, void *userData);
 
 public:
diff -r 1788f6795302 -r a0f26eaf474d src/Selection.cxx
--- a/src/Selection.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Selection.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -22,10 +22,10 @@
 using namespace Scintilla;
 #endif
 
-void SelectionPosition::MoveForInsertDelete(bool insertion, int startChange, int length) {
+void SelectionPosition::MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length) {
 	if (insertion) {
 		if (position == startChange) {
-			int virtualLengthRemove = std::min(length, virtualSpace);
+			Sci::Position virtualLengthRemove = std::min(length, virtualSpace);
 			virtualSpace -= virtualLengthRemove;
 			position += virtualLengthRemove;
 		} else if (position > startChange) {
@@ -36,7 +36,7 @@
 			virtualSpace = 0;
 		}
 		if (position > startChange) {
-			int endDeletion = startChange + length;
+			Sci::Position endDeletion = startChange + length;
 			if (position > endDeletion) {
 				position -= length;
 			} else {
@@ -75,7 +75,7 @@
 		return *this > other;
 }
 
-int SelectionRange::Length() const {
+Sci::Position SelectionRange::Length() const {
 	if (anchor > caret) {
 		return anchor.Position() - caret.Position();
 	} else {
@@ -83,12 +83,12 @@
 	}
 }
 
-void SelectionRange::MoveForInsertDelete(bool insertion, int startChange, int length) {
+void SelectionRange::MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length) {
 	caret.MoveForInsertDelete(insertion, startChange, length);
 	anchor.MoveForInsertDelete(insertion, startChange, length);
 }
 
-bool SelectionRange::Contains(int pos) const {
+bool SelectionRange::Contains(Sci::Position pos) const {
 	if (anchor > caret)
 		return (pos >= caret.Position()) && (pos <= anchor.Position());
 	else
@@ -102,7 +102,7 @@
 		return (sp >= anchor) && (sp <= caret);
 }
 
-bool SelectionRange::ContainsCharacter(int posCharacter) const {
+bool SelectionRange::ContainsCharacter(Sci::Position posCharacter) const {
 	if (anchor > caret)
 		return (posCharacter >= caret.Position()) && (posCharacter < anchor.Position());
 	else
@@ -168,7 +168,7 @@
 // If range is all virtual collapse to start of virtual space
 void SelectionRange::MinimizeVirtualSpace() {
 	if (caret.Position() == anchor.Position()) {
-		int virtualSpace = caret.VirtualSpace();
+		Sci::Position virtualSpace = caret.VirtualSpace();
 		if (virtualSpace > anchor.VirtualSpace())
 			virtualSpace = anchor.VirtualSpace();
 		caret.SetVirtualSpace(virtualSpace);
@@ -187,11 +187,11 @@
 	return (selType == selRectangle) || (selType == selThin);
 }
 
-int Selection::MainCaret() const {
+Sci::Position Selection::MainCaret() const {
 	return ranges[mainRange].caret.Position();
 }
 
-int Selection::MainAnchor() const {
+Sci::Position Selection::MainAnchor() const {
 	return ranges[mainRange].anchor.Position();
 }
 
@@ -284,15 +284,15 @@
 	return lastPosition;
 }
 
-int Selection::Length() const {
-	int len = 0;
+Sci::Position Selection::Length() const {
+	Sci::Position len = 0;
 	for (size_t i=0; i<ranges.size(); i++) {
 		len += ranges[i].Length();
 	}
 	return len;
 }
 
-void Selection::MovePositions(bool insertion, int startChange, int length) {
+void Selection::MovePositions(bool insertion, Sci::Position startChange, Sci::Position length) {
 	for (size_t i=0; i<ranges.size(); i++) {
 		ranges[i].MoveForInsertDelete(insertion, startChange, length);
 	}
@@ -376,7 +376,7 @@
 	tentativeMain = false;
 }
 
-int Selection::CharacterInSelection(int posCharacter) const {
+int Selection::CharacterInSelection(Sci::Position posCharacter) const {
 	for (size_t i=0; i<ranges.size(); i++) {
 		if (ranges[i].ContainsCharacter(posCharacter))
 			return i == mainRange ? 1 : 2;
@@ -384,7 +384,7 @@
 	return 0;
 }
 
-int Selection::InSelectionForEOL(int pos) const {
+int Selection::InSelectionForEOL(Sci::Position pos) const {
 	for (size_t i=0; i<ranges.size(); i++) {
 		if (!ranges[i].Empty() && (pos > ranges[i].Start().Position()) && (pos <= ranges[i].End().Position()))
 			return i == mainRange ? 1 : 2;
@@ -392,8 +392,8 @@
 	return 0;
 }
 
-int Selection::VirtualSpaceFor(int pos) const {
-	int virtualSpace = 0;
+Sci::Position Selection::VirtualSpaceFor(Sci::Position pos) const {
+	Sci::Position virtualSpace = 0;
 	for (size_t i=0; i<ranges.size(); i++) {
 		if ((ranges[i].caret.Position() == pos) && (virtualSpace < ranges[i].caret.VirtualSpace()))
 			virtualSpace = ranges[i].caret.VirtualSpace();
diff -r 1788f6795302 -r a0f26eaf474d src/Selection.h
--- a/src/Selection.h	Thu Mar 30 09:11:48 2017 +1100
+++ b/src/Selection.h	Fri Mar 31 18:19:38 2017 +1100
@@ -13,10 +13,10 @@
 #endif
 
 class SelectionPosition {
-	int position;
-	int virtualSpace;
+	Sci::Position position;
+	Sci::Position virtualSpace;
 public:
-	explicit SelectionPosition(int position_=INVALID_POSITION, int virtualSpace_=0) : position(position_), virtualSpace(virtualSpace_) {
+	explicit SelectionPosition(Sci::Position position_=INVALID_POSITION, Sci::Position virtualSpace_=0) : position(position_), virtualSpace(virtualSpace_) {
 		PLATFORM_ASSERT(virtualSpace < 800000);
 		if (virtualSpace < 0)
 			virtualSpace = 0;
@@ -25,7 +25,7 @@
 		position = 0;
 		virtualSpace = 0;
 	}
-	void MoveForInsertDelete(bool insertion, int startChange, int length);
+	void MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length);
 	bool operator ==(const SelectionPosition &other) const {
 		return position == other.position && virtualSpace == other.virtualSpace;
 	}
@@ -33,22 +33,22 @@
 	bool operator >(const SelectionPosition &other) const;
 	bool operator <=(const SelectionPosition &other) const;
 	bool operator >=(const SelectionPosition &other) const;
-	int Position() const {
+	Sci::Position Position() const {
 		return position;
 	}
-	void SetPosition(int position_) {
+	void SetPosition(Sci::Position position_) {
 		position = position_;
 		virtualSpace = 0;
 	}
-	int VirtualSpace() const {
+	Sci::Position VirtualSpace() const {
 		return virtualSpace;
 	}
-	void SetVirtualSpace(int virtualSpace_) {
+	void SetVirtualSpace(Sci::Position virtualSpace_) {
 		PLATFORM_ASSERT(virtualSpace_ < 800000);
 		if (virtualSpace_ >= 0)
 			virtualSpace = virtualSpace_;
 	}
-	void Add(int increment) {
+	void Add(Sci::Position increment) {
 		position = position + increment;
 	}
 	bool IsValid() const {
@@ -90,17 +90,17 @@
 	}
 	explicit SelectionRange(SelectionPosition single) : caret(single), anchor(single) {
 	}
-	explicit SelectionRange(int single) : caret(single), anchor(single) {
+	explicit SelectionRange(Sci::Position single) : caret(single), anchor(single) {
 	}
 	SelectionRange(SelectionPosition caret_, SelectionPosition anchor_) : caret(caret_), anchor(anchor_) {
 	}
-	SelectionRange(int caret_, int anchor_) : caret(caret_), anchor(anchor_) {
+	SelectionRange(Sci::Position caret_, Sci::Position anchor_) : caret(caret_), anchor(anchor_) {
 	}
 	bool Empty() const {
 		return anchor == caret;
 	}
-	int Length() const;
-	// int Width() const;	// Like Length but takes virtual space into account
+	Sci::Position Length() const;
+	// Sci::Position Width() const;	// Like Length but takes virtual space into account
 	bool operator ==(const SelectionRange &other) const {
 		return caret == other.caret && anchor == other.anchor;
 	}
@@ -115,10 +115,10 @@
 		anchor.SetVirtualSpace(0);
 		caret.SetVirtualSpace(0);
 	}
-	void MoveForInsertDelete(bool insertion, int startChange, int length);
-	bool Contains(int pos) const;
+	void MoveForInsertDelete(bool insertion, Sci::Position startChange, Sci::Position length);
+	bool Contains(Sci::Position pos) const;
 	bool Contains(SelectionPosition sp) const;
-	bool ContainsCharacter(int posCharacter) const;
+	bool ContainsCharacter(Sci::Position posCharacter) const;
 	SelectionSegment Intersect(SelectionSegment check) const;
 	SelectionPosition Start() const {
 		return (anchor < caret) ? anchor : caret;
@@ -146,8 +146,8 @@
 	Selection();
 	~Selection();
 	bool IsRectangular() const;
-	int MainCaret() const;
-	int MainAnchor() const;
+	Sci::Position MainCaret() const;
+	Sci::Position MainAnchor() const;
 	SelectionRange &Rectangular();
 	SelectionSegment Limits() const;
 	// This is for when you want to move the caret in response to a
@@ -166,8 +166,8 @@
 	void SetMoveExtends(bool moveExtends_);
 	bool Empty() const;
 	SelectionPosition Last() const;
-	int Length() const;
-	void MovePositions(bool insertion, int startChange, int length);
+	Sci::Position Length() const;
+	void MovePositions(bool insertion, Sci::Position startChange, Sci::Position length);
 	void TrimSelection(SelectionRange range);
 	void TrimOtherSelections(size_t r, SelectionRange range);
 	void SetSelection(SelectionRange range);
@@ -177,9 +177,9 @@
 	void DropAdditionalRanges();
 	void TentativeSelection(SelectionRange range);
 	void CommitTentative();
-	int CharacterInSelection(int posCharacter) const;
-	int InSelectionForEOL(int pos) const;
-	int VirtualSpaceFor(int pos) const;
+	int CharacterInSelection(Sci::Position posCharacter) const;
+	int InSelectionForEOL(Sci::Position pos) const;
+	Sci::Position VirtualSpaceFor(Sci::Position pos) const;
 	void Clear();
 	void RemoveDuplicates();
 	void RotateMain();
diff -r 1788f6795302 -r a0f26eaf474d win32/ScintillaWin.cxx
--- a/win32/ScintillaWin.cxx	Thu Mar 30 09:11:48 2017 +1100
+++ b/win32/ScintillaWin.cxx	Fri Mar 31 18:19:38 2017 +1100
@@ -294,15 +294,15 @@
 
 	bool DragThreshold(Point ptStart, Point ptNow) override;
 	void StartDrag() override;
-	int TargetAsUTF8(char *text);
+	Sci::Position TargetAsUTF8(char *text);
 	void AddCharUTF16(wchar_t const *wcs, unsigned int wclen);
-	int EncodedFromUTF8(char *utf8, char *encoded) const;
+	Sci::Position EncodedFromUTF8(char *utf8, char *encoded) const;
 	sptr_t WndPaint(uptr_t wParam);
 
 	sptr_t HandleCompositionWindowed(uptr_t wParam, sptr_t lParam);
 	sptr_t HandleCompositionInline(uptr_t wParam, sptr_t lParam);
 	static bool KoreanIME();
-	void MoveImeCarets(int offset);
+	void MoveImeCarets(Sci::Position offset);
 	void DrawImeIndicator(int indicator, int len);
 	void SetCandidateWindowPos();
 	void SelectionToHangul();
@@ -323,12 +323,12 @@
 	bool HaveMouseCapture() override;
 	void SetTrackMouseLeaveEvent(bool on);
 	bool PaintContains(PRectangle rc) override;
-	void ScrollText(int linesToMove) override;
+	void ScrollText(Sci::Line linesToMove) override;
 	void NotifyCaretMove() override;
 	void UpdateSystemCaret() override;
 	void SetVerticalScrollPos() override;
 	void SetHorizontalScrollPos() override;
-	bool ModifyScrollBars(int nMax, int nPage) override;
+	bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) override;
 	void NotifyChange() override;
 	void NotifyFocus(bool focus) override;
 	void SetCtrlID(int identifier) override;
@@ -361,7 +361,7 @@
 
 	int SetScrollInfo(int nBar, LPCSCROLLINFO lpsi, BOOL bRedraw);
 	bool GetScrollInfo(int nBar, LPSCROLLINFO lpsi);
-	void ChangeScrollPos(int barType, int pos);
+	void ChangeScrollPos(int barType, Sci::Position pos);
 	sptr_t GetTextLength();
 	sptr_t GetText(uptr_t wParam, sptr_t lParam);
 
@@ -618,7 +618,7 @@
 		}
 	}
 	inDragDrop = ddNone;
-	SetDragPosition(SelectionPosition(invalidPosition));
+	SetDragPosition(SelectionPosition(Sci::invalidPosition));
 }
 
 // Avoid warnings everywhere for old style casts by concentrating them here
@@ -730,8 +730,8 @@
 
 // Returns the target converted to UTF8.
 // Return the length in bytes.
-int ScintillaWin::TargetAsUTF8(char *text) {
-	int targetLength = targetEnd - targetStart;
+Sci::Position ScintillaWin::TargetAsUTF8(char *text) {
+	Sci::Position targetLength = targetEnd - targetStart;
 	if (IsUnicodeMode()) {
 		if (text) {
 			pdoc->GetCharRange(text, targetStart, targetLength);
@@ -752,8 +752,8 @@
 
 // Translates a nul terminated UTF8 string into the document encoding.
 // Return the length of the result in bytes.
-int ScintillaWin::EncodedFromUTF8(char *utf8, char *encoded) const {
-	int inputLength = (lengthForEncode >= 0) ? lengthForEncode : static_cast<int>(strlen(utf8));
+Sci::Position ScintillaWin::EncodedFromUTF8(char *utf8, char *encoded) const {
+	Sci::Position inputLength = (lengthForEncode >= 0) ? lengthForEncode : static_cast<Sci::Position>(strlen(utf8));
 	if (IsUnicodeMode()) {
 		if (encoded) {
 			memcpy(encoded, utf8, inputLength);
@@ -889,10 +889,10 @@
 	return codePage == 949 || codePage == 1361;
 }
 
-void ScintillaWin::MoveImeCarets(int offset) {
+void ScintillaWin::MoveImeCarets(Sci::Position offset) {
 	// Move carets relatively by bytes.
 	for (size_t r=0; r<sel.Count(); r++) {
-		int positionInsert = sel.Range(r).Start().Position();
+		Sci::Position positionInsert = sel.Range(r).Start().Position();
 		sel.Range(r).caret.SetPosition(positionInsert + offset);
 		sel.Range(r).anchor.SetPosition(positionInsert + offset);
 	}
@@ -908,7 +908,7 @@
 	}
 	pdoc->decorations.SetCurrentIndicator(indicator);
 	for (size_t r=0; r<sel.Count(); r++) {
-		int positionInsert = sel.Range(r).Start().Position();
+		Sci::Position positionInsert = sel.Range(r).Start().Position();
 		pdoc->DecorationFillRange(positionInsert - len, 1, len);
 	}
 }
@@ -928,10 +928,10 @@
 
 void ScintillaWin::SelectionToHangul() {
 	// Convert every hanja to hangul within the main range.
-	const int selStart = sel.RangeMain().Start().Position();
-	const int documentStrLen = sel.RangeMain().Length();
-	const int selEnd = selStart + documentStrLen;
-	const int utf16Len = pdoc->CountUTF16(selStart, selEnd);
+	const Sci::Position selStart = sel.RangeMain().Start().Position();
+	const Sci::Position documentStrLen = sel.RangeMain().Length();
+	const Sci::Position selEnd = selStart + documentStrLen;
+	const Sci::Position utf16Len = pdoc->CountUTF16(selStart, selEnd);
 
 	if (utf16Len > 0) {
 		std::string documentStr(documentStrLen, '\0');
@@ -957,7 +957,7 @@
 	if (sel.Count() > 1) {
 		return; // Do not allow multi carets.
 	}
-	int currentPos = CurrentPosition();
+	Sci::Position currentPos = CurrentPosition();
 	int oneCharLen = pdoc->LenChar(currentPos);
 
 	if (oneCharLen < 2) {
@@ -1091,7 +1091,7 @@
 
 		// Move IME caret from current last position to imeCaretPos.
 		int imeEndToImeCaretU16 = imc.GetImeCaretPos() - static_cast<unsigned int>(wcs.size());
-		int imeCaretPosDoc = pdoc->GetRelativePositionUTF16(CurrentPosition(), imeEndToImeCaretU16);
+		Sci::Position imeCaretPosDoc = pdoc->GetRelativePositionUTF16(CurrentPosition(), imeEndToImeCaretU16);
 
 		MoveImeCarets(- CurrentPosition() + imeCaretPosDoc);
 
@@ -1298,7 +1298,7 @@
 			// Either SCROLL or ZOOM. We handle the wheel steppings calculation
 			wheelDelta -= static_cast<short>(HiWord(wParam));
 			if (abs(wheelDelta) >= WHEEL_DELTA && linesPerScroll > 0) {
-				int linesToScroll = linesPerScroll;
+				Sci::Line linesToScroll = linesPerScroll;
 				if (linesPerScroll == WHEEL_PAGESCROLL)
 					linesToScroll = LinesOnScreen() - 1;
 				if (linesToScroll == 0) {
@@ -1663,8 +1663,8 @@
 			break;
 
 		case EM_SETSEL: {
-				int nStart = static_cast<int>(wParam);
-				int nEnd = static_cast<int>(lParam);
+				Sci::Position nStart = static_cast<Sci::Position>(wParam);
+				Sci::Position nEnd = static_cast<Sci::Position>(lParam);
 				if (nStart == 0 && nEnd == -1) {
 					nEnd = pdoc->Length();
 				}
@@ -1850,7 +1850,7 @@
 	return true;
 }
 
-void ScintillaWin::ScrollText(int /* linesToMove */) {
+void ScintillaWin::ScrollText(Sci::Line /* linesToMove */) {
 	//Platform::DebugPrintf("ScintillaWin::ScrollText %d\n", linesToMove);
 	//::ScrollWindow(MainHWND(), 0,
 	//	vs.lineHeight * linesToMove, 0, 0);
@@ -1883,7 +1883,7 @@
 }
 
 // Change the scroll position but avoid repaint if changing to same value
-void ScintillaWin::ChangeScrollPos(int barType, int pos) {
+void ScintillaWin::ChangeScrollPos(int barType, Sci::Position pos) {
 	SCROLLINFO sci = {
 		sizeof(sci), 0, 0, 0, 0, 0, 0
 	};
@@ -1904,14 +1904,14 @@
 	ChangeScrollPos(SB_HORZ, xOffset);
 }
 
-bool ScintillaWin::ModifyScrollBars(int nMax, int nPage) {
+bool ScintillaWin::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) {
 	bool modified = false;
 	SCROLLINFO sci = {
 		sizeof(sci), 0, 0, 0, 0, 0, 0
 	};
 	sci.fMask = SIF_PAGE | SIF_RANGE;
 	GetScrollInfo(SB_VERT, &sci);
-	int vertEndPreferred = nMax;
+	Sci::Line vertEndPreferred = nMax;
 	if (!verticalScrollBarVisible)
 		nPage = vertEndPreferred + 1;
 	if ((sci.nMin != 0) ||
@@ -1932,14 +1932,14 @@
 	int horizEndPreferred = scrollWidth;
 	if (horizEndPreferred < 0)
 		horizEndPreferred = 0;
-	unsigned int pageWidth = static_cast<unsigned int>(rcText.Width());
+	int pageWidth = static_cast<int>(rcText.Width());
 	if (!horizontalScrollBarVisible || Wrapping())
 		pageWidth = horizEndPreferred + 1;
 	sci.fMask = SIF_PAGE | SIF_RANGE;
 	GetScrollInfo(SB_HORZ, &sci);
 	if ((sci.nMin != 0) ||
 		(sci.nMax != horizEndPreferred) ||
-		(sci.nPage != pageWidth) ||
+		(sci.nPage != static_cast<unsigned int>(pageWidth)) ||
 	        (sci.nPos != 0)) {
 		sci.fMask = SIF_PAGE | SIF_RANGE;
 		sci.nMin = 0;
@@ -1949,7 +1949,7 @@
 		sci.nTrackPos = 1;
 		SetScrollInfo(SB_HORZ, &sci, TRUE);
 		modified = true;
-		if (scrollWidth < static_cast<int>(pageWidth)) {
+		if (scrollWidth < pageWidth) {
 			HorizontalScrollTo(0);
 		}
 	}
@@ -2673,13 +2673,13 @@
 LRESULT ScintillaWin::ImeOnReconvert(LPARAM lParam) {
 	// Reconversion on windows limits within one line without eol.
 	// Look around:   baseStart  <--  (|mainStart|  -- mainEnd)  --> baseEnd.
-	const int mainStart = sel.RangeMain().Start().Position();
-	const int mainEnd = sel.RangeMain().End().Position();
-	const int curLine = pdoc->LineFromPosition(mainStart);
+	const Sci::Position mainStart = sel.RangeMain().Start().Position();
+	const Sci::Position mainEnd = sel.RangeMain().End().Position();
+	const Sci::Line curLine = pdoc->LineFromPosition(mainStart);
 	if (curLine != pdoc->LineFromPosition(mainEnd))
 		return 0;
-	const int baseStart = pdoc->LineStart(curLine);
-	const int baseEnd = pdoc->LineEnd(curLine);
+	const Sci::Position baseStart = pdoc->LineStart(curLine);
+	const Sci::Position baseEnd = pdoc->LineEnd(curLine);
 	if ((baseStart == baseEnd) || (mainEnd > baseEnd))
 		return 0;
 
@@ -2730,8 +2730,8 @@
 
 	// Make place for next composition string to sit in.
 	for (size_t r=0; r<sel.Count(); r++) {
-		int rBase = sel.Range(r).Start().Position();
-		int docCompStart = rBase + adjust;
+		Sci::Position rBase = sel.Range(r).Start().Position();
+		Sci::Position docCompStart = rBase + adjust;
 
 		if (inOverstrike) { // the docCompLen of bytes will be overstriked.
 			sel.Range(r).caret.SetPosition(docCompStart);
@@ -2739,8 +2739,8 @@
 		} else {
 			// Ensure docCompStart+docCompLen be not beyond lineEnd.
 			// since docCompLen by byte might break eol.
-			int lineEnd = pdoc->LineEnd(pdoc->LineFromPosition(rBase));
-			int overflow = (docCompStart + docCompLen) - lineEnd;
+			Sci::Position lineEnd = pdoc->LineEnd(pdoc->LineFromPosition(rBase));
+			Sci::Position overflow = (docCompStart + docCompLen) - lineEnd;
 			if (overflow > 0) {
 				pdoc->DeleteChars(docCompStart, docCompLen - overflow);
 			} else {
@@ -2833,7 +2833,7 @@
 	//Platform::DebugPrintf("ScrollInfo %d mask=%x min=%d max=%d page=%d pos=%d track=%d\n", b,sci.fMask,
 	//sci.nMin, sci.nMax, sci.nPage, sci.nPos, sci.nTrackPos);
 
-	int topLineNew = topLine;
+	Sci::Line topLineNew = topLine;
 	switch (LoWord(wParam)) {
 	case SB_LINEUP:
 		topLineNew -= 1;
@@ -3038,7 +3038,7 @@
 
 STDMETHODIMP ScintillaWin::DragLeave() {
 	try {
-		SetDragPosition(SelectionPosition(invalidPosition));
+		SetDragPosition(SelectionPosition(Sci::invalidPosition));
 		return S_OK;
 	} catch (...) {
 		errorStatus = SC_STATUS_FAILURE;
@@ -3054,7 +3054,7 @@
 		if (pIDataSource == NULL)
 			return E_POINTER;
 
-		SetDragPosition(SelectionPosition(invalidPosition));
+		SetDragPosition(SelectionPosition(Sci::invalidPosition));
 
 		STGMEDIUM medium = {0, {0}, 0};
 
